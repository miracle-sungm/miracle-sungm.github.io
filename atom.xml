<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miracle&#39;s Blog</title>
  
  <subtitle>Miracles happen every day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-26T02:05:53.410Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sungm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发编程] 15. 线程通信</title>
    <link href="http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-21T11:22:17.000Z</published>
    <updated>2020-08-26T02:05:53.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过共享对象实现线程通信"><a href="#1-通过共享对象实现线程通信" class="headerlink" title="1. 通过共享对象实现线程通信"></a>1. 通过共享对象实现线程通信</h3><p>线程通过在共享对象中发送一个信号实现与其他线程通信。如下图所示，设置一个成员变量 hasProcess，线程A通过setHasProcess同步方法设置hasProcess的值，这样线程B可以读取到成员变量hasProcess的值，实现线程之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MySignal &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasProcess &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void setHasProcess(boolean hasProcess) &#123; this.hasProcess &#x3D; hasProcess; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean getHasProcess() &#123; return this.hasProcess; &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A和线程B必须引用共享对象 MySignal 的实例来实现线程A与线程B之间的线程通信。如果线程A和线程B引用了不同的MySignal实例对象，那么线程A和线程B不会检测到彼此发送的信号，达不到线程通信的目的。</p><hr><h3 id="2-Busy-Wait"><a href="#2-Busy-Wait" class="headerlink" title="2. Busy Wait"></a>2. Busy Wait</h3><p>上例中线程B需要等待信号处理数据，因此它的业务代码很可能一直在等待信号，浪费了很多CPU资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySignal singal &#x3D; ...</span><br><span class="line"></span><br><span class="line">while (!singal.getHasProcess()) &#123;</span><br><span class="line">    &#x2F;&#x2F;do nothing... busy waiting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们不知道线程A什么时候发送信号，因此导致线程B一直等待线程A的信号，没做任何事情，浪费CPU资源。</p><hr><h3 id="3-等待通知机制：wait-、notify-、notifyAll"><a href="#3-等待通知机制：wait-、notify-、notifyAll" class="headerlink" title="3. 等待通知机制：wait()、notify()、notifyAll()"></a>3. 等待通知机制：wait()、notify()、notifyAll()</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-通过共享对象实现线程通信&quot;&gt;&lt;a href=&quot;#1-通过共享对象实现线程通信&quot; class=&quot;headerlink&quot; title=&quot;1. 通过共享对象实现线程通信&quot;&gt;&lt;/a&gt;1. 通过共享对象实现线程通信&lt;/h3&gt;&lt;p&gt;线程通过在共享对象中发送一个信号实现与其
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 14. ThreadLocal</title>
    <link href="http://yoursite.com/2020/08/21/ThreadLocal/"/>
    <id>http://yoursite.com/2020/08/21/ThreadLocal/</id>
    <published>2020-08-21T02:45:56.000Z</published>
    <updated>2020-08-21T11:20:57.464Z</updated>
    
    <content type="html"><![CDATA[<p>Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 ThreadLocal 类以一种非常简单的方式确保了线程安全。</p><p>建议: 看这篇博客的同时，阅读一遍 java.lang.ThreadLocal 的源码，相信您从源码中获取的知识点会更多一些。</p><h3 id="1-创建一个线程变量"><a href="#1-创建一个线程变量" class="headerlink" title="1. 创建一个线程变量"></a>1. 创建一个线程变量</h3><p>我们可以通过下面这种方式创建一个ThreadLocal对象，我们还可以给它指定泛型类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这个代码只需要执行一次。然后线程就可以对它设置值（set）或者读取值（get），每个线程只能获取到它们自己设置的值。</p><hr><h3 id="2-设置-ThreadLocal-的值"><a href="#2-设置-ThreadLocal-的值" class="headerlink" title="2. 设置 ThreadLocal 的值"></a>2. 设置 ThreadLocal 的值</h3><p>一旦创建了ThreadLocal对象，就可以设置ThreadLocal的值，我们通过set()方法设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="2-获取-ThreadLocal-的值"><a href="#2-获取-ThreadLocal-的值" class="headerlink" title="2. 获取 ThreadLocal 的值"></a>2. 获取 ThreadLocal 的值</h3><p>通过get()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure><hr><h3 id="3-移除-ThreadLocal-的值"><a href="#3-移除-ThreadLocal-的值" class="headerlink" title="3. 移除 ThreadLocal 的值"></a>3. 移除 ThreadLocal 的值</h3><p>通过remove()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure><hr><h3 id="4-ThreadLocal-泛型"><a href="#4-ThreadLocal-泛型" class="headerlink" title="4. ThreadLocal 泛型"></a>4. ThreadLocal 泛型</h3><p>我们可以给ThreadLocal指定泛型类型，指定泛型类型之后只能设置泛型类型的值，另外，获取ThreadLocal的值时不需要做类型转换。</p><p>正如我们上面提出的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定泛型类型为String</span><br><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置值</span><br><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值</span><br><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 13. volatile关键字</title>
    <link href="http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-19T13:01:24.000Z</published>
    <updated>2020-08-26T02:08:25.023Z</updated>
    
    <content type="html"><![CDATA[<p>volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。</p><p>实际上，自 Java 5 起，volatile 关键字不仅仅保证从主内存中读取数据或者写回数据至主内存中。下面一起来探索下 volatile 关键字的作用吧。</p><h3 id="1-volatile-可见性问题"><a href="#1-volatile-可见性问题" class="headerlink" title="1. volatile 可见性问题"></a>1. volatile 可见性问题</h3><p>volatile 关键字保证了当某个线程改变了 volatile 变量的值时对其他线程可见。</p><p>在多线程应用系统中，线程操作 non-volatile 变量时，每个线程会拷贝 non-volatile 变量（拷贝引用）至CPU高速缓存中。如果你的计算机包含多个CPU，每个线程在不同的CPU上运行时，这就意味着每个线程拷贝这些变量至不同的CPU的CPU高速缓存中，如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" alt></div></p><p>对于 non-volatile 变量，JVM每次读取变量数据时不会保证从主内存中拷贝至CPU高速缓存中，或者每次写数据时不会保证把CPU高速缓存的数据写回至主内存中。</p><p>下面我们来看个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，有2个线程，第一个线程对 count 的值做修改，第二个的线程能读取到 count 被修改后的值吗？？？</p><p>由于这个 count 变量没有被 volatile 关键字声明，当2个CPU运行的2个线程分别读取 count 的值时，会从主内存中将count的值拷贝至各自的CPU高速缓存中，其中一个线程修改count的值，由于它没有被volatile声明，因此不会保证被修改后的值写回至主内存中。请看下图：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" alt></div></p><p>由于count变量值被修改后没有写回主内存中，并且线程每次读取count变量值也没有保证从主内存中读取，这个问题被称为数据可见性问题，我们可以通过使用volatile关键字解决数据可见性问题，也可以使用其他方式解决。</p><hr><h3 id="2-volatile-可见性保证"><a href="#2-volatile-可见性保证" class="headerlink" title="2. volatile 可见性保证"></a>2. volatile 可见性保证</h3><p>volatile 关键字解决了数据可见性问题。通过使用 volatile 关键字声明变量是一个volatile变量，保证了每次读取变量数据时从主内存读取，写数据时把数据写回主内存中。</p><p>通过 volatile 声明变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public volatile int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的这种情况，当线程一修改了count的值，线程二没有修改count的值，只读取了count的值，这种情况下，使用volatile关键字声明count变量足够保证数据的线程二读取到的是最新的数据。</p><p><strong>注意：当存在多个线程对同一个共享变量做修改操作时，使用volatile是远远不够的，volatile关键字只能保证数据可见性，并不能保证数据操作是原子性的，我们可以使用synchronized关键字或者Java提供的JUC工具包。</strong></p><h5 id="2-1-所有变量可见性保证"><a href="#2-1-所有变量可见性保证" class="headerlink" title="2.1 所有变量可见性保证"></a>2.1 所有变量可见性保证</h5><p>实际上，volatile 关键字的作用超越了 volatile 变量本身，有更多的作用。包括：</p><blockquote><ul><li>当某个线程写回volatile变量的值至主内存时，这个<strong>线程可见的所有变量的值</strong>都会写回至主内存中</li><li>当某个线程从主内存中读取volatile变量的值时，这个<strong>线程可见的所有变量的值</strong>都会重新从主内存中读取</li></ul></blockquote><p>上面提到的这些内容我们在博客<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">[Java 并发编程] 11. Java Happen Before Guarantee</a>提到过，这里不再举例证明。</p><hr><h3 id="3-指令重排挑战"><a href="#3-指令重排挑战" class="headerlink" title="3. 指令重排挑战"></a>3. 指令重排挑战</h3><p>JVM和CPU为了提升性能允许指令重排，只要满足语义不变（单线程情况下执行结果不变）即可指令重排。</p><p>请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>指令重排后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line">int b &#x3D; 2;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>然而，当一个变量被volatile修饰时，存在一些指令重排的挑战。请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int years;</span><br><span class="line">    private int months</span><br><span class="line">    private volatile int days;</span><br><span class="line"></span><br><span class="line">    public void update(int years, int months, int days)&#123;</span><br><span class="line">        this.years  &#x3D; years;</span><br><span class="line">        this.months &#x3D; months;</span><br><span class="line">        this.days   &#x3D; days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦执行上面的update()方法，执行到修改days的指令时，years和months修改后的值也会被写回到主内存中。但是如果发生了指令重排，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void update(int years, int months, int days)&#123;</span><br><span class="line">    this.days   &#x3D; days;</span><br><span class="line">    this.years  &#x3D; years;</span><br><span class="line">    this.months &#x3D; months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样执行到days修改的指令时，years和months的值也会被写回到主内存中，但此时years和months的值未被修改（指令重排导致years和months修改的指令在days指令下面），写回数据至主内存的操作发生在years和months修改指令的前面，当执行完years和months的修改指令后，不会同步数据至主内存，因此years和months的新值对其他线程不可见（未使用volatile关键字），这样的指令重排导致程序的语义发生了改变。</p><p>Java 有解决这个问题，让我们看下一章节。</p><h3 id="4-volatile-happens-before-保证"><a href="#4-volatile-happens-before-保证" class="headerlink" title="4. volatile happens-before 保证"></a>4. volatile happens-before 保证</h3><p>为了解决指令重排可能产生的问题，java volatile 关键字除了提供可见性保证之外，还提供提供了happens-before保证，如下：</p><blockquote><ul><li>当其他变量的读写指令原本就在volatile写指令前面时，那么其他变量的读写指令不会被重排序到 volatile 写指令后面。（请注意：这里只提出了原本在volatile变量写指令前面的指令，不会被重排序到volatile指令后面，原本在volatile写指令前面的指令之间可以发生指令重排。）</li><li>当其他变量的读写指令原本就在volatile读指令后面时，那么其他变量的读写指令不会被重排序到 volatile 读指令前面。（同样：原本在 volatile 读指令后面的指令之间可以发生指令重排）</li></ul></blockquote><h3 id="5-volatile-不足"><a href="#5-volatile-不足" class="headerlink" title="5. volatile 不足"></a>5. volatile 不足</h3><p>即使 volatile 关键字保证了线程每次读取 volatile 变量时从主内存中读取数据，每次写数据时把数据写回主内存中，但在一些情况下，声明volatile变量是不够的。</p><p>上面我们提到过当一个线程修改volatile变量时，能保证其他线程可以读取到volatile变量的最新值。</p><p>事实上，在多个线程修改volatile变量的情况下，也能确保最新值被写回到主内存中。但这样可能会存在一些问题，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int totalPrice &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public int addPrice(int price) &#123;</span><br><span class="line">    totalPrice +&#x3D; price;</span><br><span class="line">    return totalPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initTotalPrice() &#123;</span><br><span class="line">    totalPrice &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程一、线程二分别在执行addPrice()方法和initTotalPrice()方法时，线程一执行完totalPrice += price指令后，把totalPrice的最新值刷回到主内存中，若此时线程二正巧执行完initTotalPrice()方法，totalPrice的值被重新刷回0，当线程一再读取totalPrice值并返回，导致最终返回的值是0，这可能不是我们程序最终想要的结果。（备注：当然我们不会去写这种程序代码，这个示例我只用来说明问题，并没有实际测试过这种场景。）</p><p>上例其实就是为了说明一个问题：<strong>volatile 只是保证了数据的可见性，并没有保证原子性，如果要执行原子性操作，使用volatile关键字是远远不够的。这里顺便提一下，synchronized关键字不仅保证了数据可见性，同时也保证了原子性。</strong></p><p>再来看下一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明volatile变量</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自增</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>当2个线程同时对变量 i 做自增操作，当他们同时把 i 的值写回到主内存中时，最终写回的值时1，实际上i做了2次自增。</p><p>因此：在多个线程同时存在修改共享数据的情况时，仅仅使用volatile变量是不够的。请记住：volatile 关键字只保证了数据可见性，并不保证原子性。</p><h3 id="6-什么时候使用-volatile"><a href="#6-什么时候使用-volatile" class="headerlink" title="6. 什么时候使用 volatile ?"></a>6. 什么时候使用 volatile ?</h3><p>正如前面提到的，如果多个线程同时对共享数据进行读写操作，这种情况下使用volatile关键字是不够的。我们需要使用synchronized关键字保证数据读写的可见性和原子性。</p><p>除了使用synchronized关键字之外，我们还可以使用 java.util.concurrent 包提供的各种工具类，比如 AtomicLong 、 AtomicReference 等等。</p><p>当只有一个线程会对共享变量的值进行修改，其他的线程只读取共享变量的值时，我们使用volatile关键字是足够的。</p><p>另外: volatile 关键字工作在32位或者64位的变量上。</p><h3 id="7-volatile-性能考虑"><a href="#7-volatile-性能考虑" class="headerlink" title="7. volatile 性能考虑"></a>7. volatile 性能考虑</h3><p>我们都知道，CPU操作CPU高速缓存的速度远远快于操作主内存的速度。CPU每次操作volatile关键字都会操作主内存会带来额外的性能开销。另外，volatile 关键字防止指令重排是正常性能增强技术。在条件允许的情况下，使用volatile关键字代替synchronized代码块能节省性能开销。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。&lt;/p&gt;
&lt;p&gt;实际上，自 Ja
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 12. synchronized关键字</title>
    <link href="http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-16T06:56:35.000Z</published>
    <updated>2020-08-26T02:08:25.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-synchronized-同步机制"><a href="#1-synchronized-同步机制" class="headerlink" title="1. synchronized 同步机制"></a>1. synchronized 同步机制</h3><p>synchronized 同步机制是 Java 第一个多线程同步访问共享对象（数据）的机制。显然刚开始的时候Java 同步机制不是很好，因此在 jdk 1.5 提出了一些并发工具类帮助开发者实现比synchronized同步机制更好的并发控制。随着 jdk 版本的不断更新发布，synchronized 关键的性能已经做了很多的优化，在多数情况下，使用 synchronized 关键字能够满足并发控制。</p><hr><h3 id="2-synchronized-关键字"><a href="#2-synchronized-关键字" class="headerlink" title="2. synchronized 关键字"></a>2. synchronized 关键字</h3><p>通过 synchronized 关键字标记 synchronized 代码块。Java 中 synchronized 代码块是在某个对象上做同步（这个对象我们称为锁），所有作用在某个对象的同步代码块同时只能被一个执行，其他线程尝试执行同步代码块时必须等待正在执行同步代码块的线程退出之后才能进入同步代码块。</p><p>synchronized 关键字三种用法：</p><ul><li>作用于实例方法（普通方法）</li><li>作用于静态方法</li><li>作用于代码块</li></ul><p>建议：在需要使用synchronized 关键字时，首先考虑作用于代码块，其次是普通方法，最后是静态方法（代码块 &gt; 普通方法 &gt; 静态方法）。</p><h5 id="2-1-作用于普通方法"><a href="#2-1-作用于普通方法" class="headerlink" title="2.1 作用于普通方法"></a>2.1 作用于普通方法</h5><p>通过使用 synchronized 关键字声明一个同步的普通方法。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyCounter &#123;</span><br><span class="line"></span><br><span class="line">  private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public synchronized void add(int value)&#123;</span><br><span class="line">      this.count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用  声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步实例方法：给当前实例对象加锁，当某个线程进入执行synchronized实例方法时需要获取当前实例对象的锁。因此当synchronized作用于普通方法时，每个实例的同步方法只作用于自己的实例对象。</strong></p><p><strong>只有一个线程可以执行实例同步方法。如果存在多个线程，那么只有一个线程能够同时执行实例同步方法，其他线程必须等待正在执行同步方法的线程执行完毕同步方法，获取到实例锁之后才能执行同步方法。</strong></p><h5 id="2-2-作用于静态方法"><a href="#2-2-作用于静态方法" class="headerlink" title="2.2 作用于静态方法"></a>2.2 作用于静态方法</h5><p>通过使用 synchronized 关键字声明一个同步的静态方法，与普通方法不同的是，静态方法需要通过 static 关键字声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">      count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用 synchronized 声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步静态方法：给当前类的 class 对象加锁，当某个线程进入synchronized静态方法时需要获取当前类的class对象的锁。</strong></p><p><strong>因为JVM中每个类只有一个class对象，因此只有一个线程能够同时执行静态同步方法。</strong></p><p>如果一个类声明了多个静态同步方法，只有一个线程可以同时执行这些方法。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">    count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static synchronized void subtract(int value)&#123;</span><br><span class="line">    count -&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于静态同步方法的锁作用于当前类的class对象，所以当多个线程需要执行同一个类中声明的不同的静态同步方法时，同一时间只有一个线程能拿到类的class对象锁，因此只有一个线程能在给定的时间内执行某个静态方法。</p><p>上例中声明了2个静态同步方法，分别是add()方法和subtract()方法，当某个线程执行add()方法时，其他线程只能等待正在执行add()方法执行完毕，并释放类的class对象锁后，才能获取到锁并执行对应的静态同步方法。</p><h5 id="2-3-作用于代码块"><a href="#2-3-作用于代码块" class="headerlink" title="2.3 作用于代码块"></a>2.3 作用于代码块</h5><p>通常情况下，我们不需要同步整个方法，可以在方法内部声明同步代码块，当多个线程执行到同步代码时，使线程的变得同步执行。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (object) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：object 表示接收某个对象作为锁，可以是任意对象，也可以是class对象。</strong> </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void add(int value)&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">       this.count +&#x3D; value;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上例中通过使用synchronized标记这段代码块是同步的，当多个线程需要执行这段代码时，线程会变得同步执行。</p><p>synchronized代码块接收一个对象作为同步锁，只有获取到同步锁才能执行同步代码，这个对象可以是我们自定义的任意对象，包括class对象。通常包括下面三种情况：</p><blockquote><ul><li>this 对象</li><li>class 对象</li><li>其他自定义对象</li></ul></blockquote><h6 id="2-3-1-this对象作为synchronized同步代码块的锁"><a href="#2-3-1-this对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.1 this对象作为synchronized同步代码块的锁"></a>2.3.1 this对象作为synchronized同步代码块的锁</h6><p>当以this对象（表示当前实例对象）作为同步代码块的锁时，只有获取到当前实例对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：如果某个线程正在执行log2()方法中的同步代码块，那么会阻塞其他线程执行log1()方法和log2()方法中的同步代码块（log1方法是普通同步方法，也是以当前实例对象作为锁）。</p><p>以this为对象锁的同步代码块，和普通同步方法的锁对象相同，都是某个实例对象作为同步锁。这种情况下，我们要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-class对象作为synchronized同步代码块的锁"><a href="#2-3-2-class对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 class对象作为synchronized同步代码块的锁"></a>2.3.2 class对象作为synchronized同步代码块的锁</h6><p>当以class对象作为同步代码块的锁时，只有获取到class对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (MyClass.class) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：当某个线程正在执行log1()方法中的同步代码块或者log2()方法时，会阻塞其他线程执行这两个方法中的任意一个方法。</p><p>以class为对象锁的同步代码块，和静态同步方法的锁对象相同，都是某个类的class对象作为同步锁。这种情况下，我们也要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-其他对象作为synchronized同步代码块的锁"><a href="#2-3-2-其他对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 其他对象作为synchronized同步代码块的锁"></a>2.3.2 其他对象作为synchronized同步代码块的锁</h6><p>可以指定任意对象作为同步代码块的对象锁，通常情况下我们使用共享资源对象作为指定的对象锁。备注：如果存在多个共享资源，那么一定要注意锁的顺序，有效防止死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    private String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (lock) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以任意自定义对象作为锁时，似乎要比以this对象和class对象作为synchronized同步锁要灵活的多，不过也要根据场景来使用不同的对象作为同步锁。</p><h6 id="2-3-3-Lambda-表达式中的同步代码块"><a href="#2-3-3-Lambda-表达式中的同步代码块" class="headerlink" title="2.3.3 Lambda 表达式中的同步代码块"></a>2.3.3 Lambda 表达式中的同步代码块</h6><p>我们可以在Lambda表达式中声明synchronized同步代码块，其使用方式跟我们上面提到的知识点是一样的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; s -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F;do something...</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-synchronized-数据可见性"><a href="#3-synchronized-数据可见性" class="headerlink" title="3. synchronized 数据可见性"></a>3. synchronized 数据可见性</h3><p>上一篇博客我们讲<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">《Java Happens Before Guarantee》</a> 时提到过 volatile 关键字和 synchronize 关键字的数据可见性保证。</p><p>这里我们简单回忆一下：没有使用 volatile 关键字或 synchronized 关键字时，当某个线程改变了共享资源的值时对其他线程不可见，原因是不会保证存储于CPU寄存器或者CPU高速缓存的数据重新写回主内存中。</p><p>synchronized 数据可见性：<strong>通过使用synchronized关键字声明同步方法或者同步代码块时，某个线程进入synchronized代码块时，会从主内存中读取最新的数据保存至CPU高速缓存或者CPU寄存器中；当某个线程退出synchronized代码块时，会将CPU寄存器中最新的数据刷回到CPU高速缓存中，再将CPU高速缓存中的最新数据刷新到主内存中，以此保证数据可见性。</strong></p><hr><h3 id="4-synchronized-和指令重排"><a href="#4-synchronized-和指令重排" class="headerlink" title="4. synchronized 和指令重排"></a>4. synchronized 和指令重排</h3><p>上一篇博客中提到过： synchronized 在一定程度上限制了指令重排。</p><p>JVM 和 CPU 为了让程序更快的执行，允许指令重排，通过指令重排让指令并行执行。（前提条件是并行执行的指令没有依赖关系，也就是重排的指令之间不存在依赖关系）</p><p>指令重排在多线程中可能会产生一些问题，比如synchronized同步代码块中写一个变量的代码被重排到synchronized外面。为了防止这种问题产生，synchronized 关键字限制了一些指令重排的发生（与volatile关键字限制指令重排相似）。</p><p>最终的结果是：你可以确定你的代码正确的工作 ———— synchronized限制了指令重排的发生。</p><hr><h3 id="5-什么对象用来做同步对象锁？"><a href="#5-什么对象用来做同步对象锁？" class="headerlink" title="5. 什么对象用来做同步对象锁？"></a>5. 什么对象用来做同步对象锁？</h3><p>正如我们前面多次提到的一样，synchronized 关键字必须作用于某个对象上做同步（通常情况下我们称这个对象为同步对象锁）。</p><p>你可以使用任意对象作为同步对象锁，但是不建议你使用某些String类型的对象和原始基本数据类型的包装类对象作为同步对象锁。因为编译器会优化它们，最终的结果是当你使用他们在不同的同步代码块中作为对象锁时，你以为你使用了不同的对象作为对象锁，实际上只使用了同一个对象作为对象锁。</p><p>出于安全考虑，使用 this 对象或者 new Object() 作为同步对象锁，这种情况下不会被Java编译器或JVM缓存。</p><hr><h3 id="6-synchronized-代码块的限制和替代品"><a href="#6-synchronized-代码块的限制和替代品" class="headerlink" title="6. synchronized 代码块的限制和替代品"></a>6. synchronized 代码块的限制和替代品</h3><p>Java 中的 synchronized代码块存在一些限制，比如同一时间只允许一个线程进入同步代码块。如果多个线程只读取共享数据，不更新共享数据，这是线程安全的，这种情况下我们可以使用 Read / Write Lock 代替 synchronized 代码块。</p><p>你想要多个线程进入同步代码块还是只是一个线程进入同步代码块？我们可以通过使用 Semaphore（计数信号量：限流的作用） 来实现指定数量的线程进入同步代码块(这个点说的同步代码块不是指synchronized代码块)，后面的博客我们来讲解这种实现方式。</p><p>synchronized代码块不会保证等待线程按顺序执行同步代码块。如果我们需要线程按顺序执行同步代码块，可以通过实现 Fairness（公平锁） 来达到这个目的。</p><p>如果只有一个线程修改共享变量，其他的线程只读取共享变量的值，我们可以使用 volatile 关键字，不需要任何同步代码块。</p><hr><h3 id="7-synchronized-性能消耗"><a href="#7-synchronized-性能消耗" class="headerlink" title="7. synchronized 性能消耗"></a>7. synchronized 性能消耗</h3><p>当线程进入和退出 synchronized 代码块时存在一些性能消耗。随着 JDK 版本的发布，性能的消耗变得越来越小，但是使用synchronized代码块还是不可避免地需要付出一些代价。</p><p>如果在循环内不断地进入和退出同步代码块，无疑会让放大性能的损耗。</p><p>尽量避免大的同步代码块，换句话说，只把真正需要的同步操作的代码放进同步代码块，避免其他线程执行不需要同步操作的代码时造成阻塞，同时也能提高执行代码的性能。</p><hr><h3 id="8-synchronized-锁重入"><a href="#8-synchronized-锁重入" class="headerlink" title="8. synchronized 锁重入"></a>8. synchronized 锁重入</h3><p>锁重入：当一个线程进入某个同步代码块时，线程持有同步代码块的同步锁，若同步代码块还调用了具有相同同步锁的同步代码块，线程不需要再次获取锁，可以直接进入相同同步锁的其他同步代码块。</p><p>synchronized 支持锁重入。</p><p>备注：设计多重同步代码块时，需要合理的设计，错误的实现容易导致死锁产生，保持同步代码的锁的顺序一致是一种设计方案。</p><hr><h3 id="9-集群中的-synchronized-代码块"><a href="#9-集群中的-synchronized-代码块" class="headerlink" title="9. 集群中的 synchronized 代码块"></a>9. 集群中的 synchronized 代码块</h3><p>请记住：synchronized 代码块只针对于同一个 JVM 中不同的线程能起到同步作用，如果你拥有相同的 Java 应用程序在多个 JVM 上面运行 ———— 集群，可能导致每个JVM都有一个线程在同时访问共享资源。 </p><p>如果你需要所有的JVM同步访问共享资源，可以使用其他的同步机制，而不是使用 synchronized 代码块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-synchronized-同步机制&quot;&gt;&lt;a href=&quot;#1-synchronized-同步机制&quot; class=&quot;headerlink&quot; title=&quot;1. synchronized 同步机制&quot;&gt;&lt;/a&gt;1. synchronized 同步机制&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 11. Java Happen Before Guarantee</title>
    <link href="http://yoursite.com/2020/08/14/Guarantee/"/>
    <id>http://yoursite.com/2020/08/14/Guarantee/</id>
    <published>2020-08-14T09:11:03.000Z</published>
    <updated>2020-08-26T02:08:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。</p><h3 id="1-指令重排"><a href="#1-指令重排" class="headerlink" title="1. 指令重排"></a>1. 指令重排</h3><p>现代计算机有能力并行执行指令，当一个指令不依赖其他指令时，可能发生指令重排。如下所示：两个指令不相互依赖，计算机可以并行执行这两个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e + f;</span><br></pre></td></tr></table></figure><p>下面这2个指令不会发生指令重排，因为第二个指令依赖第一个指令产生的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a + e;</span><br></pre></td></tr></table></figure><p>指令重排的结果可以让指令在CPU中并行执行，以提高性能。指令重排在JVM和CPU中是被允许的，前提是程序中的语句没有发生改变。指令重排后程序执行的结果必须与没有指令重排时程序执行的结果保持一致。</p><hr><h3 id="2-指令重排在多CPU计算机中的问题"><a href="#2-指令重排在多CPU计算机中的问题" class="headerlink" title="2. 指令重排在多CPU计算机中的问题"></a>2. 指令重排在多CPU计算机中的问题</h3><p>指令重排在多线程、多CPU系统中存在一些挑战。请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int a &#x3D; 0;</span><br><span class="line">private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;有点意思&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>在第一个线程中，a = 1 与 b = 1 两个指令不相互影响，CPU为了提高执行性能，可能并行执行这两个指令，这种情况下， b = 1 指令可能在 a = 1 前面执行，若执行 b = 1 后（假定 a = 1 指令还未执行，此时 a 的值为初始值 0），此时第二个线程正在执行判断条件 a == 0 &amp;&amp; b == 1，那么将会打印数据 ‘有点意思’。为了验证这个问题，我们来循环执行这段代码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-08-13 15:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int a &#x3D; 0;</span><br><span class="line">    private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    System.out.println(&quot;有点意思&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            a &#x3D; 0;</span><br><span class="line">            b &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这段代码有意思，不妨自己试一试。多等待一会，你会发现控制台输出了“有点意思”。</p><hr><h3 id="3-volatile-可见性保证"><a href="#3-volatile-可见性保证" class="headerlink" title="3. volatile 可见性保证"></a>3. volatile 可见性保证</h3><p>Java volatile 关键字提供了读写的可见性保证，当线程读volatile变量时会从主内存中读取数据，当线程修改volatile变量时会将变量的值写回到主内存中。这种同步到主内存的机制保证了变量的值对其他线程可见，这就是volatile可见性保证。</p><h5 id="3-1-volatile-修改数据可见性保证"><a href="#3-1-volatile-修改数据可见性保证" class="headerlink" title="3.1 volatile 修改数据可见性保证"></a>3.1 volatile 修改数据可见性保证</h5><p>当线程修改volatile变量的值时，修改后的值会被同步到主内存中。另外，<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。（请注意这句话，线程所有的变量都会随volatile变量写回到主内存中，不只是volatile变量写回到主内存中）</strong></p><p>请看示例：<br>(1) 首先我们用简单的代码证明使用 volatile 定义的变量的值被某个线程修改后对其他线程可见。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意这里没有使用volatile关键字</span><br><span class="line">    private boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public boolean isKeepRunning() &#123;</span><br><span class="line">        return keepRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;子线程把keepRunning的值改为true</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程中循环尝试获取子线程修改后的keepRunning的值，如果获取到，输出有点意思</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (myRunnable.isKeepRunning()) &#123;</span><br><span class="line">            System.out.println(&quot;有点意思&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你亲手运行了这段代码，你会发现这个程序永远不会输出“有点意思”。现在我们使用volatile定义keepRunning属性，其他代码不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用volatile定义</span><br><span class="line">private volatile boolean keepRunning &#x3D; false;</span><br></pre></td></tr></table></figure><p>使用volatile关键字后，程序循环输出“有点意思”。</p><p><strong>因此我们可以得出结论：volatile 定义的变量的值被某个线程修改后对其他线程可见。</strong></p><p>(2) 现在我们来证明下我们前面说的：<strong>线程里包含的所有变量都会随 volatile 变量写回到主内存中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用了 volatile 关键字的属性</span><br><span class="line">    private volatile boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;未使用 volatile 关键字的属性</span><br><span class="line">    private String strA &#x3D; &quot;A&quot;;</span><br><span class="line">    private String strB &#x3D; &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">        strA &#x3D; &quot;a&quot;;</span><br><span class="line">        strB &#x3D; &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyRunnable&#123;&quot; +</span><br><span class="line">                &quot;keepRunning&#x3D;&quot; + keepRunning +</span><br><span class="line">                &quot;, strA&#x3D;&#39;&quot; + strA + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, strB&#x3D;&#39;&quot; + strB + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(200L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(myRunnable.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序最终输出：MyRunnable{keepRunning=true, strA=’a’, strB=’b’}</p><p>这个结果我们不难看出：子线程修改了keepRunning、strA和strB的值（strA和strB未使用volatile关键字），主线程不仅读取到了keepRunning更新后的值，还读取到了strA和strB更新后的值。所以请记住：<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。</strong></p><h5 id="3-2-volatile-读取数据可见性保证"><a href="#3-2-volatile-读取数据可见性保证" class="headerlink" title="3.2 volatile 读取数据可见性保证"></a>3.2 volatile 读取数据可见性保证</h5><p>当线程读取被 volatile 关键字修饰的变量时，会从主内存中读取。<strong>另外：线程里所有的变量都会随着 volatile 变量读取到CPU缓存或者寄存器中。</strong></p><p>比如下面三个变量，当线程读取strA的值时，会重定向到主内存中读取strA的值，如果strB，strC同样在线程中，也会从主内存中读取strB，strC的值。我们本章3.1节的例子同样能证明此特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valatile String strA &#x3D; &quot;A&quot;;</span><br><span class="line">String strB &#x3D; &quot;B&quot;;</span><br><span class="line">String strC &#x3D; &quot;C&quot;;</span><br></pre></td></tr></table></figure><h5 id="3-3-volatile-happens-before-保证"><a href="#3-3-volatile-happens-before-保证" class="headerlink" title="3.3 volatile happens-before 保证"></a>3.3 volatile happens-before 保证</h5><p>volatile happens-before 保证设置了一些关于volatile变量指令重排的限制（规定）。</p><p><strong>volatile write happens-before guarantee</strong></p><p>volatile write happens-before guarantee: <strong>所有volatile写之前的指令不允许被重排序到volatile指令后面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>示例中 nonVolatileVariableA、nonVolatileVariableB两个变量是没有被volatile修饰的变量，volatileVariableC变量被volatile修饰。volatile write happens-before 保证了前面两个指令不能重排序到第三个指令后面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br></pre></td></tr></table></figure><p>但是示例可能会发生下面这种重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p><strong>volatile read happens-before guarantee</strong></p><p>volatile read happens-before guarantee: <strong>所有volatile读之后的指令不允许被重排序到volatile指令前面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br></pre></td></tr></table></figure><p>volatile read happens-before 保证了最后两个指令不能重排序到第一个指令前面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">volatileVariableC;</span><br></pre></td></tr></table></figure><p>示例可能会发生下面这种重排序的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">nonVolatileVariableA;</span><br></pre></td></tr></table></figure><p><strong>总结volatile happens-before guarantee：所有volatile写之前的指令不允许被重排序到volatile指令后面；所有volatile读之后的指令不允许被重排序到volatile指令前面。（简记：volatile写之前读之后）</strong></p><hr><h3 id="4-synchronized-可见性保证"><a href="#4-synchronized-可见性保证" class="headerlink" title="4. synchronized 可见性保证"></a>4. synchronized 可见性保证</h3><p>synchronized 可见性保证 与 volatile 可见性保证非常相似。</p><h5 id="4-1-synchronized-锁进入可见性保证"><a href="#4-1-synchronized-锁进入可见性保证" class="headerlink" title="4.1 synchronized 锁进入可见性保证"></a>4.1 synchronized 锁进入可见性保证</h5><p>当一个进程进入 synchronized同步代码块（或同步方法），线程内所有可见变量都将从主内存中读取数据。</p><h5 id="4-2-synchronized-锁退出可见性保证"><a href="#4-2-synchronized-锁退出可见性保证" class="headerlink" title="4.2 synchronized 锁退出可见性保证"></a>4.2 synchronized 锁退出可见性保证</h5><p>当一个进程退出 synchronized同步代码块（或同步方法），线程内所有可见变量数据都将写回到主内存中。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line"></span><br><span class="line">    private int numberA &#x3D; 1;</span><br><span class="line">    private int numberB &#x3D; 2;</span><br><span class="line">    private int numberC &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter方法</span><br><span class="line"></span><br><span class="line">    void copyNumber(Demo demo) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">        &#125;</span><br><span class="line">        this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">        this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：当某个线程进入 copyNumber() 方法的 synchronized 代码块时，线程内所有的可见变量都会从主内存中加载数据，也就是说 this 对象的 numberA, numberB也会从主内存中读取数据；退出synchronized 代码块时，线程内所有的可见变量都会写回到主内存中，this 对象的 numberA, numberB修改后的值也会被写回到主内存中。</p><h5 id="4-3-synchronized-happens-before-guarantee"><a href="#4-3-synchronized-happens-before-guarantee" class="headerlink" title="4.3 synchronized happens-before guarantee"></a>4.3 synchronized happens-before guarantee</h5><p>synchronized 提供了两种 happens-before guarantee ：一种与开始进入synchronized 代码块有关；另外一种与退出synchronized 代码块有关。</p><p><strong>synchronized beginning happens-before guarantee :</strong></p><p>我们已经知道，当线程进入 synchronized 代码块时，线程所有可见变量都将从主内存中读取数据。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程进入 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 都将从主内存中读取数据。</p><p>对于上面这个示例，<strong>所有的变量的读取指令都不会重排序到进入 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Number n) &#123;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized end happens-before guarantee :</strong></p><p>我们已经知道，当线程退出 synchronized 代码块时，线程所有可见变量的数据都将写回到主内存中。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程退出 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 的数据都将写回到主内存中。</p><p>对于上面这个示例，<strong>所有的变量的写的指令都不会重排序到退出 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void copyNumber(Number n) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 synchronized happens-before时，我总感觉把它总结的太复杂了，你可以简单的理解为 synchronized 不与其他指令发生指令重排，因为 synchronized happens-before 保证了线程在读取数据和写回数据时都会限制指令重排的发生。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 10. Java内存模型</title>
    <link href="http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-12T08:39:30.000Z</published>
    <updated>2020-08-26T02:08:25.081Z</updated>
    
    <content type="html"><![CDATA[<p>Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。</p><p>如果你想要设计出正确的并发程序，那么理解JMM是非常重要的。Java内存模型会提到一个线程怎样获取被别的线程修改后的共享变量的值；也会提到当有必要的时候，怎样让多个线程顺序的访问共享变量。</p><p>注意：原来的Java内存模型进行过修订，从Java 1.5 到 Java 14+，这个版本的内存模型仍然适用。</p><h3 id="1-Java-Memory-Model"><a href="#1-Java-Memory-Model" class="headerlink" title="1. Java Memory Model"></a>1. Java Memory Model</h3><p>在JVM中，JMM包含两种内存模型：Thread Stacks(线程栈)、Heap(堆内存)。如图所示</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt></div></p><p><strong>内存模型</strong></p><ol><li>每个在JVM中运行的线程都有自己的线程栈。这个线程栈包含线程中调用的方法信息和程序计数器（当前程序所执行的字节码的行号指示器）。</li><li>在开始执行某个方法的时候，会在线程栈中存储方法内所有的local variable(局部变量)，局部变量只对创建它的线程可见，其他线程无法访问。即使两个线程同时执行同一个方法，这两个线程都会创建局部变量保存至属于自己的线程栈中，线程只能访问自己线程栈中的数据。</li><li>所有基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量都保存在线程栈中，并且对其他线程不可见。一个线程可能拷贝一个基本数据类型变量给其他线程，但不会共享原始的局部变量（这里是值传递）。</li><li>堆内存中包含Java应用程序中所有对象的创建，不论哪个线程创建的对象都存储在堆内存中，并且包含基础数据类型的包装类也存储于堆内存中。对象的创建不管是作为局部变量、还是作为对象的成员，都始终保存于堆内存中。</li></ol><p>如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt></div></p><ol><li>一个本地变量可能是一个基本数据类型，这种情况下本地变量将完全保存在线程栈中。</li><li>一个本地变量可能引用一个对象，这种情况下对象的引用保存在线程栈中，对象保存在堆内存中。</li><li>一个对象可能包含一些方法，方法包含一些本地变量。本地变量保存在线程栈中，方法保存随对象保存在堆内存中。</li><li>一个对象的成员变量随对象保存在堆内存中，不论这个成员变量是基本数据类型还是引用其他对象，成员变量都保存在堆内存中。</li><li>静态变量随 class(类) 保存在堆内存中。</li></ol><p>堆内存的对象可以被任何具有该对象引用的线程访问。</p><hr><h3 id="2-计算机硬件内存结构"><a href="#2-计算机硬件内存结构" class="headerlink" title="2. 计算机硬件内存结构"></a>2. 计算机硬件内存结构</h3><p>现代硬件内存结构与Java内存模型有些不同，为了更好的理解Java内存模型，了解硬件内存结果是很重要的。</p><p>通常的硬件内存结构。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt></div></p><p>现代计算机通常拥有2个以上的CPU，有些CPU有多个内核。重点是多CPU计算机可以同时执行多个线程。当你的Java应用程序是多线程应用程序，在你的应用程序中可能同时出现每个CPU都在执行线程的情况。</p><ol><li>每个CPU有一组（注意是一组，多个）CPU寄存器，CPU操作寄存器的速度比操作主内存更快，这也意味着CPU访问寄存器的速度比访问内存更快。</li><li>每个CPU也可能有一个CPU缓存（CPU Cache Memory），事实上，每个CPU可能有一定数量的CPU缓存。CPU访问CPU缓存的速度比访问内存的速度快，通常情况下CPU访问CPU缓存的速度没有访问寄存器的速度快。因此你可以认为CPU访问内存的顺序依次是：寄存器 &gt; CPU缓存 &gt; 主内存。另外，一些CPU可能会有多级CPU缓存（L1,L2,L3等）。</li><li>每个计算机都包含一个主内存，主内存的容量比CPU缓存的容量更大。</li><li>通常情况下，CPU访问内存会读取主内存中的一些数据拷贝至CPU缓存，甚至拷贝至CPU内部的寄存器，然后可以在CPU缓存或者寄存器操作数据。当CPU需要写回数据至主内存中时，它首先会将寄存器中的结果值提交至CPU缓存中，然后再将CPU缓存的值提交至主内存中。</li><li>当CPU需要将CPU缓存的数据提交至主内存中时，CPU缓存的数据将会被写回主内存中。</li></ol><h5 id="2-1-桥接Java内存模型和计算机硬件内存结构"><a href="#2-1-桥接Java内存模型和计算机硬件内存结构" class="headerlink" title="2.1 桥接Java内存模型和计算机硬件内存结构"></a>2.1 桥接Java内存模型和计算机硬件内存结构</h5><p>如您所知，Java内存模型与现代计算机硬件内存结构不同，硬件内存结构没有区分线程栈内存和堆内存。也就是说：线程栈内存和堆内存可以都存在于硬件的主内存、CPU高速缓存、寄存器中。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt></div></p><p>当Java对象和变量可以保存在不同的计算机内存区域中，这就可能会导致一些问题的发生。主要的两个问题是：</p><ol><li>当线程更新共享数据时，共享数据在多个线程中的可见性。</li><li>当多个线程读、写、检查共享数据时，产生竞争条件。</li></ol><p>下面我们来解释这2个问题</p><h5 id="2-2-共享数据的可见性"><a href="#2-2-共享数据的可见性" class="headerlink" title="2.2. 共享数据的可见性"></a>2.2. 共享数据的可见性</h5><p>如果多个线程共享一个对象，并且代码中没有使用 volatile 关键字和 synchronized 同步代码块。当一个线程更新这个共享对象后，修改后的对象的值可能对其他线程不可见。</p><p>想象一下，当一个共享对象保存在主内存中时，一个CPU正在执行某个线程时把主内存中共享对象缓存至CPU高速缓存上，另外一个CPU也把共享对象缓存到CPU高速缓存中，其中一个CPU在CPU高速缓存中更新了共享数据并把共享数据写回到主内存中，此时另外一个CPU的CPU高速缓存还是旧的共享资源数据。</p><p>下图中解释了上面这种场景。下图左边的正在执行某个线程的CPU将 obj.count 加载到CPU高速缓存中，同时将 obj.count 的值改为 2。左边这个线程对 obj.count 的值进行修改后，对执行其他线程的CPU并不可见。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 volatile 关键字。这个关键字用于修饰某个成员变量，当线程要读取这个变量的值时，会从读取主内存中读取变量的值，并且每次修改变量的值时都会重新写回到主内存中。（后面会有文章详细介绍 volatile 关键字）</p><h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>如果多个线程共享一个对象，并且有多个线程修改共享变量，可能产生竞争条件。</p><p>想象一下，如果一个线程A从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，同时线程B也从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，线程A和线程B同时对 obj.count 做自增操作，也就是说 obj.count 同时被自增2次，在每个CPU里面自增一次。如果变量 obj.count 的同步执行递增2次，那么这个变量写回主内存时值应该是 obj.count + 2，然而这2次递增没有同步执行，实际上是在线程A和线程B并行执行，最终线程A和线程B把 obj.count 的值写回数据到主内存后，实际值变成了 obj.count + 1。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 synchronized 锁。synchronized 可以分别用于 代码块、普通方法、静态方法。后面有文章介绍 synchronized，这里不做过多描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。&lt;/p&gt;
&lt;p&gt;如果你想要设计出正确的并发程序，那么理解JMM是非常重
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 9. 线程安全和不变性</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</id>
    <published>2020-08-12T07:50:16.000Z</published>
    <updated>2020-08-26T02:08:24.984Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。</p><p>下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ImmutableValue&#123;</span><br><span class="line"></span><br><span class="line">  private int value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue(int value)&#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 ImmutableValue 提供了一个传入指定 value 的构造函数，一旦对象被创建，该对象没有提供任何修改value值的方法，所以value的值无法被修改。</p><h3 id="特别注意：对象引用不是线程安全的"><a href="#特别注意：对象引用不是线程安全的" class="headerlink" title="特别注意：对象引用不是线程安全的"></a>特别注意：对象引用不是线程安全的</h3><p>需要注意的是，当一个对象不可变时对象本身是线程安全的，但是对象的引用可能不是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  private ImmutableValue currentValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue getImmutableValue()&#123;</span><br><span class="line">    return currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setImmutableValue(ImmutableValue newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void add(int newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; new ImmutableValue(currentValue.getValue() + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator 类引用了一个 ImmutableValue 对象，请注意它可以通过 setImmutableValue() 方法和 add() 方法改变了 ImmutableValue 对象的引用。换句话说，即使 ImmutableValue 对象是不可变的，但它也是非线程安全的。ImmutableValue 类是线程安全的，但对象的引用是非线程安全的。<strong>所以特别注意：对象的引用可能是非线程安全的。</strong> 可以通过给 setImmutableValue() 方法和 add() 方法加锁（使用 synchronized 关键字等）保证线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。&lt;/p&gt;
&lt;p&gt;下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 8. 线程安全和共享资源</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</id>
    <published>2020-08-12T06:56:11.000Z</published>
    <updated>2020-08-26T02:08:25.092Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。</p><h3 id="1-Local-variables-本地变量-局部变量"><a href="#1-Local-variables-本地变量-局部变量" class="headerlink" title="1. Local variables (本地变量/局部变量)"></a>1. Local variables (本地变量/局部变量)</h3><p>局部变量保存在每个线程独有的线程栈中，因此局部变量在线程之间是不共享的。也就是说所有的局部变量都是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void someMethod()&#123;</span><br><span class="line">    long threadSafeInt &#x3D; 0;</span><br><span class="line">    threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-Local-Object-References-本地对象引用-局部对象引用"><a href="#2-Local-Object-References-本地对象引用-局部对象引用" class="headerlink" title="2. Local Object References (本地对象引用/局部对象引用)"></a>2. Local Object References (本地对象引用/局部对象引用)</h3><p>本地对象引用有所不同，引用本身是不共享的，同样也是保存在线程独有的线程栈中，线程之间不共享引用。但是引用的对象不是保存在线程栈中，而是保存在主内存堆中，理论上讲所有的线程都能够访问内存堆中存储的对象（但是要有对象的引用）。</p><p>如果一个对象创建之后没有离开创建它的方法，那么是线程安全的。事实上传递这个对象的引用给其他的方法，只要这个对象的引用没有传递给其他的线程，那么这个对象都不会成为共享对象，始终是线程安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void methodOne()&#123;</span><br><span class="line">  LocalObject localObject &#x3D; new LocalObject();</span><br><span class="line">  methodTwo(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo(LocalObject localObject)&#123;</span><br><span class="line">  localObject.setValue(&quot;value&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中：对象 localObject 在 methodOne() 方法中被创建，然后传递给 methodTwo()，localObject 没有传递给其他线程; 每个线程执行 methodOne() 时会都创建一个新的 LocalObject 对象，且 LocalObject 对象的引用都保存在各自的线程栈中，因此是 methodOne() 线程安全的，尽管 LocalObject 存在多个实例对象，但使用它们是线程安全的。</p><p><strong>但有一种场景例外：</strong> 当某个方法将 localObject 对象的引用作为参数传递给了其他线程，那么可能会造成线程不安全。</p><h3 id="3-Object-Member-Variables-对象成员变量"><a href="#3-Object-Member-Variables-对象成员变量" class="headerlink" title="3. Object Member Variables (对象成员变量)"></a>3. Object Member Variables (对象成员变量)</h3><p>对象成员变量随对象保存在堆内存中。因此当两个线程调用了某个方法，这个方法引用了同一个对象并修改了这个对象的成员变量时，那么这个方法时线程不安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public add(String text)&#123;</span><br><span class="line">        this.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程同时调用同一个 NotThreadSafe 对象的 add() 方法时，会导致竞争条件发生。 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotThreadSafe sharedInstance &#x3D; new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"></span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance &#x3D; instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    this.instance.add(&quot;some text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意有 2 个 MyRunnable 对象共享了 sharedInstance 对象，因此当他们同时调用 sharedInstance.add() 方法时，会发生竞争条件。</p><p>然而，当 2 个线程同时调用不对对象的 add() 方法时，不会产生竞争条件。示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br></pre></td></tr></table></figure><h3 id="4-线程安全规则"><a href="#4-线程安全规则" class="headerlink" title="4. 线程安全规则"></a>4. 线程安全规则</h3><p>当你想确认你的代码访问某些资源的时候是否是线程安全的，你可以使用下面这个规则：</p><blockquote><p><strong>如果资源的创建、使用和销毁都没有离开某个方法，并且没有分享给其他线程，那么使用这个资源是线程安全的。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。&lt;/p&gt;
&lt;h3 id=&quot;1-Local-variables-本地变量-局部变
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 7. 竞争条件和临界区</title>
    <link href="http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</id>
    <published>2020-08-12T06:41:07.000Z</published>
    <updated>2020-08-26T02:08:25.013Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 6. 创建和开始Java线程</title>
    <link href="http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-12T02:32:54.000Z</published>
    <updated>2020-08-26T02:08:25.034Z</updated>
    
    <content type="html"><![CDATA[<p>一个Java线程就像一个可以执行你的Java代码的虚拟CPU。</p><p>当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。</p><p>Java 线程都是对象，就像其他的Java对象一样，线程对象都是 java.lang.Tread 的实例或者其子类的实例。</p><h3 id="1-创建和开始线程"><a href="#1-创建和开始线程" class="headerlink" title="1 创建和开始线程"></a>1 创建和开始线程</h3><p>你可以像这样创建一个线程对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread myThread &#x3D; new Thread();</span><br></pre></td></tr></table></figure><p>你可以像这样开始一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><p>创建线程的几种方式：</p><blockquote><ul><li>继承 java.lang.Thread 类并重写 run() 方法。</li><li>实现 java.lang.Runnable 接口并重写 run() 方法。</li><li>实现 java.util.concurrent.Callable 接口并重写 call() 方法。（备注：这种实现方式后面有 JUC 专题）</li></ul></blockquote><hr><h3 id="2-Thread-子类"><a href="#2-Thread-子类" class="headerlink" title="2 Thread 子类"></a>2 Thread 子类</h3><p>继承 java.lang.Thread 类并重写 run() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyThread myThread &#x3D; new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start() 方法不会等线程执行完 run()方法，run() 方法将会由其他不同的CPU执行。</p><hr><h3 id="3-实现-Runnable-接口"><a href="#3-实现-Runnable-接口" class="headerlink" title="3 实现 Runnable 接口"></a>3 实现 Runnable 接口</h3><p>第二种创建线程的方式是实现 java.lang.Runnable 接口并重写该接口的 run() 方法。一个 Java 对象实现 Runnable 接口 可以被Java Thread 类执行。</p><p>Runnable 接口由 JDK 提供，仅有一个 run 方法，是一个函数式接口。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 的方式有3种：</p><blockquote><ol><li>创建一个 Java 类实现 Runnable 接口</li><li>创建一个 Java 匿名类实现 Runnable 接口</li><li>使用 Java 8 Lambda 表达式实现 Runnable 接口</li></ol></blockquote><h5 id="3-1-创建一个-Java-类实现-Runnable-接口"><a href="#3-1-创建一个-Java-类实现-Runnable-接口" class="headerlink" title="3.1 创建一个 Java 类实现 Runnable 接口"></a>3.1 创建一个 Java 类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-创建一个-Java-匿名类实现-Runnable-接口"><a href="#3-2-创建一个-Java-匿名类实现-Runnable-接口" class="headerlink" title="3.2 创建一个 Java 匿名类实现 Runnable 接口"></a>3.2 创建一个 Java 匿名类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable &#x3D; new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口"><a href="#3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口" class="headerlink" title="3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口"></a>3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable &#x3D; () -&gt; &#123; System.out.println(&quot;Lambda Runnable running&quot;); &#125;;</span><br></pre></td></tr></table></figure><h5 id="3-4-开启一个实现了-Runnable-接口的线程"><a href="#3-4-开启一个实现了-Runnable-接口的线程" class="headerlink" title="3.4 开启一个实现了 Runnable 接口的线程"></a>3.4 开启一个实现了 Runnable 接口的线程</h5><p>java.lang.Thread的包含传入一个Runnable接口的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;or an anonymous class, or lambda...</span><br><span class="line">    Runnable runnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;executed by a thread</span><br><span class="line">    Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-使用哪种方式创建线程更好"><a href="#4-使用哪种方式创建线程更好" class="headerlink" title="4. 使用哪种方式创建线程更好 ?"></a>4. 使用哪种方式创建线程更好 ?</h3><p>关于继承Thread和实现Runnable接口，没有明确的规定用哪种方式创建线程更好，两种方式都可以让线程运行。我更倾向于使用实现Runnable接口的方式，后面我还们会了解到另外一种创建线程的方式，通过线程池创建线程的方式更加合理。</p><h3 id="5-常见陷阱：调用-run-代替-start"><a href="#5-常见陷阱：调用-run-代替-start" class="headerlink" title="5. 常见陷阱：调用 run() 代替 start()"></a>5. 常见陷阱：调用 run() 代替 start()</h3><p>通过调用start()，程序会告诉 CPU 线程已准备就绪，等待CPU执行 run() 方法。若直接调用 run() 方法则不会开启一个新的线程去执行 run() 方法，而是在原来的线程中去执行 run() 方法，所以当我们需要一个新的线程去执行 run() 方法中的代码时，应该调用 start() 方法启动一个线程，而不是直接调用 run() 方法。</p><h3 id="6-线程名（Thread-Names）"><a href="#6-线程名（Thread-Names）" class="headerlink" title="6. 线程名（Thread Names）"></a>6. 线程名（Thread Names）</h3><p>创建线程的时候可以指定线程名称，详见 java.lang.Thread API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable myRunnable &#x3D; () -&gt; System.out.println(&quot;Thread name is &quot; + Thread.currantThread().getName());</span><br><span class="line">    </span><br><span class="line">    new Thread(myRunnable, &quot;Thread One&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console out: Thread name is Thread One</span><br></pre></td></tr></table></figure><h3 id="7-Thread-currentThread"><a href="#7-Thread-currentThread" class="headerlink" title="7. Thread.currentThread()"></a>7. Thread.currentThread()</h3><p>通过 Thread.currentThread() 获取当前正在执行的线程对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread currentThread &#x3D; Thread.currentThread();</span><br></pre></td></tr></table></figure><h3 id="8-暂停线程"><a href="#8-暂停线程" class="headerlink" title="8. 暂停线程"></a>8. 暂停线程</h3><p>可以通过 Thread.sheep() 让线程睡眠指定毫秒数。这里不建议使用 thread.suspend() 方法，该方法和 Thread 类的 resume()、stop()、destroy() 都是 JDK 标注废弃方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： Thread.sheep() 方法不会释放CPU资源，如果设置锁的话也不会释放锁资源，只是让线程睡眠指定毫秒数。与 Object 类的 wait() 方法不同， wait() 方法主要用于线程通信，且 wait() 方法会释放锁资源。</p><h3 id="9-停止一个线程"><a href="#9-停止一个线程" class="headerlink" title="9. 停止一个线程"></a>9. 停止一个线程</h3><p>不建议使用 Thread 类提供的 stop() 方法去停止一个线程，stop() 方法会暴力停止一个线程，对程序不友好，可以通过更友好的方式停止一个线程。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private boolean doStop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.doStop &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized boolean keepRunning() &#123;</span><br><span class="line">        return this.doStop &#x3D;&#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(keepRunning()) &#123;</span><br><span class="line">            &#x2F;&#x2F; keep doing what this thread should do.</span><br><span class="line">            System.out.println(&quot;Running&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3L * 1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 doStop() 方法和 keepRunning() 方法使用了 synchronized 关键字，后面会详细讲解 synchronized 关键字的作用，这里不做过多描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnableMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10L * 1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例通过设置一个标识，主线程里面启动子线程，然后主线程睡眠10秒钟后调用 doStop() 方法，实现在主线程中停止子线程的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个Java线程就像一个可以执行你的Java代码的虚拟CPU。&lt;/p&gt;
&lt;p&gt;当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。&lt;/p&gt;
&lt;p&gt;Java 线程都是对象，就像其他的Java对
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 5. 并发和并行</title>
    <link href="http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</id>
    <published>2020-08-11T02:23:36.000Z</published>
    <updated>2020-08-26T02:08:24.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Concurrency-并发"><a href="#1-Concurrency-并发" class="headerlink" title="1. Concurrency 并发"></a>1. Concurrency 并发</h3><p>应用程序中（Application）同时进行一个以上的任务（Task）。对于单CPU的电脑而言，不可能同时进行一个以上的任务，CPU通过交换的执行任务直到任务都被执行完成。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" alt></div></p><hr><h3 id="2-Parallelism-并行"><a href="#2-Parallelism-并行" class="headerlink" title="2. Parallelism 并行"></a>2. Parallelism 并行</h3><p>应用程序中的任务（Task）被切割成多个子任务（SubTask）同时执行。实现并行你的应用程序必须有多个线程在同时执行，并且至少有一个任务在执行（Task）。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" alt></div></p><hr><h3 id="3-Concurrency-vs-Parallelism"><a href="#3-Concurrency-vs-Parallelism" class="headerlink" title="3. Concurrency vs. Parallelism"></a>3. Concurrency vs. Parallelism</h3><ul><li>并发是一个应用程序同时执行多个任务。</li><li>并行是一个应用程序处理单个任务，将单个任务切割成多个子任务并行执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Concurrency-并发&quot;&gt;&lt;a href=&quot;#1-Concurrency-并发&quot; class=&quot;headerlink&quot; title=&quot;1. Concurrency 并发&quot;&gt;&lt;/a&gt;1. Concurrency 并发&lt;/h3&gt;&lt;p&gt;应用程序中（Applic
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 4. 相同线程</title>
    <link href="http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-11T01:02:36.000Z</published>
    <updated>2020-08-26T02:08:25.063Z</updated>
    
    <content type="html"><![CDATA[<p>相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。</p><p>一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。</p><h3 id="1-为什么用单线程系统？"><a href="#1-为什么用单线程系统？" class="headerlink" title="1. 为什么用单线程系统？"></a>1. 为什么用单线程系统？</h3><p>你可能会想为什么每个人都能设计出单线程系统。单线程系统受欢迎的原因是因为单线程系统的并发模型比多线程系统的并发模型更加简单。单线程系统线程之间不共享任何状态（对象/数据），单线程系统可以不使用任何并发数据结构，并且更好地利用CPU和CPU缓存。</p><p>遗憾的是，单线程系统不能很好的利用现代CPU，现代CPU通常情况下拥有多个CPU内核，每个CPU内核的功能就像一个独立的单核CPU，一个单线程系统只能利用CPU中的一个内核，模型如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" alt></div></p><hr><h3 id="2-相同线程（单线程系统的扩展）"><a href="#2-相同线程（单线程系统的扩展）" class="headerlink" title="2. 相同线程（单线程系统的扩展）"></a>2. 相同线程（单线程系统的扩展）</h3><p>为了充分的利用CPU的内核，一个单线程系统可以扩展到利用整个计算机。</p><h5 id="一个CPU内核执行一个线程"><a href="#一个CPU内核执行一个线程" class="headerlink" title="一个CPU内核执行一个线程"></a>一个CPU内核执行一个线程</h5><p>相同线程系统通常让计算机中每个CPU内核执行一个线程，如果一个计算机有4个CPU，每个CPU拥有4个CPU内核，让每个CPU内核执行一个线程的示例如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" alt></div></p><hr><h3 id="3-不共享状态（数据）"><a href="#3-不共享状态（数据）" class="headerlink" title="3. 不共享状态（数据）"></a>3. 不共享状态（数据）</h3><p>一个相同线程系统与传统的多线程系统相似，因为一个相同线程系统有多个线程同时执行，但是两者有一些区别。</p><p>相同线程系统与多线程系统不同的是相同线程系统不共享状态（或不共享数据），当产生并发访问时不共享数据，没有并发数据结构等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" alt></div></p><p>不共享数据让相同线程系统看上去像单线程系统。因为相同线程系统可以包含多个单线程，因此取名相同线程系统更加合理。</p><p>相同线程系统基本含义是进程同时包含处理多个相同的线程，在相同线程系统中并发时没有线程共享数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。&lt;/p&gt;
&lt;p&gt;一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 3. 并发模型</title>
    <link href="http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-09T09:10:45.000Z</published>
    <updated>2020-08-26T02:08:25.072Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。</p><h3 id="1-并发模型与分布式系统相似"><a href="#1-并发模型与分布式系统相似" class="headerlink" title="1. 并发模型与分布式系统相似"></a>1. 并发模型与分布式系统相似</h3><blockquote><ul><li>在一个并发系统中，不同的线程之间相互通信。</li><li>在一个分布式系统中，不同的进程之间相互通信。</li><li>进程和线程在本质上非常的相似。</li></ul></blockquote><p>分布式系统比并发系统面临更多的挑战，比如可能面临网络异常、远程主机或进程停止；并发系统理论上也存在相似的问题，比如CPU异常，内存或硬盘损坏等情况，这种异常的概率相对较小，但实际上是存在的。</p><hr><h3 id="2-共享状态-vs-隔离状态"><a href="#2-共享状态-vs-隔离状态" class="headerlink" title="2. 共享状态 vs 隔离状态"></a>2. 共享状态 vs 隔离状态</h3><h5 id="2-1-共享状态"><a href="#2-1-共享状态" class="headerlink" title="2.1 共享状态"></a>2.1 共享状态</h5><p>共享状态意味着同一系统的多个线程之间共享一些状态（一般指数据，共享一个或多个对象的数据）。当线程共享状态时，容易引发一些并发问题，比如死锁，竞争条件等等，这取决于线程怎样地使用和访问共享数据等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" alt></div></p><h5 id="2-2-隔离状态"><a href="#2-2-隔离状态" class="headerlink" title="2.2 隔离状态"></a>2.2 隔离状态</h5><p>隔离状态意味着同一系统的多个线程之间不共享状态。如果不同的线程之间需要进行通信，可以通过交换不可变对象、或者使用复制的对象进行通信。当多个线程之间不存在共享状态（或共享数据），就可以避免最常见的并发问题。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" alt></div></p><p><strong>备注</strong><br>隔离状态通常情况下可以让代码实现更加简单，并且可以不用担心发生并发访问的问题，避免一些常见的并发问题。在一些特殊情况下，使用分离状态并发设计可能存在更大的挑战。</p><hr><h3 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3. 并发模型"></a>3. 并发模型</h3><h5 id="3-1-Parallel-Workers-并行工作者并发模式"><a href="#3-1-Parallel-Workers-并行工作者并发模式" class="headerlink" title="3.1 Parallel Workers (并行工作者并发模式)"></a>3.1 Parallel Workers (并行工作者并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt></div></p><p><strong>并行工作者模式：</strong><br>传入的工作被分配到不同的工作者去执行，每个工作者执行完整的工作流程。工作者在不同的线程中执行。并行工作者并发模型在 Java 应用程序中很常见，JUC包中很多并发工具类的设计都采用了这种并发模型。 </p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><blockquote><ul><li>非常容易理解：如果要提高并行效率只需要增加更多的工作者</li></ul></blockquote><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><blockquote><ul><li>存在共享状态时实现更加复杂</li><li>工作顺序不固定</li></ul></blockquote><p><strong>缺点1：存在共享状态时实现更加复杂</strong><br>并行工作者模式不同线程存在共享数据时，实现变得更加复杂。共享线程通常需要访问共享对象，不论共享对象存在于内存中还是数据库中。如下图所示<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt></div></p><p>某些共享状态是工作队列中的通信机制，也有些共享状态是业务数据、数据缓存、数据库连接池等等。</p><p>并行工作者并发模式的线程之间存在共享数据时会更加复杂，当一个线程修改了共享数据变量时，需要确保其他线程读取的共享数据变量是最新的（线程修改了共享数据变量应该把数据保存至主内存中，而不是保存至线程独有的CPU高速缓存栈中）。线程需要避免死锁、竞争条件、或者其他共享状态的并发问题。</p><p>当某个线程正在访问共享数据结构时，其他线程会等待正在访问共享数据结构的线程执行完毕，造成阻塞。这可能导致这些线程在竞争共享数据资源，高的竞争条件会导致许多线程访问共享数据时串行执行。</p><p>现代非阻塞并发算法可能降低竞争并且提高性能，但是非阻塞并发算法很难实现。</p><p>持久性数据结构是另一种选择，当持久性数据结构被修改时，他总是保持修改前版本。当多个线程引用了某个持久性数据结构，其中某个线程对持久性数据结构做了修改时，这个修改了持久性数据结构的线程获得了最新的引用数据，而其他的线程保持原来的引用的数据。在共享数据被修改时，持久性数据结构的方式是一个很好的解决方案。</p><blockquote><p>关于持久性数据结构的举例：</p><ul><li>当某个线程给ArrayList添加一个元素时，新添加的元素对其他线程并不可见</li><li>也存在某些缺陷，比如LinkedList， 由于LinkedList是链表的数据结构，链表的每个元素都是一个单独的对象，这种数据结构分布在内存块中的各个地方。然而现代CPU在访问顺序的数据结构时要快的多，比如ArrayList，所以CPU在访问ArrayList时能够表现出更加卓越的性能。CPU能够一次加载一个较大的数组类型的数据结构至高速缓存中，但是无法将一个元素分布至内存各个地方的链表（ListedList）加载到CPU的高速缓存中。</li></ul></blockquote><p><strong>无状态工作者</strong><br>共享数据可以被系统中某个线程修改，其他线程在每次访问共享数据时必须重新读取最新的内存中的数据，以保证线程在执行中时拿到的是最新的内存副本，一个线程不始终保持自己线程独有的CPU高速缓存数据的状态称为无状态。</p><p><strong>缺点2：工作顺序不固定</strong><br>工作A可能被分配给线程A执行，也可能被分配给线程B执行，因此并行工作者模式的执行顺序不是固定的。</p><h5 id="3-2-Assembly-Line-流水线并发模式"><a href="#3-2-Assembly-Line-流水线并发模式" class="headerlink" title="3.2 Assembly Line (流水线并发模式)"></a>3.2 Assembly Line (流水线并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt></div></p><p>这种模式就像工厂中流水线的工人一样，每个工作者只负责整个生产车间的一部分工作，每个工作者负责的这部分工作完成之后会传递给下一个工作者。</p><p>每个工作者在自己的线程内执行，不存在共享状态，流水线并发模式也被称为无共享并发模式。</p><p>流水线并发模式经常在非阻塞IO (NIO) 被设计使用。当一个工作者开始IO操作，其他工作者不需要等待IO操作结束。IO操作很慢，所以等待IO操作完成会浪费大量CPU时间，当IO操作完成时，IO操作的结果会被传递给其他工作者。</p><p>关于NIO， 在IO操作确定工人之间的界限。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt></div></p><p>实际上，工作模式可能不只一条流水线，大多数系统可以设计多条流水线。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt></div></p><p>工作可能并定向到一个工作者进行并行处理。比如一个工作可能同时被分配到工作执行器和日志执行器中执行。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt></div></p><p>流水线并发模式也被称为反应系统或者事件响应系统。</p><p><strong>优点：</strong></p><blockquote><ul><li>不共享状态</li><li>可以顺序执行工作</li></ul></blockquote><p><strong>缺点</strong></p><blockquote><ul><li>作业的执行分散在各个工人</li><li>调试更加复杂</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。&lt;/p&gt;
&lt;h3 id=&quot;1-并发模型与分布式系统相似&quot;&gt;&lt;a href=&quot;#1-并发模型与分布式系统相似&quot; 
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 2. 使用多线程的成本</title>
    <link href="http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/</id>
    <published>2020-08-09T08:31:10.000Z</published>
    <updated>2020-08-26T02:08:25.054Z</updated>
    
    <content type="html"><![CDATA[<p>从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不是靠猜想。</p><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><blockquote><ul><li>更复杂的程序设计</li><li>上下文切换的开销</li></ul></blockquote><p><strong>更复杂的程序设计</strong> </p><blockquote><ul><li>在某些情况下，一个多线程应用程序比单线程应用程序更加简单，但是在某些特殊情况下要更加复杂。</li><li>在多个线程引用了同一个共享变量的情况下，多线程应用程序比单线程应用程序使用起来更加复杂，因为需要考虑线程安全问题，不正确的线程同步问题出现的问题往往防不胜防。</li></ul></blockquote><p><strong>上下文切换的开销</strong> </p><blockquote><ul><li>当一个CPU从当前线程切换的执行另外一个线程时，CPU需要保存当前线程的本地数据以及程序指针等等，再有另外一个线程切换到当前线程时，需要重新读取本地数据和程序指针等，这个交换的执行过程叫做上下文切换。</li><li>上下文切换的成本并不便宜。</li></ul></blockquote><p><strong>减少上下文切换</strong></p><blockquote><ul><li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁。</li><li>CAS算法：Java的atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程：避免创建不需要的线程。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 1. 并发和多线程</title>
    <link href="http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/"/>
    <id>http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/</id>
    <published>2020-08-09T06:19:56.000Z</published>
    <updated>2020-08-26T02:08:25.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-并发和多线程"><a href="#1-并发和多线程" class="headerlink" title="1. 并发和多线程"></a>1. 并发和多线程</h3><p><strong>并发编程</strong><br>并发编程涵盖了多线程技术在内，指并发执行任务时可能出现的问题，使用的多线程技术，以及解决方案。</p><p><strong>多线程：</strong><br>同一个应用程序中，多个线程同时执行。</p><p><strong>多线程应用程序:</strong><br>多线程应用程序是一个多 CPU 同时执行不同的线程的应用程序。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" alt></div></p><p>一个线程不等于一个CPU，通常情况下一个CPU在不同时间段交换执行不同的线程，不同的CPU同时执行不同的线程。如图：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" alt></div></p><hr><h3 id="2-为什么使用多线程"><a href="#2-为什么使用多线程" class="headerlink" title="2. 为什么使用多线程"></a>2. 为什么使用多线程</h3><blockquote><ul><li>更好的利用单 CPU 资源</li><li>更好的利用多 CPU 或 CPU 内核</li><li>更快速的响应-提高用户体验</li><li>更公平的响应-提高用户体验</li></ul></blockquote><p><strong>更好的利用单 CPU 资源</strong><br>单个CPU通过分配CPU时间片达到交换地执行不同线程的目的，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒。</p><p><strong>更好的利用多 CPU 或 CPU 内核</strong><br>创建多个线程，充分地利用多个CPU同时执行不同的线程，加快程序执行速度，充分利用多CPU资源。</p><p><strong>更快速的响应-提高用户体验</strong><br>充分的利用单CPU资源和多CPU资源都能够加快程序的执行速度，以提高用户体验</p><p><strong>更公平的响应-提高用户体验</strong><br>不同的线程在单CPU中分配CPU时间片交换执行，在某些特定情况下以一种更加公平的方式执行不同的线程。比如某个线程需要调用网络资源或者其他的操作需要长时间占用CPU，导致许多线程需要等待CPU去执行，造成阻塞。</p><hr><h3 id="3-使用多线程不一定更快"><a href="#3-使用多线程不一定更快" class="headerlink" title="3. 使用多线程不一定更快"></a>3. 使用多线程不一定更快</h3><p>由于线程的创建和上下文的切换的开销，多线程的执行效率不一定比单线程的执行效率更好。</p><p><strong>线程创建的方式</strong></p><blockquote><ul><li>继承Thread类，重写 run() 方法</li><li>实现Runnable接口，重写 run() 方法</li><li>实现Callable接口，重写 call() 方法</li></ul></blockquote><p><strong>上下文切换</strong><br>单核处理器也支持多线程执行代码，CPU 通过给每个线程分配CPU时间片来实现这个机制。当前任务执行一个时间片后会切换到下一个任务。但是切换前会保存上一个任务的状态，以便于下次切换到该任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><hr><h3 id="4-多线程-vs-多任务"><a href="#4-多线程-vs-多任务" class="headerlink" title="4. 多线程 vs. 多任务"></a>4. 多线程 vs. 多任务</h3><p><strong>多任务</strong><br>不同CPU同时执行不同的应用程序的不同线程。</p><p><strong>多线程</strong><br>不同CPU同时执行相同的应用程序的不同线程。</p><p><strong>多线程技术更难实现</strong><br>多线程技术可以以一种很好的方式提高某些类型的应用程序的性能。但是多线程技术比多任务技术要面临更多的技术挑战。不同的线程在同一个应用程序中同时执行，它们可能存在一个线程在读取共享内存的数据，另外一个线程在写入数据至共享内存，造成线程不安全的问题发生，以至于产生了单线程技术通常情况下不会发生的错误。</p><p>现代计算机通常拥有多个CPU或者多个CPU内核，这意味着不同的线程可以被不同的CPU同时执行。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" alt></div></p><hr><h3 id="5-Java-中的并发和多线程"><a href="#5-Java-中的并发和多线程" class="headerlink" title="5. Java 中的并发和多线程"></a>5. Java 中的并发和多线程</h3><p><strong>并发模型</strong></p><blockquote><ul><li>共享状态并发模型（shared state concurrency model）</li><li>隔离状态并发模型（separate state concurrency model）</li></ul></blockquote><p><strong>共享状态并发模型</strong><br>同一个应用程序中的不同的线程使用了同一个共享对象（或变量）。在共享状态并发模型中存在很多问题，这些问题难以完美地解决。</p><p><strong>隔离状态并发模型</strong><br>同一个应用程序中的不同的线程不共享任何对象（或变量）。</p><hr><h3 id="Java-并发学习指南"><a href="#Java-并发学习指南" class="headerlink" title="Java 并发学习指南"></a>Java 并发学习指南</h3><p><strong>并发和多线程理论知识</strong></p><blockquote><ul><li>多线程的好处</li><li>多线程的成本</li><li>并发模型</li><li>同一线程</li><li>并发 vs. 并行</li></ul></blockquote><p><strong>Java并发的基础理论知识</strong></p><blockquote><ul><li>创建和开始一个线程</li><li>线程安全和共享资源</li><li>线程安全和不变性</li><li>JMM (Java memory model)</li><li>synchronize 关键字</li><li>volatile 关键字</li><li>ThreadLocal </li></ul></blockquote><p><strong>Java 并发常见问题</strong></p><blockquote><ul><li>死锁</li><li>预防死锁</li></ul></blockquote><p><strong>Java 提供的一些解决常见问题的工具</strong></p><blockquote><ul><li>Lock （锁）</li><li>Read / Write Lock （读写锁）</li><li>ReentrantLock （可重入锁）</li><li>Semaphores （信号）</li><li>Blocking Queues （阻塞队列）</li><li>Thread Pools （线程池）</li><li>Compare and Swap （CAS）</li></ul></blockquote><p><strong>Java 并发工具包 （JUC: java.util.concurrent）</strong></p><blockquote><ul><li>Java Concurrency Utilities - java.util.concurrent</li></ul></blockquote><hr><p><strong>推荐</strong></p><blockquote><p>&lt;Java 并发编程的艺术&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-并发和多线程&quot;&gt;&lt;a href=&quot;#1-并发和多线程&quot; class=&quot;headerlink&quot; title=&quot;1. 并发和多线程&quot;&gt;&lt;/a&gt;1. 并发和多线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;并发编程&lt;/strong&gt;&lt;br&gt;并发编程涵盖了多线程技术在内，指并发执
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并行流</title>
    <link href="http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    <id>http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/</id>
    <published>2020-07-09T11:21:09.000Z</published>
    <updated>2020-07-09T11:21:09.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数式数据处理</title>
    <link href="http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-07-01T11:22:34.000Z</published>
    <updated>2020-07-08T06:04:24.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h2><p>概念：</p><blockquote><ul><li>Stream：支持数据处理操作的源（集合、数组、输入/输出资源）生成的元素序列 。</li><li>备注： 流是Java 8 API的新成员，它允许你以声明性方式处理数据集合。</li><li><a href="https://miracle-sungm.github.io/2020/06/13/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">Lambda表达式博客链接</a>   </li></ul></blockquote><p>定义：</p><blockquote><ol><li>源： 流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li>元素序列： 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。</li><li>数据处理操作: 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ol></blockquote><p>特点：</p><blockquote><ol><li>流水线： 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li><li>内部迭代： 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ol></blockquote><p>流的特性：</p><blockquote><ol><li>只能遍历一次。和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</li></ol></blockquote><p>Stream API 带来的好处：</p><blockquote><ul><li>声明性 ： 更简洁易读</li><li>可复合 ： 更灵活</li><li>可并行 ： 性能更好</li></ul></blockquote><p>流与集合</p><blockquote><p>粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，集合中的每个元素都得先计算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</p></blockquote><p>流与集合的差异：</p><blockquote><ol><li>遍历数据的方式不同。使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</li><li>//TODO 待补充</li></ol></blockquote><h2 id="2-使用-Stream"><a href="#2-使用-Stream" class="headerlink" title="2. 使用 Stream"></a>2. 使用 Stream</h2><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th align="left">操作</th><th align="left">类型</th><th align="left">返回类型</th><th align="left">函数式接口</th><th align="left">函数描述符</th></tr></thead><tbody><tr><td align="left">filter</td><td align="left">中间</td><td align="left">Stream<T></T></td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">distinct</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">skip</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">limit</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">map</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, R&gt;</td><td align="left">T -&gt; R</td></tr><tr><td align="left">flatMap</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, Stream<R>&gt;</R></td><td align="left">T -&gt; Stream<R></R></td></tr><tr><td align="left">sorted</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left">Comparator<T></T></td><td align="left">(T, T) -&gt; int</td></tr><tr><td align="left">anyMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">noneMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">allMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">findAny</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">findFirst</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">forEach</td><td align="left">终端</td><td align="left">void</td><td align="left">Consumer<T></T></td><td align="left">T -&gt; void</td></tr><tr><td align="left">collect</td><td align="left">终端</td><td align="left">R</td><td align="left">Collector&lt;T, A, R&gt;</td><td align="left"></td></tr><tr><td align="left">reduce</td><td align="left">终端(有状态 &amp; 有界)</td><td align="left">Optional<T></T></td><td align="left">BinaryOperator<T></T></td><td align="left">(T, T) -&gt; T</td></tr><tr><td align="left">count</td><td align="left">终端</td><td align="left">long</td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>过滤流元素：该操作会接受一个 Predicate 函数式接口对象（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;过滤出元素小于5的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().filter(number -&gt; number &lt; 5).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h4 id="2-2-distinct"><a href="#2-2-distinct" class="headerlink" title="2.2 distinct"></a>2.2 distinct</h4><p>对流元素去重：根据流元素的hashCode和equals方法判断元素是否重复。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 1, 1, 2, 2, 2, 3, 3);</span><br><span class="line">    &#x2F;&#x2F;去重数据</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="2-3-limit"><a href="#2-3-limit" class="headerlink" title="2.3 limit"></a>2.3 limit</h4><p>截断流：该操作会接受一个 int 类型的入参，返回一个不超过给定长度的流。（如果流是有序的，则最多返回前 n 个元素）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;截断前2个元素</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().limit(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><h4 id="2-4-skip"><a href="#2-4-skip" class="headerlink" title="2.4 skip"></a>2.4 skip</h4><p>跳过元素：该操作会接受一个 int 类型的入参，返回扔掉前 n 个元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;跳过前2个元素，返回剩余元素的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().skip(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>映射元素： 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;将int元素映射成String元素</span><br><span class="line">    List&lt;String&gt; result &#x3D; numbers.stream().map(Object::toString).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-6-flatMap"><a href="#2-6-flatMap" class="headerlink" title="2.6 flatMap"></a>2.6 flatMap</h4><p>扁平化流： 当流的元素可以转换成另外一个流时，扁平化流会得到一个流元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; a &#x3D; Arrays.asList(&quot;a&quot;, &quot;a1&quot;);</span><br><span class="line">    List&lt;String&gt; b &#x3D; Arrays.asList(&quot;b&quot;, &quot;b1&quot;);</span><br><span class="line">    List&lt;String&gt; c &#x3D; Arrays.asList(&quot;c&quot;, &quot;c1&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listList &#x3D; Arrays.asList(a, b, c);</span><br><span class="line">    &#x2F;&#x2F;扁平化流：将 Stream&lt;List&lt;String&gt;&gt; 流转换成一个新的 Stream&lt;String&gt; 流。</span><br><span class="line">    List&lt;String&gt; list &#x3D; listList.stream().flatMap(List::stream).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">[a, a1, b, b1, c, c1]</span><br></pre></td></tr></table></figure><h4 id="2-7-anyMatch"><a href="#2-7-anyMatch" class="headerlink" title="2.7 anyMatch"></a>2.7 anyMatch</h4><p>判断流中是否存在元素与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否存在与谓词匹配。（注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回true）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    if (numbers.stream().anyMatch(number -&gt; number &#x3D;&#x3D; 2)) &#123;</span><br><span class="line">        System.out.println(&quot;成功匹配到数字2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">成功匹配到数字2</span><br></pre></td></tr></table></figure><h4 id="2-8-allMatch"><a href="#2-8-allMatch" class="headerlink" title="2.8 allMatch"></a>2.8 allMatch</h4><p>判断流中所有元素是否都与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都与谓词匹配。 （注意：该方法执行时，若找到一个不匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39;,&#39;结尾</span><br><span class="line">    if (list.stream().allMatch(s -&gt; s.endsWith(&quot;,&quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素均以&#39;,&#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素均以&#39;,&#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-9-nonMatch"><a href="#2-9-nonMatch" class="headerlink" title="2.9 nonMatch"></a>2.9 nonMatch</h4><p>与allMatch相反，nonMatch是判断流中所有元素是否都不与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都不与谓词匹配。 （注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39; &#39;结尾</span><br><span class="line">    if (list.stream().noneMatch(s -&gt; s.endsWith(&quot; &quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素都不以&#39; &#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素都不以&#39; &#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-10-findFirst"><a href="#2-10-findFirst" class="headerlink" title="2.10 findFirst"></a>2.10 findFirst</h4><p>找到流中第一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中第一个元素。（注意：该方法执行时，找到第一个元素之后，则终止操作，并返回包含第一个元素的Optional对象）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到第一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findFirst();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="2-11-findAny"><a href="#2-11-findAny" class="headerlink" title="2.11 findAny"></a>2.11 findAny</h4><p>找到流中任何一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中任何一个元素。（注意：该方法执行时，找到任何一个元素之后，则终止操作，并返回包含匹配的元素的Optional对象。该方法在并行情况下效率更佳）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到任何一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findAny();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>何时使用 findFirst 和 findAny</strong></p><blockquote><p>你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p></blockquote><h4 id="2-12-reduce"><a href="#2-12-reduce" class="headerlink" title="2.12 reduce"></a>2.12 reduce</h4><p>规约：包含2个方法</p><p><strong>第一个方法</strong></p><p>该方法接受一个与流元素类型相同的泛型对象 T 和一个 BinaryOperator(该类继承了BiFunction)对象；返回一个与流元素类型相同的规约后的对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure></p><p><strong>第二个方法</strong></p><p>该方法接受一个 BinaryOperator<T> 对象；返回 Optional<T> 对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></T></T></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer::sum);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce((a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最大值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:max);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最小值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:min);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p><strong>2个方法的区别</strong></p><blockquote><p>第一个方法接受了一个对象，执行规约方法时会将入参与流中的元素规约到一起。<br>第二个方法只对流中的元素进行规约，因为源可能是空的，所以返回一个Optional对象。</p></blockquote><h4 id="2-13-count"><a href="#2-13-count" class="headerlink" title="2.13 count"></a>2.13 count</h4><p>对流中元素进行计数，返回一个long类型的对象。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().count();</span><br><span class="line">    System.out.println(count));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="2-14-注意："><a href="#2-14-注意：" class="headerlink" title="2.14 注意："></a>2.14 注意：</h4><blockquote><ul><li>filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你用不着为了让某些数据处理任务并行而去操心线程和锁了，Stream API都替你做好了！</li><li>对于流而言，某些操作（例如allMatch、anyMatch、noneMatch、findFirst和findAny）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流</li></ul></blockquote><hr><h2 id="3-数值流"><a href="#3-数值流" class="headerlink" title="3. 数值流"></a>3. 数值流</h2><p>我们在计算流中元素总和时，通常情况下会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码问题是它暗藏拆箱成本。每个Integer都必须拆成一个原始类型再进行求和。</p><h4 id="3-1-原始类型特化"><a href="#3-1-原始类型特化" class="headerlink" title="3.1 原始类型特化"></a>3.1 原始类型特化</h4><p>说明：</p><blockquote><p>Java 8 引入了三个原始类型特化流接口来解决上面这个暗藏拆箱成本的问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。要记住的是，这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和Integer之间的效率差异。</p></blockquote><p><strong>映射到数值流</strong></p><blockquote><ul><li>mapToInt：    映射成IntStream</li><li>mapToLong：   映射成LongStream</li><li>mapToDouble： 映射成DoubleStream</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;映射到数值流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).sum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换回对象流</strong></p><p>通过boxed()方法，转换回对象流，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过boxed()方法，转换回对象流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).boxed().reduce(0, Integer::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).boxed().reduce(0L, Long::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).boxed().reduce(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值</strong></p><p>对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。</p><p><strong>数值范围</strong></p><p>通过使用range() 和 rangeClosed() 方法生成数值范围。</p><blockquote><ul><li>range(int startInclusive, int endExclusive) 方法： 生成 [startInclusive, endExclusive) 范围内数值流（左闭右开）。</li><li>rangeClosed(int startInclusive, int endInclusive) 方法： 生成 [startInclusive, endInclusive] 范围内数值流（左闭右闭）。</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(IntStream.range(1, 100).count());</span><br><span class="line">    System.out.println(IntStream.rangeClosed(1, 100).count());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td></tr></table></figure><hr><h2 id="4-构建流"><a href="#4-构建流" class="headerlink" title="4. 构建流"></a>4. 构建流</h2><p>这里主要介绍由集合、数值、数组、文件来创建流；最后介绍下由生成函数来创建无限流。</p><h4 id="4-1-由集合生成流"><a href="#4-1-由集合生成流" class="headerlink" title="4.1 由集合生成流"></a>4.1 由集合生成流</h4><p>Java 8 的 Collection 新增了 stream() 的 Api，集合对象通过调用 stream() 方法生成流。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;sungm&quot;, &quot;other&quot;);</span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure><h4 id="4-2-由数值生成流"><a href="#4-2-由数值生成流" class="headerlink" title="4.2 由数值生成流"></a>4.2 由数值生成流</h4><p>通过 Stream.of() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;sungm&quot;, &quot;other&quot;);</span><br></pre></td></tr></table></figure><h4 id="4-3-由数组生成流"><a href="#4-3-由数组生成流" class="headerlink" title="4.3 由数组生成流"></a>4.3 由数组生成流</h4><p>通过 Arrays.stream() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(numbers);</span><br></pre></td></tr></table></figure><h4 id="4-4-由文件生成流"><a href="#4-4-由文件生成流" class="headerlink" title="4.4 由文件生成流"></a>4.4 由文件生成流</h4><p>java nio</p><blockquote><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。例如：Files.lines()方法</p></blockquote><h4 id="4-5-函数生成流：创建无限流"><a href="#4-5-函数生成流：创建无限流" class="headerlink" title="4.5 函数生成流：创建无限流"></a>4.5 函数生成流：创建无限流</h4><p>Stream.iterate()方法和Stream.generate()方法：</p><blockquote><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;我们通过使用limit()方法来截断流</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>无限流是没有固定大小的流</p></blockquote><hr><h2 id="5-用流收集数据"><a href="#5-用流收集数据" class="headerlink" title="5. 用流收集数据"></a>5. 用流收集数据</h2><h4 id="5-1-Collectors-收集器"><a href="#5-1-Collectors-收集器" class="headerlink" title="5.1 Collectors (收集器)"></a>5.1 Collectors (收集器)</h4><p><strong>简介</strong></p><blockquote><ul><li>Stream类的collect方法是一个终端操作，类似于Stream类的reduce方法，可以接受做法作为参数，将流中的元素累积成一个汇总结果，而collect方法接受的就是一个 Collector 对象。</li><li>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）；再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。</li><li>Collectors 非常有用，因为它可以简洁和灵活的定义collect用来生成结果集合的标准。更具体地说，对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）</li><li>Collectors 是 Collector 的工厂类。</li></ul></blockquote><p><strong>预定义收集器</strong></p><p>Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p><blockquote><p>将流元素归约和汇总为一个值<br>元素分组<br>元素分区</p></blockquote><h4 id="5-2-归约和汇总"><a href="#5-2-归约和汇总" class="headerlink" title="5.2 归约和汇总"></a>5.2 归约和汇总</h4><h5 id="5-2-1-counting-计数"><a href="#5-2-1-counting-计数" class="headerlink" title="5.2.1 counting (计数)"></a>5.2.1 counting (计数)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().collect(Collectors.counting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>使用 number.stream().count() 进行计数更直接，但是counting收集器在和其他收集器联合使用的时候特别有用。</p></blockquote><h5 id="5-2-2-maxBy-最大值"><a href="#5-2-2-maxBy-最大值" class="headerlink" title="5.2.2 maxBy (最大值)"></a>5.2.2 maxBy (最大值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; maxNumber &#x3D; numbers.stream().collect(Collectors.maxBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().max(Comparator.comparingInt(a -&gt; a)) 获取最大值</p></blockquote><h5 id="5-2-3-minBy-最小值"><a href="#5-2-3-minBy-最小值" class="headerlink" title="5.2.3 minBy (最小值)"></a>5.2.3 minBy (最小值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; minNumber &#x3D; numbers.stream().collect(Collectors.minBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().min(Comparator.comparingInt(a -&gt; a)) 获取最小值</p></blockquote><h5 id="5-2-4-summingInt、summarizingLong、summarizingDouble-求和"><a href="#5-2-4-summingInt、summarizingLong、summarizingDouble-求和" class="headerlink" title="5.2.4 summingInt、summarizingLong、summarizingDouble (求和)"></a>5.2.4 summingInt、summarizingLong、summarizingDouble (求和)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求和</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以将流转换成数值流之后再对数值流进行求和，例如： numbers.stream().maoToInt(a -&gt; a).sum()。</p></blockquote><h5 id="5-2-5-averagingInt、averagingLong、averagingDouble-求平均值"><a href="#5-2-5-averagingInt、averagingLong、averagingDouble-求平均值" class="headerlink" title="5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)"></a>5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求平均值</span><br><span class="line">    double averagingInt &#x3D; numbers.stream().collect(Collectors.averagingInt(a -&gt; a));</span><br><span class="line">    double averagingLong &#x3D; numbers.stream().collect(Collectors.averagingLong(a -&gt; (long) a));</span><br><span class="line">    double averagingDouble &#x3D; numbers.stream().collect(Collectors.averagingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结"><a href="#5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结" class="headerlink" title="5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)"></a>5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;对数值进行总结，获取流元素的数值和、最大值、最小值、平均值、计数。</span><br><span class="line">    IntSummaryStatistics intSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    LongSummaryStatistics longSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    DoubleSummaryStatistics doubleSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line"></span><br><span class="line">    System.out.println(intSummaryStatistics.toString());</span><br><span class="line">    System.out.println(longSummaryStatistics.toString());</span><br><span class="line">    System.out.println(doubleSummaryStatistics.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">IntSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">LongSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">DoubleSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36.000000, min&#x3D;1.000000, average&#x3D;4.500000, max&#x3D;8.000000&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>通过一次 summarizing 操作你可以就计算出元素的个数，并得到元素总和、平均值、最大值和最小值。</p></blockquote><h5 id="5-2-7-join-连接字符串"><a href="#5-2-7-join-连接字符串" class="headerlink" title="5.2.7 join 连接字符串"></a>5.2.7 join 连接字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;);</span><br><span class="line">    &#x2F;&#x2F;直接连接字符串</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining()));</span><br><span class="line">    &#x2F;&#x2F;字符串之间用指定的delimiter(定界符)连接字符</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining(&quot;, &quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">OneTwoThreeFourFiveSix</span><br><span class="line">One, Two, Three, Four, Five, Six</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>某些情况下，可以使用String.join()方法更直接。 例如：String.join(“, “, list);</p></blockquote><h4 id="5-2-8-reducing-规约-5-2章节的重点"><a href="#5-2-8-reducing-规约-5-2章节的重点" class="headerlink" title="5.2.8 reducing 规约(5.2章节的重点)"></a>5.2.8 reducing 规约(5.2章节的重点)</h4><p><strong>Collectors类中存在3个reducing()方法，下面我们逐个介绍</strong></p><blockquote><ul><li>reducing(Object, Function, BinaryOperator)</li><li>reducing(Object, BinaryOperator)</li><li>reducing(BinaryOperator)</li></ul></blockquote><p><strong>说明：</strong></p><blockquote><p>我们上面讨论的7种方法（5.2.1 - 5.2.7）都是一个可以用 reducing 工厂方法定义的归约过程的特殊情况而已。Collectors.reducing 工厂方法是所有这些特殊情况的一般化。<br>Collectors类中存在3个reducing()方法功能类似。</p></blockquote><p><strong>方法一：reducing(Object, Function, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? super T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口Function对象，该Function对象将流元素对象转换成你所需要进行规约操作的对象</li><li>该方法第三个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 成绩</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-07-05 14:32</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Grade &#123;</span><br><span class="line"></span><br><span class="line">    private String studentName;</span><br><span class="line">    private String course;</span><br><span class="line">    private Double score;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter、setter、toString、以及无参构造方法和全参构造方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().collect(Collectors.reducing(0D, Grade::getScore, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：reducing(Object, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, T&gt;</span><br><span class="line">reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0],</span><br><span class="line">            CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：reducing(BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    class OptionalBox implements Consumer&lt;T&gt; &#123;</span><br><span class="line">        T value &#x3D; null;</span><br><span class="line">        boolean present &#x3D; false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void accept(T t) &#123;</span><br><span class="line">            if (present) &#123;</span><br><span class="line">                value &#x3D; op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                value &#x3D; t;</span><br><span class="line">                present &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::new, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; if (b.present) a.accept(b.value); return a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法入参是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li><li>该方法返回一个Optional<T>类的对象。</T></li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学视所有课程的总成绩</span><br><span class="line">    Optional&lt;Double&gt; score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别"><a href="#5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别" class="headerlink" title="5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别"></a>5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别</h4><p> 示例：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 8)</span><br><span class="line">        .boxed()</span><br><span class="line">        .reduce(new ArrayList&lt;&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; &#123;</span><br><span class="line">            l.add(e);</span><br><span class="line">            return l;</span><br><span class="line">        &#125;, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; &#123;</span><br><span class="line">            l1.addAll(l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>区别:</p><blockquote><p>Stream类的reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反，collect方法的设计就是要改变容器，从而累积要输出的结果。这意味着，上面的示例的代码片段是在滥用reduce方法，因为它在原地改变了作为累加器的List。<br>以错误的语义使用Stream类的reduce方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏List本身。在这种情况下，如果你想要线程安全，就需要每次分配一个新的List，而对象分配又会影响性能。这就是collect方法特别适合表达可变容器上的归约的原因，更关键的是它适合并行操作</p></blockquote><p>使用收集器的的好处：</p><blockquote><ul><li>灵活性更强：可以以不同的方法执行同样的操作。</li><li>根据情况选择最佳解决方案：收集器在某种程度上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</li></ul></blockquote><p><strong>建议：</strong></p><blockquote><p>就实际应用而言，建议使用Collectors类的reduce方法，无轮从可读性还是性能上讲，Collectors类的reduce方法都更好。</p></blockquote><h2 id="5-3-分组"><a href="#5-3-分组" class="headerlink" title="5.3 分组"></a>5.3 分组</h2><h4 id="5-3-1-groupingBy-分组"><a href="#5-3-1-groupingBy-分组" class="headerlink" title="5.3.1 groupingBy 分组"></a>5.3.1 groupingBy 分组</h4><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(1L, &quot;miracle&quot;, 25, &quot;Boy&quot;)</span><br><span class="line">            , new Student(2L, &quot;bob&quot;, 24, &quot;Boy&quot;)</span><br><span class="line">            , new Student(3L, &quot;lucky&quot;, 22, &quot;Girl&quot;)</span><br><span class="line">            , new Student(3L, &quot;lusa&quot;, 24, &quot;Girl&quot;));</span><br><span class="line">    &#x2F;&#x2F;按照性别分组</span><br><span class="line">    Map&lt;String, List&lt;Student&gt;&gt; map &#x3D; students.stream().collect(Collectors.groupingBy(Student::getSex));</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#123;</span><br><span class="line">    Girl&#x3D;[Student&#123;id&#x3D;3, name&#x3D;&#39;lucky&#39;, age&#x3D;22, sex&#x3D;&#39;Girl&#39;&#125;, Student&#123;id&#x3D;3, name&#x3D;&#39;lusa&#39;, age&#x3D;24, sex&#x3D;&#39;Girl&#39;&#125;], </span><br><span class="line">    Boy&#x3D;[Student&#123;id&#x3D;1, name&#x3D;&#39;miracle&#39;, age&#x3D;25, sex&#x3D;&#39;Boy&#39;&#125;, Student&#123;id&#x3D;2, name&#x3D;&#39;bob&#39;, age&#x3D;24, sex&#x3D;&#39;Boy&#39;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>示例中给groupingBy传入一个Function，我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p></blockquote><p>groupingBy源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    return groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Stream&quot;&gt;&lt;a href=&quot;#1-Stream&quot; class=&quot;headerlink&quot; title=&quot;1. Stream&quot;&gt;&lt;/a&gt;1. Stream&lt;/h2&gt;&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Stream：支持数据处理操
      
    
    </summary>
    
    
    
      <category term="Java 8 新特性" scheme="http://yoursite.com/tags/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="http://yoursite.com/2020/06/28/Effective-Java-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/28/Effective-Java-%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-28T12:00:48.000Z</published>
    <updated>2020-06-30T03:29:46.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-考虑使用静态工厂方法代替构造方法"><a href="#1-考虑使用静态工厂方法代替构造方法" class="headerlink" title="1. 考虑使用静态工厂方法代替构造方法"></a>1. 考虑使用静态工厂方法代替构造方法</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-静态工厂方法代替构造方法的优缺点"><a href="#1-1-静态工厂方法代替构造方法的优缺点" class="headerlink" title="1.1 静态工厂方法代替构造方法的优缺点"></a>1.1 静态工厂方法代替构造方法的优缺点</h4><blockquote><p>优点：</p><ul><li>静态工厂方法不需要每次都创建一个对象，而构造方法每次都会创建一个对象。</li><li>静态工厂方法返回值可以是任何对象，而构造方法返回指定的对象。</li><li>静态工厂方法返回值可以根据入参的不同而不同。</li><li>静态工厂方法有自定义的方法名，构造方法方法名与类名相同。</li></ul></blockquote><blockquote><p>缺点:</p><ul><li>限制：没有公共或受保护的构造方法不能被子类化。（假如定义一个Person类，且该类没有公共或受保护的构造函数，如果我们想定义一个类来继承Person类，将发生编译错误）</li><li>静态方法不如构造方法易发现，不仔细阅读源码我们很难找到他们。</li></ul></blockquote><h4 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h4><blockquote><ul><li>定义静态工厂方法代替构造方法时，建议将构造方法设置成私有的（private）或受保护的（protected）。</li><li>如果定义一个静态工厂方法用来代替构造方法，且静态构造方法每次被调用都返回一个新对象，那么使用静态工厂方法代替构造方法将意义不大。</li><li>根据需要，重载静态工厂方法。</li></ul></blockquote><hr><h2 id="2-当构造方法参数过多时，使用Builder模式"><a href="#2-当构造方法参数过多时，使用Builder模式" class="headerlink" title="2 当构造方法参数过多时，使用Builder模式"></a>2 当构造方法参数过多时，使用Builder模式</h2><p>说明：</p><blockquote><p>使用Builder模式可以使用简化代码，提高代码可读性。（这里对Builder模式不做过多的解释，若您想了解Builder模式，请百度。）</p></blockquote><h4 id="2-1-方式一：使用Lombok插件"><a href="#2-1-方式一：使用Lombok插件" class="headerlink" title="2.1 方式一：使用Lombok插件"></a>2.1 方式一：使用Lombok插件</h4><blockquote><p> 安装Lombok插件，引入Lombok依赖之后使用Lombok的@Builder注解。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义响应值</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-23 17:28</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">public class ResponseDTO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;序列化</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    private String resultCode;</span><br><span class="line">    private String resultMessage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主函数</span><br><span class="line"> * </span><br><span class="line"> * @param args      入参</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ResponseDTO response &#x3D; ResponseDTO.builder()</span><br><span class="line">        .resultCode(ResultEnum.ONE.getResultCode())</span><br><span class="line">        .resultMessage(ResultEnum.ONE.getResultMessage())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>使用Lombok插件还是蛮香的，我们可以通过使用Lombok定义的注解，来减少了我们编写的代码量、提高了代码可读性，但是Lombok插件会增加我们程序编译的时间，且通常情况下我们也可以通过使用IDEA的快捷键来自动生成代码。</p></blockquote><h4 id="2-2-方式二：使用通用Builder工具类"><a href="#2-2-方式二：使用通用Builder工具类" class="headerlink" title="2.2 方式二：使用通用Builder工具类"></a>2.2 方式二：使用通用Builder工具类</h4><p>Builder工具类博客地址：</p><blockquote><p><a href="https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/" target="_blank" rel="noopener">https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/</a></p></blockquote><h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><blockquote><ul><li>对于方式一和方式二的选择，仁者见仁智者见智，你更喜欢哪种方式呢？或者你还有其他更好的方式？</li></ul></blockquote><hr><h2 id="3-使用私有构造方法或枚举实现单例模式"><a href="#3-使用私有构造方法或枚举实现单例模式" class="headerlink" title="3. 使用私有构造方法或枚举实现单例模式"></a>3. 使用私有构造方法或枚举实现单例模式</h2><p>说明：</p><blockquote><p>单例是一个仅实例化一次的类，通常情况下表示无状态对象。</p></blockquote><h4 id="3-1-使用私有构造方法实现单例模式"><a href="#3-1-使用私有构造方法实现单例模式" class="headerlink" title="3.1 使用私有构造方法实现单例模式"></a>3.1 使用私有构造方法实现单例模式</h4><p><em>两种常见的单例模式实现方式</em></p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明公共属性的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonOne &#123;</span><br><span class="line"></span><br><span class="line">    public static final SingletonOne INSTANCE &#x3D; new SingletonOne();</span><br><span class="line"></span><br><span class="line">    private SingletonOne() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明静态工厂方法的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonTwo &#123;</span><br><span class="line"></span><br><span class="line">    private static final SingletonTwo INSTANCE &#x3D; new SingletonTwo();</span><br><span class="line"></span><br><span class="line">    private SingletonTwo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonTwo getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>方式一和方式二的构造函数都是私有构造函数，且定义了一个 static final 类型的INSTANCE变量，并使其实例化，确保了该类只能被实例化一次，保证了全局的唯一性。</li><li>不论是方式一还是方式二，特殊情况下可以通过使用反射的方式调用构造方法创建对象，如果需要防止此操作的产生，需修改构造方法，使其请求创建第二个对象时抛出异常。</li></ul></blockquote><p>建议：</p><blockquote><p>建议通过静态工厂方法（方式二）来创建单例。原因是通过静态工厂的方式更加灵活，并且可以根据需要设计泛型单例工厂，并且还能使用函数式接口Supplier，例如Singleton::getInstance。</p></blockquote><h4 id="3-2-通过使用枚举设计单例模式"><a href="#3-2-通过使用枚举设计单例模式" class="headerlink" title="3.2 通过使用枚举设计单例模式"></a>3.2 通过使用枚举设计单例模式</h4><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是单一元素枚举类通常是实现单例的最佳方式。</p></blockquote><p>注意：</p><blockquote><p>如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p></blockquote><hr><h2 id="4-使用私有构造方法执行非实例化"><a href="#4-使用私有构造方法执行非实例化" class="headerlink" title="4. 使用私有构造方法执行非实例化"></a>4. 使用私有构造方法执行非实例化</h2><p>场景说明：</p><blockquote><p>当我们希望设计一个类只包含静态方法和静态属性时，为了避免这样的类被实例化，可以通过声明私有的构造方法达到类不被实例化的目的。</p></blockquote><p>副作用：</p><blockquote><p>当我们想设计一个子类来继承私有化构造函数的父类时，将报编译异常。因为所有构造方法都必须显示或者隐式的调用父类的构造方法，若父类的构造函数被私有化，则子类没有访问父类构造函数的权限，因此报错。</p></blockquote><hr><h2 id="5-比起硬资源连接，优先使用依赖注入"><a href="#5-比起硬资源连接，优先使用依赖注入" class="headerlink" title="5. 比起硬资源连接，优先使用依赖注入"></a>5. 比起硬资源连接，优先使用依赖注入</h2><p>硬资源连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Dictionary &#123;</span><br><span class="line">    &#x2F;&#x2F;定义字典</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;硬资源连接：想当然的认为一本字典就够了，无法承载多字典的场景</span><br><span class="line">    private static final Dictionary DICTIONARY &#x3D; new ChineseDictionary();</span><br><span class="line"></span><br><span class="line">    private SpellChecker() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义字典接口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义中文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ChineseDictionary implements Dictionary&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义英文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EnglishDictionary implements Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 拼写检查器</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    private final Dictionary DICTIONARY;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用依赖注入的方式，创建对象时将字典注入到对象属性中</span><br><span class="line">    public SpellChecker(Dictionary dictionary) &#123;</span><br><span class="line">        this.DICTIONARY &#x3D; dictionary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>当一个类依赖于一个或多个底层资源时，该类的实现方式不要使用单例或静态的实用类，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p></blockquote><hr><h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>说明：</p><blockquote><p>通常情况下，重用对象比创建一个相同功能的对象的做法更恰当，重用可以使程序更快的执行且耗用更少的内存。如果一个对象是不可变的，他总是可以被重用。</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请不要这样写代码</span><br><span class="line">String name &#x3D; new String(&quot;sungm&quot;);</span><br></pre></td></tr></table></figure><p>这样写代码产生的结果：</p><blockquote><p>该语句每次执行时都会创建一个新的String实例，并且这些对象都不是必须的。String的构造方法String(String original)的入参original本身就是一个String实例，它与构造方法创建的对象的功能相同。</p></blockquote><p>优化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; &quot;sungm&quot;;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过使用静态工厂方法，可以避免创建不必要的对象。<blockquote><p>例如：使用静态工厂方法 Boolean.parseBoolean(String) 比构造方法 Boolean(String) 好的多，构造方法每次调用都会创建一个新的对象，而工厂方法永远不需要这样做，在实践中也不需要。</p></blockquote></li><li>一些对象的创建比其他对象的创建的代价要昂贵的多，如果要使用这样一个昂贵的对象，建议将其缓存起来以便重复使用。<blockquote><p>例如创建创建正则表达式的 Pattern 对象，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p></blockquote></li><li>当一些对象是不可变（final定义的对象）的时侯，很明显它可以被重用，但是在其他情况下，没有很明显的可以被重用，这种情况下需谨慎考虑是否重用对象。</li><li>自动装箱的情况下是不需要创建不必要的对象的，自动装箱允许程序员混用基本数据类型和装箱类型，根据需要自动装箱和拆箱。<blockquote><p>建议：优先使用基本数据类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p></blockquote></li></ul><hr><h2 id="7-消除过期对象的引用"><a href="#7-消除过期对象的引用" class="headerlink" title="7. 消除过期对象的引用"></a>7. 消除过期对象的引用</h2><p>举例：</p><blockquote><p>《Effective Java》原书中该章节举了一个栈（Stock）弹出元素（pop）没有及时清空弹出的元素引用，当Stock扩容后收缩，容易发生内存溢出异常。</p></blockquote><p>好处：</p><blockquote><ul><li>及时消除过期对象的引用，减少内存消耗，增加程序执行速度，同时可以避免因内存溢出导致程序异常。</li><li>消除过期对象的引用有一个好处是程序错误的引用过期的对象之后能及时抛出NPE(空指针异常)，而不是让程序在引用过期的对象之后继续悄悄地做错误的事请。</li></ul></blockquote><p>不建议：</p><blockquote><ul><li>不建议程序结束后立即清空所有对象的引用，因为这是Java垃圾回收器的工作。清空对象引用应该是例外而不是规范，程序结束后立即清空所有对象的引用是不必要的，也是不可取的。</li></ul></blockquote><p>常见的内存溢出：</p><blockquote><ul><li>当一个类自己管理内存时，应警惕内存泄漏的问题</li><li>缓存：防止业务数据缓存之后没有及时清空</li><li>监听器和回调，防止程序执行时间过长导致内存溢出。</li></ul></blockquote><p>总结：</p><blockquote><ul><li>内存溢出问题通常情况下不会变现出明显的故障，但一些没必要的内存消耗可能一直存在于系统中，建议多留意代码细节和实现方式，减少不必要的内存消耗。</li></ul></blockquote><hr><h2 id="8-避免使用-Finalizer-和-Cleaner-机制"><a href="#8-避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="8. 避免使用 Finalizer 和 Cleaner 机制"></a>8. 避免使用 Finalizer 和 Cleaner 机制</h2><p>//TODO 待完成</p><hr><h2 id="9-使用-try-with-resource-语句代替-try-finally-语句"><a href="#9-使用-try-with-resource-语句代替-try-finally-语句" class="headerlink" title="9. 使用 try-with-resource 语句代替 try-finally 语句"></a>9. 使用 try-with-resource 语句代替 try-finally 语句</h2><p>说明：</p><blockquote><ul><li>Java 类库中有很多必须通过调用 close 方法手动关闭的资源。比如 InputStream、OutputStream 等等。年轻的程序员可能经常忽略关闭这些资源，未及时关闭资源会影响系统性能，甚至终止程序。尽管这些资源中有很多使用 finalizer 机制作为安全网，但 finalizer 机制却不能很好地工作。</li><li>在我们 JDK 7 发布之前，我们使用 try-finally 语句保证资源的正确关闭是最佳的方式，JDK 7 发布之后，我们可以通过使用 try-with-resource 更好的关闭资源，但是使用 try-with-resource 关闭资源必须满足一些条件，详见下文。</li></ul></blockquote><p>使用 try-with-resource 语句需满足的条件：</p><blockquote><ul><li>资源需实现 AutoCloseable 接口， Java 类库中和第三方类库中许多类都实现或继承了该接口，如果我们程序设计的类需要关闭资源，那么这个类也应该实现 AutoCloseable 接口。</li></ul></blockquote><p>使用 try-with-resource 语句的优点：</p><blockquote><p>比 try-finally 语句更加精简，具有更好的可读性，并且生成的异常更有用。<br>比 try-finally 语句关闭资源更容易，也不会出错。</p></blockquote><p>使用 try-with-resource 语句关闭资源时的特征：</p><blockquote><p>先声明的资源先关闭，后声明的资源后关闭。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先关闭 fin 资源, 接着关闭 fout 资源, 最后关闭 out 资源</span><br><span class="line">try (</span><br><span class="line">        FileInputStream fin &#x3D; new FileInputStream(input);</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(output);</span><br><span class="line">        GZIPOutputStream out &#x3D; new GZIPOutputStream(fout)</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F;do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>这里不详细说明 try-with-resource 语句的用法，想要了解的同学可以网上搜索相关资料。</p></blockquote><hr><h2 id="10-重写-equals-方法时遵守通用约定"><a href="#10-重写-equals-方法时遵守通用约定" class="headerlink" title="10. 重写 equals 方法时遵守通用约定"></a>10. 重写 equals 方法时遵守通用约定</h2><p>//TODO 待完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-考虑使用静态工厂方法代替构造方法&quot;&gt;&lt;a href=&quot;#1-考虑使用静态工厂方法代替构造方法&quot; class=&quot;headerlink&quot; title=&quot;1. 考虑使用静态工厂方法代替构造方法&quot;&gt;&lt;/a&gt;1. 考虑使用静态工厂方法代替构造方法&lt;/h2&gt;&lt;p&gt;例如：&lt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>验证XML</title>
    <link href="http://yoursite.com/2020/06/18/%E9%AA%8C%E8%AF%81XML/"/>
    <id>http://yoursite.com/2020/06/18/%E9%AA%8C%E8%AF%81XML/</id>
    <published>2020-06-18T06:53:53.000Z</published>
    <updated>2020-06-18T09:16:09.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><ul><li>如果我们解析XML之后，获取到XML的内容，再校验XML内容或格式是否符合设计规范，这个工作是很繁琐的。</li><li>幸好，XML解析器的一个很大的好处就是它能够自动校验某个文档是否具有正确的结构，这样解析工作就变的简单的多。</li><li>通过定义一个 <a href="https://www.w3school.com.cn/dtd/dtd_intro.asp" target="_blank" rel="noopener">DTD</a> 或者 <a href="https://www.w3school.com.cn/schema/schema_intro.asp" target="_blank" rel="noopener">XML Schema</a>， DTD 或者 Schema 包含了用于解释文档如何构成的规则，这些规则指定了每个元素的合法子元素和属性。</li></ul></blockquote><hr><h2 id="2-定义DTD校验规则"><a href="#2-定义DTD校验规则" class="headerlink" title="2. 定义DTD校验规则"></a>2. 定义DTD校验规则</h2><p><strong>XML文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!-- 定义DTD校验规则 --&gt;</span><br><span class="line">&lt;!DOCTYPE class [</span><br><span class="line">    &lt;!-- 定义class至少包含一个student --&gt;</span><br><span class="line">    &lt;!ELEMENT class (student+)&gt;</span><br><span class="line">    &lt;!-- 定义student只包含name,age,sex,className属性 --&gt;</span><br><span class="line">    &lt;!ELEMENT student (name, age, sex, className)&gt;</span><br><span class="line">        &lt;!-- 定义id属性, 属性默认值为0 --&gt;</span><br><span class="line">        &lt;!ATTLIST student id CDATA &quot;0&quot;&gt;</span><br><span class="line">    &lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT className (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果我们解析XML之后，获取到XML的内容，再校验XML内容或格式是否符合设计规范
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>解析XML</title>
    <link href="http://yoursite.com/2020/06/16/%E8%A7%A3%E6%9E%90XML/"/>
    <id>http://yoursite.com/2020/06/16/%E8%A7%A3%E6%9E%90XML/</id>
    <published>2020-06-16T08:36:40.000Z</published>
    <updated>2020-06-18T04:42:51.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>Java 8 官方API : <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8 API</a></li><li>github代码地址: <a href="https://github.com/miracle-sungm/learn_xml" target="_blank" rel="noopener">Github</a></li></ul></blockquote><hr><h2 id="1-DOM解析XML"><a href="#1-DOM解析XML" class="headerlink" title="1. DOM解析XML"></a>1. DOM解析XML</h2><p><strong>xml文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.w3c.dom.*;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-16 16:59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者工厂实例（设计模式：工厂模式）</span><br><span class="line">        DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者实例（设计模式：Builder模式）</span><br><span class="line">        DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">        &#x2F;&#x2F;使用xml解析器builder解析文档，获取解析后的Document对象</span><br><span class="line">        Document document &#x3D; builder.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取根元素</span><br><span class="line">        Element rootElement &#x3D; document.getDocumentElement();</span><br><span class="line">        &#x2F;&#x2F;获取文档中student元素列表（也可以直接通过document.getElementsByTagName(&quot;student&quot;)获取所有的student元素）</span><br><span class="line">        NodeList studentNodes &#x3D; rootElement.getElementsByTagName(&quot;student&quot;);</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; studentNodes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            Element element &#x3D; (Element) studentNodes.item(index);</span><br><span class="line">            &#x2F;&#x2F;元素（备注：通过getElementsByTagName()方法获取指定的元素）</span><br><span class="line">            Element nameElement &#x3D; (Element) element.getElementsByTagName(&quot;name&quot;).item(0);</span><br><span class="line">            Element ageElement &#x3D; (Element) element.getElementsByTagName(&quot;age&quot;).item(0);</span><br><span class="line">            Element sexElement &#x3D; (Element) element.getElementsByTagName(&quot;sex&quot;).item(0);</span><br><span class="line">            Element classElement &#x3D; (Element) element.getElementsByTagName(&quot;className&quot;).item(0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;文本（备注：通过getNodeName()方法获取元素名称，通过getTextContent()方法获取文本内容）</span><br><span class="line">            System.out.println(nameElement.getNodeName()  + &quot; : &quot; + nameElement.getTextContent());</span><br><span class="line">            System.out.println(ageElement.getNodeName()   + &quot; : &quot; + ageElement.getTextContent());</span><br><span class="line">            System.out.println(sexElement.getNodeName()   + &quot; : &quot; + sexElement.getTextContent());</span><br><span class="line">            System.out.println(classElement.getNodeName() + &quot; : &quot; + classElement.getTextContent());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;属性（备注：通过getAttributeNode(name)方法属性节点，通过getAttribute(name)方法获取属性内容）</span><br><span class="line">            Attr nameAttr &#x3D; nameElement.getAttributeNode(&quot;nameAttr&quot;);</span><br><span class="line">            Attr ageAttr &#x3D; ageElement.getAttributeNode(&quot;ageAttr&quot;);</span><br><span class="line">            Attr sexAttr &#x3D; sexElement.getAttributeNode(&quot;sexAttr&quot;);</span><br><span class="line">            Attr classAttr &#x3D; classElement.getAttributeNode(&quot;classAttr&quot;);</span><br><span class="line">            System.out.println(nameAttr.getName()  + &quot; : &quot; + nameAttr.getValue());</span><br><span class="line">            System.out.println(ageAttr.getName()   + &quot; : &quot; + ageAttr.getValue());</span><br><span class="line">            System.out.println(sexAttr.getName()   + &quot; : &quot; + sexAttr.getValue());</span><br><span class="line">            System.out.println(classAttr.getName()   + &quot; : &quot; + classAttr.getValue());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">name : sungm</span><br><span class="line">age : 25</span><br><span class="line">sex : Man</span><br><span class="line">className : Class One</span><br><span class="line">nameAttr : sungm</span><br><span class="line">ageAttr : 25</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassOne</span><br><span class="line"></span><br><span class="line">name : sunhw</span><br><span class="line">age : 1</span><br><span class="line">sex : Man</span><br><span class="line">className : Class Two</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">ageAttr : 1</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>树结构，方便理解与使用</li><li>解析过程中树结构保存在内存中，方便修改</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>当文件过大时耗用内存，需谨慎使用</li></ul></blockquote><hr><h2 id="2-SAX解析XML"><a href="#2-SAX解析XML" class="headerlink" title="2. SAX解析XML"></a>2. SAX解析XML</h2><p><strong>xml文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>自定义Handler处理器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import org.xml.sax.Attributes;</span><br><span class="line">import org.xml.sax.SAXException;</span><br><span class="line">import org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:42</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StudentParserHandler extends DefaultHandler &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String ROOT_ELEMENT &#x3D; &quot;class&quot;;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法执行顺序：startDocument -&gt; startElement -&gt; characters -&gt; endElement -&gt; characters -&gt; endDocument</span><br><span class="line">    &#x2F;&#x2F;执行次数        只执行一次      元素循环执行    元素循环执行   元素循环执行   元素循环执行    只执行一次</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startDocument() throws SAXException &#123;</span><br><span class="line">        super.startDocument();</span><br><span class="line">        System.out.println(&quot;开始解析XML文档&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endDocument() throws SAXException &#123;</span><br><span class="line">        super.endDocument();</span><br><span class="line">        System.out.println(&quot;解析XML文档结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">        super.startElement(uri, localName, qName, attributes);</span><br><span class="line">        System.out.println(Constants.ROOT_ELEMENT.equals(qName) ? &quot;开始解析根节点&quot; : &quot;节点名称 ： &quot; + qName);</span><br><span class="line">        &#x2F;&#x2F;获取元素的属性</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; attributes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            String attrName &#x3D; attributes.getLocalName(index);</span><br><span class="line">            String attrValue &#x3D; attributes.getValue(index);</span><br><span class="line">            System.out.println(&quot;attrName &#x3D; &quot; + attrName + &quot;, attrValue &#x3D; &quot; + attrValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endElement(String uri, String localName, String qName) throws SAXException &#123;</span><br><span class="line">        super.endElement(uri, localName, qName);</span><br><span class="line">        if (Constants.ROOT_ELEMENT.equals(qName)) &#123;</span><br><span class="line">            System.out.println(&quot;解析根节点结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void characters(char[] ch, int start, int length) throws SAXException &#123;</span><br><span class="line">        super.characters(ch, start, length);</span><br><span class="line">        String value &#x3D; new String(ch, start, length).trim();</span><br><span class="line">        if (!Constants.EMPTY.equals(value)) &#123;</span><br><span class="line">            System.out.println(&quot;节点值：&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line">import javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:33</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析工厂实例</span><br><span class="line">        SAXParserFactory saxParserFactory &#x3D; SAXParserFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析器实例</span><br><span class="line">        SAXParser saxParser &#x3D; saxParserFactory.newSAXParser();</span><br><span class="line">        &#x2F;&#x2F;创建一个Handel实例</span><br><span class="line">        StudentParserHandler handler &#x3D; new StudentParserHandler();</span><br><span class="line">        &#x2F;&#x2F;解析文件</span><br><span class="line">        saxParser.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">开始解析XML文档</span><br><span class="line">开始解析根节点</span><br><span class="line">节点名称 ： class</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sungm</span><br><span class="line">节点值：sungm</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 25</span><br><span class="line">节点值：25</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassOne</span><br><span class="line">节点值：Class One</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sunhw</span><br><span class="line">节点值：sunhw</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 1</span><br><span class="line">节点值：1</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassTwo</span><br><span class="line">节点值：Class Two</span><br><span class="line">解析根节点结束</span><br><span class="line">解析XML文档结束</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>采用事件驱动的方式，耗用内存更少</li><li>适用于只需要处理xml文件的数据时使用</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>需编写自定义的handler类，不易编写</li><li>很难同时访问同一个xml中的不同数据</li></ul></blockquote><hr><h2 id="3-JDOM解析XML"><a href="#3-JDOM解析XML" class="headerlink" title="3. JDOM解析XML"></a>3. JDOM解析XML</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jdom&#x2F;jdom --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>XML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import org.jdom2.Attribute;</span><br><span class="line">import org.jdom2.Document;</span><br><span class="line">import org.jdom2.Element;</span><br><span class="line">import org.jdom2.input.SAXBuilder;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 10:46</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        SAXBuilder saxBuilder &#x3D; new SAXBuilder();</span><br><span class="line">        Document document &#x3D; saxBuilder.build(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element rootElement &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：&quot; + rootElement.getName());</span><br><span class="line">        parseElement(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        &#x2F;&#x2F;元素内容</span><br><span class="line">        if (element.getText() !&#x3D; null &amp;&amp; !Constants.EMPTY.equals(element.getTextTrim())) &#123;</span><br><span class="line">            System.out.println(element.getName() + &quot;:&quot; + element.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;元素属性</span><br><span class="line">        if (element.hasAttributes()) &#123;</span><br><span class="line">            element.getAttributes().forEach(Main::parseAttribute);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;解析子元素</span><br><span class="line">        List&lt;Element&gt; childrenElement &#x3D; element.getChildren();</span><br><span class="line">        if (childrenElement !&#x3D; null &amp;&amp; childrenElement.size() &gt; 0) &#123;</span><br><span class="line">            childrenElement.forEach(Main::parseElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Attribute attribute) &#123;</span><br><span class="line">        System.out.println(attribute.getName() + &quot; : &quot; + attribute.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">根节点：class</span><br><span class="line">name:sungm</span><br><span class="line">nameAttr : sungm</span><br><span class="line">age:25</span><br><span class="line">ageAttr : 25</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class One</span><br><span class="line">classAttr : ClassOne</span><br><span class="line">name:sunhw</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">age:1</span><br><span class="line">ageAttr : 1</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class Two</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>API简单易用，推荐使用</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>用了很多具体类，没使用接口</li></ul></blockquote><hr><h2 id="4-DOM4J解析XML"><a href="#4-DOM4J解析XML" class="headerlink" title="4. DOM4J解析XML"></a>4. DOM4J解析XML</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;dom4j&#x2F;dom4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>XML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.dom4j.Attribute;</span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 11:27</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SAXReader reader &#x3D; new SAXReader();</span><br><span class="line">        Document document &#x3D; reader.read(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element element &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：名称 &#x3D; &quot; + element.getName());</span><br><span class="line">        &#x2F;&#x2F;递归解析</span><br><span class="line">        parseElement(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        System.out.println(&quot;节点：名称 &#x3D; &quot; + element.getName() + &quot;, value &#x3D; &quot; + element.getTextTrim());</span><br><span class="line">        Iterator iterator &#x3D; element.elementIterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Element childElement &#x3D; (Element) iterator.next();</span><br><span class="line">            &#x2F;&#x2F;解析属性</span><br><span class="line">            if (childElement.attributeCount() &gt; 0) &#123;</span><br><span class="line">                childElement.attributes().forEach(Main::parseAttribute);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;解析元素</span><br><span class="line">            parseElement(childElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Object attribute) &#123;</span><br><span class="line">        System.out.println(&quot;属性：&quot; + ((Attribute) attribute).getName() + &quot; : &quot; + ((Attribute) attribute).getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">根节点：名称 &#x3D; class</span><br><span class="line">节点：名称 &#x3D; class, value &#x3D; </span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sungm</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sungm</span><br><span class="line">属性：ageAttr : 25</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 25</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassOne</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class One</span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sunhw</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sunhw</span><br><span class="line">属性：ageAttr : 1</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 1</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassTwo</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class Two</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>使用了接口和抽象方案，是个优秀的API</li><li>灵活性好、性能优异、易用性好。推荐使用</li></ul></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Java 8 官方API : &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 8 API&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
</feed>
