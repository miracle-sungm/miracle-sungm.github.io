<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miracle&#39;s Blog</title>
  
  <subtitle>Miracles happen every day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-05T02:44:56.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sungm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发编程] 23. CAS算法</title>
    <link href="http://yoursite.com/2020/09/05/CAS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/09/05/CAS%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-05T02:15:20.000Z</published>
    <updated>2020-09-05T02:44:56.643Z</updated>
    
    <content type="html"><![CDATA[<p>CAS (Compare And Swap的缩写) 算法是在设计并发程序时常用的一个算法。通常情况下， CAS 算法接收两个入参，一个期望值，一个修改值，如果期望值与实际值相同，那么将修改值赋予指定值。听起来CAS算法很复杂，实际上当你理解它之后就变得非常简单。</p><p>在JUC提供的Lock的实现类中，大量的使用了CAS算法，比如ReentrantLock，大致算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void compareAndSwap(int expect, int update) &#123;</span><br><span class="line">    if (actual &#x3D;&#x3D; expect) &#123;</span><br><span class="line">        actual &#x3D; update;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 是一种原子操作，保证了在并发情况下是线程安全的。CAS 的具体操作是比较和替换，首先比较指定值和期望值是否一致，若一致则将修改值赋予指定值。</p><p>Java 中，sun.misc.Unsafe 类提供了一系列 compareAndSwap 函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAS (Compare And Swap的缩写) 算法是在设计并发程序时常用的一个算法。通常情况下， CAS 算法接收两个入参，一个期望值，一个修改值，如果期望值与实际值相同，那么将修改值赋予指定值。听起来CAS算法很复杂，实际上当你理解它之后就变得非常简单。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 22. 线程池</title>
    <link href="http://yoursite.com/2020/09/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/09/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-09-04T08:45:05.000Z</published>
    <updated>2020-09-04T13:27:11.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h3><p>当我们需要限制一个应用程序中同一时间运行的线程数量，我们通常使用线程池来实现。</p><p>通过把任务传递给线程池，只要线程池中有空闲的线程就将空闲的线程分配任务并执行任务，而不是给每个任务都创建一个新的线程。任务被插入到阻塞队列中，当线程池存在空的线程时，阻塞队列中的任务就被分配到空闲的线程中执行。</p><p>自Java 5 开始，java.util.concurrent 包中提供了线程池，比如：java.util.concurrent.ExecutorService.</p><h3 id="2-自定义线程池"><a href="#2-自定义线程池" class="headerlink" title="2. 自定义线程池"></a>2. 自定义线程池</h3><p><strong>阻塞队列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class BlockingQueue&lt;E extends Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LinkedList&lt;E&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    private int limit;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造方法注入队列上限</span><br><span class="line">     *</span><br><span class="line">     * @param limit     队列上限</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BlockingQueue(int limit) &#123;</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void enqueue(E e) throws InterruptedException &#123;</span><br><span class="line">        while (queue.size() &#x3D;&#x3D; limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(e);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized E dequeue() throws InterruptedException &#123;</span><br><span class="line">        while (queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">        return queue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPool&lt;R extends Runnable, T extends BaseThread&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private BlockingQueue&lt;R&gt; blockingQueue;</span><br><span class="line">    private List&lt;T&gt; threads &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    private boolean stop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public ThreadPool(int blockingQueueLimit, int threadNumber, Supplier&lt;T&gt; supplier) &#123;</span><br><span class="line">        if (threadNumber &lt; 1) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Param &#39;threadNumber&#39; cannot be less than 1.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化阻塞队列</span><br><span class="line">        blockingQueue &#x3D; new BlockingQueue&lt;&gt;(blockingQueueLimit);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化线程池中的线程</span><br><span class="line">        IntStream.rangeClosed(1, threadNumber).forEach(i -&gt; &#123;</span><br><span class="line">            T t &#x3D; supplier.get();</span><br><span class="line">            t.setBlockingQueue(blockingQueue);</span><br><span class="line">            threads.add(t);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动线程</span><br><span class="line">        for (T t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void execute(R r) throws InterruptedException &#123;</span><br><span class="line">        if (stop) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;ThreadPool is stopped.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将任务添加到阻塞队列中</span><br><span class="line">        this.blockingQueue.enqueue(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.stop &#x3D; true;</span><br><span class="line">        for (T thread : threads) &#123;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义线程 BaseThread 类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class BaseThread&lt;R extends Runnable&gt; extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private BlockingQueue&lt;R&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">    public void setBlockingQueue(BlockingQueue&lt;R&gt; blockingQueue) &#123;</span><br><span class="line">        this.blockingQueue &#x3D; blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!this.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                blockingQueue.dequeue().run();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool&lt;Runnable, BaseThread&lt;Runnable&gt;&gt; threadPool &#x3D; new ThreadPool&lt;&gt;(2, 1, BaseThread::new);</span><br><span class="line">threadPool.execute(() -&gt; System.out.println(&quot;测试线程池&quot;));</span><br></pre></td></tr></table></figure><p><strong>我们只需要将任务添加到阻塞队列中，线程池中的线程会对阻塞队列循环做出队操作，并执行任务，我们还可以通过调用doStop()方法停止线程池。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-线程池&quot;&gt;&lt;a href=&quot;#1-线程池&quot; class=&quot;headerlink&quot; title=&quot;1. 线程池&quot;&gt;&lt;/a&gt;1. 线程池&lt;/h3&gt;&lt;p&gt;当我们需要限制一个应用程序中同一时间运行的线程数量，我们通常使用线程池来实现。&lt;/p&gt;
&lt;p&gt;通过把任务传递给线
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 21. 阻塞队列</title>
    <link href="http://yoursite.com/2020/09/04/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/09/04/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-09-04T08:14:32.000Z</published>
    <updated>2020-09-04T13:26:25.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-阻塞队列（Blocking-Queues）"><a href="#1-阻塞队列（Blocking-Queues）" class="headerlink" title="1. 阻塞队列（Blocking Queues）"></a>1. 阻塞队列（Blocking Queues）</h3><p>Blocking Queues 是当你尝试从一个空队列取出一个元素时、或尝试从一个满队列做插入一个元素时会被阻塞的队列。</p><p>包含：</p><blockquote><ul><li>一个线程尝试从空队列做出队操作时会被阻塞，直到其他线程插入一个元素至队列中。</li><li>一个线程尝试从满队列做入队操作时会被阻塞，直到其他线程消耗队列中的一个或多个元素、或清空队列。</li></ul></blockquote><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png" alt></div></p><p>Java 5 提供了 java.util.concurrent.BlockingQueue 的实现。</p><h3 id="2-BlockingQueues的实现"><a href="#2-BlockingQueues的实现" class="headerlink" title="2. BlockingQueues的实现"></a>2. BlockingQueues的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-04 16:31</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BlockingQueue&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LinkedList&lt;T&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    private int limit &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造方法注入阻塞队列的上线</span><br><span class="line">     *</span><br><span class="line">     * @param limit      阻塞队列的限制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BlockingQueue(int limit) &#123;</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入队操作</span><br><span class="line">     *</span><br><span class="line">     * @param node      入队元素</span><br><span class="line">     * @return boolean  结果</span><br><span class="line">     * @throws InterruptedException   e</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized boolean enqueue(T node) throws InterruptedException &#123;</span><br><span class="line">        while (queue.size() &#x3D;&#x3D; limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">        return queue.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 出队操作</span><br><span class="line">     *</span><br><span class="line">     * @return T 出队元素</span><br><span class="line">     * @throws InterruptedException   e</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized T dequeue() throws InterruptedException &#123;</span><br><span class="line">        while (queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            wait();   </span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">        &#x2F;&#x2F;第一个元素出队并删除引用</span><br><span class="line">        return queue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-阻塞队列（Blocking-Queues）&quot;&gt;&lt;a href=&quot;#1-阻塞队列（Blocking-Queues）&quot; class=&quot;headerlink&quot; title=&quot;1. 阻塞队列（Blocking Queues）&quot;&gt;&lt;/a&gt;1. 阻塞队列（Blocking
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 20. Semaphores</title>
    <link href="http://yoursite.com/2020/09/04/Semaphores/"/>
    <id>http://yoursite.com/2020/09/04/Semaphores/</id>
    <published>2020-09-04T07:32:18.000Z</published>
    <updated>2020-09-04T08:13:18.290Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphores（信号）是一个线程同步结构，它既可以用于线程通信以避免丢失信号，也可以像锁一样使关键代码（介于lock和unlock之间的代码）在多个线程之间同步运行。</p><p>Java 5 提供了 java.util.concurrent.Semaphore 类，所以你可以不需要自己实现 Semaphore，但我们需要知道它的原理并使用它。</p><h3 id="1-简单的-Semaphore"><a href="#1-简单的-Semaphore" class="headerlink" title="1. 简单的 Semaphore"></a>1. 简单的 Semaphore</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-04 15:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Semaphore &#123;</span><br><span class="line"></span><br><span class="line">    private boolean signal &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void take() &#123;</span><br><span class="line">        this.signal &#x3D; true;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void release() throws InterruptedException &#123;</span><br><span class="line">        while (this.signal) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.signal &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take() 方法发送一个信号，release() 方法等待信号。</p><p><strong>使用 Semaphore 可以避免丢失信号。</strong> 我们可以使用 take() 方法代替 notify()，使用 release() 方法代替 wait()。如果 take() 方法的调用发生在 release() 方法之前，信号标志 signal = true 被保存下来，等到release() 方法被调用时便不满足自旋条件，不进入wait() 方法，因此而避免了信号丢失的情况发生。</p><hr><h3 id="2-使用-Semaphore"><a href="#2-使用-Semaphore" class="headerlink" title="2. 使用 Semaphore"></a>2. 使用 Semaphore</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-04 15:50</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送信号的线程</span><br><span class="line">        Thread sendingThread &#x3D; new Thread(semaphore::take, &quot;SendingThread&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;接收信号的线程</span><br><span class="line">        Thread receivingThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;ReceivingThread&quot;);</span><br><span class="line"></span><br><span class="line">        sendingThread.start();</span><br><span class="line">        receivingThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-Semaphore-计数"><a href="#3-Semaphore-计数" class="headerlink" title="3. Semaphore 计数"></a>3. Semaphore 计数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-04 15:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Semaphore &#123;</span><br><span class="line"></span><br><span class="line">    private int signal &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void take() &#123;</span><br><span class="line">        this.signal++;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void release() throws InterruptedException &#123;</span><br><span class="line">        while (this.signal !&#x3D; 0) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.signal--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-有限-Semaphore"><a href="#4-有限-Semaphore" class="headerlink" title="4. 有限 Semaphore"></a>4. 有限 Semaphore</h3><p>Semaphore 计数没有设置信号上限，我们可以给Semaphore设置上线。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-04 16:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BoundedSemaphore &#123;</span><br><span class="line"></span><br><span class="line">    private int signal &#x3D; 0;</span><br><span class="line">    private int bound &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造函数注入 Semaphore 上限</span><br><span class="line">     *</span><br><span class="line">     * @param bound     界限（signal的最大值）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public BoundedSemaphore(int bound) &#123;</span><br><span class="line">        this.bound &#x3D; bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void take() throws InterruptedException &#123;</span><br><span class="line">        while (this.signal &#x3D;&#x3D; this.bound) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.signal++;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void release() throws InterruptedException &#123;</span><br><span class="line">        while (this.signal &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.signal--;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发送的信号已经达到上限，那么发送信号的线程会进入等待，直到接收信号的线程消耗了一个信号，等待中的发送信号线程才可能被唤醒。</p><hr><h3 id="5-Semaphore-当成Lock使用"><a href="#5-Semaphore-当成Lock使用" class="headerlink" title="5. Semaphore 当成Lock使用"></a>5. Semaphore 当成Lock使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore.take();</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;同步代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Semaphores（信号）是一个线程同步结构，它既可以用于线程通信以避免丢失信号，也可以像锁一样使关键代码（介于lock和unlock之间的代码）在多个线程之间同步运行。&lt;/p&gt;
&lt;p&gt;Java 5 提供了 java.util.concurrent.Semaphore 类
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 19. Read/Write Lock</title>
    <link href="http://yoursite.com/2020/09/03/ReadWriteLock-In-Java/"/>
    <id>http://yoursite.com/2020/09/03/ReadWriteLock-In-Java/</id>
    <published>2020-09-03T03:17:54.000Z</published>
    <updated>2020-09-04T07:01:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>读写锁比其他同步锁要更加复杂一些。多个线程读相同的共享资源不会引发线程安全问题，所以允许共享资源被多个线程同时访问。但是如果有一个线程在写某个资源，需要保证没有线程在读取这个共享资源的数据。为了提高系统的性能，我们可以使用读写锁，在读取资源的时候允许多个线程访问共享资源，在写资源的时候保证多个线程是同步访问共享资源。</p><p>Java 5 的 java.util.concurrent 提供了读写锁，我们可以使用它，也需要了解它的一些原理。</p><hr><h3 id="1-Java-实现-Read-Write-Lock"><a href="#1-Java-实现-Read-Write-Lock" class="headerlink" title="1. Java 实现 Read/Write Lock"></a>1. Java 实现 Read/Write Lock</h3><p>首先我们总结下读写访问共享数据的条件：</p><blockquote><ul><li>Read  : 没有线程在写共享资源的数据，也没有线程在请求访问写共享资源的数据。</li><li>Write : 没有线程在读或者写共享资源。</li></ul></blockquote><p><strong>一个线程需要读共享资源，只要保证没有线程在写共享资源的数据，也没有线程在请求写共享资源的数据。</strong> 通过优先写共享资源数据的请求我们可以得到写的请求比读的请求更重要。此外，如果读经常发生，并且我们没有优先写操作，饥饿（饥饿是由于线程间不公平竞争共享资源产生某些线程被无限期阻塞的现象）经常发生。如果一个读的线程不断的获取到访问资源的锁，那么写的线程将无限期的等待锁资源被释放，产生饥饿。因此一个线程需要读共享资源，需要保证没有线程在写共享资源，并且没有线程在请求写共享资源。</p><p><strong>一个线程需要写共享资源，只要保证没有线程在读或写共享资源。</strong> </p><p>记住这些简单的规则，我们来实现一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ReadWriteLock &#123;</span><br><span class="line"></span><br><span class="line">    private int readers &#x3D; 0;</span><br><span class="line">    private int writes &#x3D; 0;</span><br><span class="line">    private int requestWrites &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockRead() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;读需要保证没有线程在写共享资源并且没有线程在请求写共享资源</span><br><span class="line">        while (writes &gt; 0 || requestWrites &gt; 0) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读资源线程记录数自增</span><br><span class="line">        readers++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockRead() &#123;</span><br><span class="line">        readers--;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockWrite() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;自增请求写资源的线程记录数</span><br><span class="line">        requestWrites++;</span><br><span class="line">        &#x2F;&#x2F;写需要保证没有线程在读或写资源</span><br><span class="line">        while (readers &gt; 0 || writes &gt; 0) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;请求写资源的线程获取到了锁，请求数自减</span><br><span class="line">        requestWrites--;</span><br><span class="line">        &#x2F;&#x2F;自增正在写资源的线程记录数</span><br><span class="line">        writes++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockWrite() &#123;</span><br><span class="line">        writes--;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是我们自定义的一个读写锁，通过synchronized实现，如果你需要实现线程间公平的写资源，可以使用JUC提供的ReadWriteLock，JUC的内容我们将在JUC专题总结。同一时间允许多个线程读共享资源，但是在调用lockRead()方法和unlockRead()方法时使得读线程同步。同一时间只允许一个线程写共享资源，同样在调用lockWrite()方法和unlockWrite()方法时会使得写线程同步。</p><p>这里再次强调下我们的规则：</p><blockquote><ul><li><strong>一个线程需要读共享资源，只要保证没有线程在写共享资源的数据，也没有线程在请求写共享资源的数据。</strong></li><li><strong>一个线程需要写共享资源，只要保证没有线程在读或写共享资源。</strong> </li></ul></blockquote><hr><h3 id="2-可重入-Read-Write-Lock"><a href="#2-可重入-Read-Write-Lock" class="headerlink" title="2. 可重入 Read / Write Lock"></a>2. 可重入 Read / Write Lock</h3><p>上面示例中的ReadWriteLock不是可重入锁。使得ReadWriteLock可重入需要做一些改变。</p><p>我们可以先列出锁重入的情况，如下所示：</p><blockquote><ul><li>读 -&gt; 读</li><li>读 -&gt; 写</li><li>写 -&gt; 读</li><li>写 -&gt; 写</li></ul></blockquote><p>下面我们按照上面列出的情况，逐一分析，这里做一个简化，因为“读 -&gt; 读”、“写 -&gt; 写”的情况比“读 -&gt; 写”、“写 -&gt; 读”简单，所以我们按照“读 -&gt; 读”、“写 -&gt; 写”、“读 -&gt; 写”、“写 -&gt; 读”的顺序来分析，最后我们将实现一个覆盖所有场景的可重入读写锁。</p><h5 id="2-1-读可重入（读-gt-读）"><a href="#2-1-读可重入（读-gt-读）" class="headerlink" title="2.1 读可重入（读 -&gt; 读）"></a>2.1 读可重入（读 -&gt; 读）</h5><p>首先我们总结下读可重入的规则：<strong>如果一个线程要实现读可重入，那么需要保证没有线程正在写共享资源获取请求写共享资源，或者它已经拥有读共享资源的锁。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class ReadWriteLock &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, Integer&gt; readerMap &#x3D; new HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    private int writes &#x3D; 0;</span><br><span class="line">    private int requestWrites &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockRead() throws InterruptedException &#123;</span><br><span class="line">        Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">        &#x2F;&#x2F;自旋</span><br><span class="line">        while (!canGrantReadAccess(currentThread)) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读资源线程记录数自增</span><br><span class="line">        if (!readerMap.containsKey(currentThread)) &#123;</span><br><span class="line">            readerMap.put(currentThread, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        readerMap.put(currentThread, readerMap.get(currentThread) + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否可以获取读访问</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;读需要保证没有线程在写共享资源并且没有线程在请求写共享资源，或者当前线程已经具有读的锁&lt;&#x2F;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param thread        线程</span><br><span class="line">     * @return boolean      结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean canGrantReadAccess(Thread thread) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前线程已经具有读的锁，就排除了有线程在写的可能性</span><br><span class="line">        if (readerMap.containsKey(thread) &amp;&amp; readerMap.get(thread) &gt; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (writes &gt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return requestWrites &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockRead() &#123;</span><br><span class="line">        Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">        readerMap.put(currentThread, readerMap.get(currentThread) - 1);</span><br><span class="line">        if (readerMap.get(currentThread) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;清空引用</span><br><span class="line">            readerMap.remove(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockWrite() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;自增请求写资源的线程记录数</span><br><span class="line">        requestWrites++;</span><br><span class="line">        &#x2F;&#x2F;自旋</span><br><span class="line">        while (!canGrateWriteAccess()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;请求写资源的线程获取到了锁，请求数自减</span><br><span class="line">        requestWrites--;</span><br><span class="line">        &#x2F;&#x2F;自增正在写资源的线程记录数</span><br><span class="line">        writes++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否可以获取写访问</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;写需要保证没有线程在读或写资源&lt;p&#x2F;&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return          结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean canGrateWriteAccess() &#123;</span><br><span class="line">        return readerMap.values().stream().mapToInt(i -&gt; i).sum() &gt; 0 || writes &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockWrite() &#123;</span><br><span class="line">        writes--;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你充分的了解了读重入锁的规则，你也可以轻易的写出类似的代码。所以：重点是规则。</p><h5 id="2-2-写可重入（写-gt-写）"><a href="#2-2-写可重入（写-gt-写）" class="headerlink" title="2.2 写可重入（写 -&gt; 写）"></a>2.2 写可重入（写 -&gt; 写）</h5><p>写可重入的规则：<strong>当前线程拥有写资源的锁，不需要再次获取锁可再次进入同步代码块。</strong> 让我们在上面示例的基础上做一些修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class ReadWriteLock &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, Integer&gt; readerMap &#x3D; new HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    private int writes &#x3D; 0;</span><br><span class="line">    private int requestWrites &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 正在写的线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Thread writingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...省略读的 lockRead() 和 unlockRead() 方法</span><br><span class="line"></span><br><span class="line">    public synchronized void lockWrite() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;自增请求写资源的线程记录数</span><br><span class="line">        requestWrites++;</span><br><span class="line">        &#x2F;&#x2F;自旋</span><br><span class="line">        while (!canGrateWriteAccess()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;请求写资源的线程获取到了锁，请求数自减</span><br><span class="line">        requestWrites--;</span><br><span class="line">        &#x2F;&#x2F;自增正在写资源的线程记录数</span><br><span class="line">        writes++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否可以获取写访问</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;写需要保证没有线程在读或写资源&lt;p&#x2F;&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return          结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean canGrateWriteAccess() &#123;</span><br><span class="line">        return writingThread &#x3D;&#x3D; Thread.currentThread()</span><br><span class="line">                || readerMap.values().stream().mapToInt(i -&gt; i).sum() &gt; 0</span><br><span class="line">                || writes &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockWrite() &#123;</span><br><span class="line">        writes--;</span><br><span class="line">        &#x2F;&#x2F;没有写的线程，清空writingThread</span><br><span class="line">        if (writes &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            writingThread &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只增加了一个writingThread变量记录当前写的线程，并修改了lockWrite()方法的自旋条件canGrateWriteAccess()方法和unlockWrite()方法。</p><h5 id="2-3-读-写可重入（读-gt-写）"><a href="#2-3-读-写可重入（读-gt-写）" class="headerlink" title="2.3 读-写可重入（读 -&gt; 写）"></a>2.3 读-写可重入（读 -&gt; 写）</h5><p>当一个线程拥有读共享资源的锁时，获取写的锁需要满足以下条件：没有其他线程正在读取数据，并且没有任何线程在写共享资源数据或者请求写共享资源数据。</p><p>因此，我们只需要改动canGrateWriteAccess()方法的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean canGrateWriteAccess() &#123;</span><br><span class="line">    return  writingThread &#x3D;&#x3D; Thread.currentThread()</span><br><span class="line">            || writes &gt; 0</span><br><span class="line">            || readerMap.entrySet().stream().filter(thread -&gt; thread !&#x3D; Thread.currentThread())</span><br><span class="line">                .map(Map.Entry::getValue)</span><br><span class="line">                .mapToInt(i -&gt; i).sum() &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-写-读可重入（写-gt-读）"><a href="#2-4-写-读可重入（写-gt-读）" class="headerlink" title="2.4 写-读可重入（写 -&gt; 读）"></a>2.4 写-读可重入（写 -&gt; 读）</h5><p>当一个线程拥有写共享资源的锁时，需要确保没有线程在读取或写共享资源，因此它可以直接读共享资源的数据。</p><p>因此，我们只要改动canGrantReadAccess()方法的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean canGrantReadAccess(Thread thread) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程已经获取写资源的锁，则不需要再次获取锁</span><br><span class="line">    if (thread &#x3D;&#x3D; writingThread) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程已经具有读的锁，就排除了有线程在写的可能性</span><br><span class="line">    if (readerMap.containsKey(thread) &amp;&amp; readerMap.get(thread) &gt; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (writes &gt; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return requestWrites &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-全功能读写可重入锁"><a href="#2-5-全功能读写可重入锁" class="headerlink" title="2.5 全功能读写可重入锁"></a>2.5 全功能读写可重入锁</h5><p>经过前面四小结的完善，ReadWriteLock就具备了读-读、读-写、写-读、写-写各个功能的锁重入。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class ReadWriteLock &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, Integer&gt; readerMap &#x3D; new HashMap&lt;Thread, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    private int writes &#x3D; 0;</span><br><span class="line">    private int requestWrites &#x3D; 0;</span><br><span class="line">    private Thread writingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockRead() throws InterruptedException &#123;</span><br><span class="line">        Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">        &#x2F;&#x2F;自旋</span><br><span class="line">        while (!canGrantReadAccess(currentThread)) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读资源线程记录数自增</span><br><span class="line">        if (!readerMap.containsKey(currentThread)) &#123;</span><br><span class="line">            readerMap.put(currentThread, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        readerMap.put(currentThread, readerMap.get(currentThread) + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否可以获取读访问</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;读需要保证没有线程在写共享资源并且没有线程在请求写共享资源，或者当前线程已经具有读的锁&lt;&#x2F;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param thread        线程</span><br><span class="line">     * @return boolean      结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean canGrantReadAccess(Thread thread) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前线程已经获取写资源的锁，则不需要再次获取锁</span><br><span class="line">        if (thread &#x3D;&#x3D; writingThread) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果当前线程已经具有读的锁，就排除了有线程在写的可能性</span><br><span class="line">        if (readerMap.containsKey(thread) &amp;&amp; readerMap.get(thread) &gt; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (writes &gt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return requestWrites &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockRead() &#123;</span><br><span class="line">        Thread currentThread &#x3D; Thread.currentThread();</span><br><span class="line">        readerMap.put(currentThread, readerMap.get(currentThread) - 1);</span><br><span class="line">        if (readerMap.get(currentThread) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;清空引用</span><br><span class="line">            readerMap.remove(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void lockWrite() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;自增请求写资源的线程记录数</span><br><span class="line">        requestWrites++;</span><br><span class="line">        &#x2F;&#x2F;自旋</span><br><span class="line">        while (!canGrateWriteAccess()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;请求写资源的线程获取到了锁，请求数自减</span><br><span class="line">        requestWrites--;</span><br><span class="line">        &#x2F;&#x2F;自增正在写资源的线程记录数</span><br><span class="line">        writes++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否可以获取写访问</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;写需要保证没有线程在读或写资源&lt;p&#x2F;&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return          结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean canGrateWriteAccess() &#123;</span><br><span class="line">        return  writingThread &#x3D;&#x3D; Thread.currentThread()</span><br><span class="line">                || writes &gt; 0</span><br><span class="line">                || readerMap.entrySet().stream().filter(thread -&gt; thread !&#x3D; Thread.currentThread())</span><br><span class="line">                    .map(Map.Entry::getValue)</span><br><span class="line">                    .mapToInt(i -&gt; i).sum() &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlockWrite() &#123;</span><br><span class="line">        writes--;</span><br><span class="line">        &#x2F;&#x2F;没有写的线程，清空writingThread</span><br><span class="line">        if (writes &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            writingThread &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有等待的线程</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-在finally代码块中调用unlock-方法"><a href="#2-6-在finally代码块中调用unlock-方法" class="headerlink" title="2.6 在finally代码块中调用unlock()方法"></a>2.6 在finally代码块中调用unlock()方法</h5><p>为了产生死锁，请在finally代码块中调用unlock()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lockWrite();</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;do critical section code, which may throw exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlockWrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读写锁比其他同步锁要更加复杂一些。多个线程读相同的共享资源不会引发线程安全问题，所以允许共享资源被多个线程同时访问。但是如果有一个线程在写某个资源，需要保证没有线程在读取这个共享资源的数据。为了提高系统的性能，我们可以使用读写锁，在读取资源的时候允许多个线程访问共享资源，在
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 18. Lock</title>
    <link href="http://yoursite.com/2020/09/02/Lock-In-Java/"/>
    <id>http://yoursite.com/2020/09/02/Lock-In-Java/</id>
    <published>2020-09-02T08:15:37.000Z</published>
    <updated>2020-09-04T07:03:43.575Z</updated>
    
    <content type="html"><![CDATA[<p>Lock 是除synchronized代码块的另外一种线程同步机制，Lock可以具有比synchronized代码块更复杂的作用。Lock可以使用synchronized关键字，所以它并不能让我们摆脱synchronized关键字。</p><p>自JDK 5开始，java.util.concurrent.locks包提供了一些Lock的实现类，比如ReentrantLock、ReadWriteLock、Condition，因此你可能不需要自己自定义Lock，但是你可能需要知道如何使用它们并了解其中的原理。这里我们不详细讲解，更多的细节，后面我将总结JUC工具包的相关知识点。</p><h3 id="1-简单的Lock"><a href="#1-简单的Lock" class="headerlink" title="1. 简单的Lock"></a>1. 简单的Lock</h3><p>先看看synchronized的同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line"></span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public int inc() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            return ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意inc()方法里面的synchronized(this)代码块，这个代码块确保了同一时间只有一个线程能够执行 ++count 指令。下面我们看看使用自定义的Lock代替上面这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Counter&#123;</span><br><span class="line">    </span><br><span class="line">    private Lock lock  &#x3D; new Lock();</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public int inc() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        int newCount &#x3D; ++count;</span><br><span class="line">        lock.unLock();</span><br><span class="line">        return newCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意lock()方法中的while (hasLock)循环，我们称它为“自旋锁”，自旋锁解决了线程通信的虚假唤醒的问题。</p><hr><h3 id="2-锁重入"><a href="#2-锁重入" class="headerlink" title="2. 锁重入"></a>2. 锁重入</h3><p>当某个线程进入同步代码块时，首先会尝试获取同步代码块的对象锁，一个线程可以拥有多个对象锁，由于不同同步代码块可能具有相同的对象锁，当线程拥有某个对象锁时，进入这个对象锁的同步代码块不需要再次获取锁，我们称它为可重入锁。</p><p>synchronized 具有重入锁的机制。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Reentrant &#123;</span><br><span class="line">    </span><br><span class="line">    public synchronized void methodA() &#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void methodB() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意普通方法A和普通方法B都使用了synchronized关键字声明，它的监视器对象是Reentrant的一个实例对象，methodA()中调用了methodB()，当某个线程进入进入methodA()，获取到对应的锁，进入methodB()不需要再次获取锁，可以直接进入methodB()。</p><p>JUC中还提供了一些重入锁，比如ReentrantLock、ReentrantReadWriteLock等等，这里我们不细讲，后面请看JUC博客专题。</p><p>现在我们自定义一个可重入锁。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义可重入锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-03 10:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CustomReentrantLock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line">    private Thread lockedBy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLocked &amp;&amp; lockedBy !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">        lockedBy &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        lockedBy &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，while 循环中不仅要判断hasLocked是否被锁住还要判断当前线程是否是锁被拥有的线程，这就是可重入的锁。</p><hr><h3 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="3. 公平锁"></a>3. 公平锁</h3><p>在上一章 <a href="https://miracle-sungm.github.io/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/" target="_blank" rel="noopener">《饥饿与公平》</a> 中我们讲了不公平锁和公平锁，synchronized是一种不公平的锁。</p><hr><h3 id="4-在finally代码块中调用unLock-方法"><a href="#4-在finally代码块中调用unLock-方法" class="headerlink" title="4. 在finally代码块中调用unLock()方法"></a>4. 在finally代码块中调用unLock()方法</h3><p>当关键代码（介于lock和unLuck之间的代码）可能抛出异常，请在finally代码块中调用unLock()方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lock 是除synchronized代码块的另外一种线程同步机制，Lock可以具有比synchronized代码块更复杂的作用。Lock可以使用synchronized关键字，所以它并不能让我们摆脱synchronized关键字。&lt;/p&gt;
&lt;p&gt;自JDK 5开始，java
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 17. 饥饿与公平</title>
    <link href="http://yoursite.com/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <id>http://yoursite.com/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/</id>
    <published>2020-09-01T06:39:45.000Z</published>
    <updated>2020-09-01T11:50:24.059Z</updated>
    
    <content type="html"><![CDATA[<p>一个线程没有获取到CPU时间片，因为CPU时间片总是被其他线程获取，这种情况我们叫它“饥饿”。线程被“饿死”是因为没有获取CPU时间片执行指令。解决“饥饿”的办法成为“公平” —— 所有的线程公平的获取CPU时间片执行指令。</p><hr><h3 id="1-Java-中常见饥饿的场景"><a href="#1-Java-中常见饥饿的场景" class="headerlink" title="1. Java 中常见饥饿的场景"></a>1. Java 中常见饥饿的场景</h3><blockquote><ul><li>具有高优先性的线程比低优先性的线程更容易获取CPU时间片。</li><li>线程无限期阻塞等待进入synchronized代码块，因为其他线程在不断地被允许访问synchronized代码块。</li><li>线程调用了wait方法，一直未被唤醒，因为总有其他的线程被唤醒（调用notify方法），而不是它。</li></ul></blockquote><h5 id="1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片"><a href="#1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片" class="headerlink" title="1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片"></a>1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片</h5><p>你可以通过setPriority()方法（Thread类的方法，取值范围是[1-10]）设置每个线程的优先级。具有高优先性的线程比低优先性的线程更容易获取CPU时间片，具体怎么执行依赖于我们的操作系统。</p><h5 id="1-2-线程无限期阻塞等待进入synchronized代码块"><a href="#1-2-线程无限期阻塞等待进入synchronized代码块" class="headerlink" title="1.2 线程无限期阻塞等待进入synchronized代码块"></a>1.2 线程无限期阻塞等待进入synchronized代码块</h5><p>Java synchronized 代码块不保证线程按照等待进入synchronized代码块的顺序进入synchronized代码块，首先等待进入synchronized代码块的线程不一定先进入synchronized代码快。这就意味着系统可能存在某些线程无限期的等待进入synchronized代码块的风险，因为其他线程在不断的访问它。</p><h5 id="1-3-线程调用了wait方法，一直未被唤醒"><a href="#1-3-线程调用了wait方法，一直未被唤醒" class="headerlink" title="1.3 线程调用了wait方法，一直未被唤醒"></a>1.3 线程调用了wait方法，一直未被唤醒</h5><p>我们都知道wait()、notify()、notifyAll() 方法用于线程通信。在多个等待线程调用了wait()方法时，某个唤醒线程调用了notify() 方法会唤醒某个等待线程，但它不保证某个线程一定会被唤醒，它唤醒的是等待线程中的任意一个线程。因此当多个线程调用了wait方法，其中某些线程可能一直处于等待状态，因为总有线程被唤醒，而不是它们。</p><hr><h3 id="2-Java-中实现公平"><a href="#2-Java-中实现公平" class="headerlink" title="2. Java 中实现公平"></a>2. Java 中实现公平</h3><p>尽管Java中不可能百分之百实现公平，但我们可以实现我们的同步机制来提高不同线程之间的公平性。</p><p>示例：synchronized 代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">  public synchronized void doSynchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;do a lot of work which takes a long time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个线程调用doSynchronized()方法，只有一个线程能够进入该方法，其他线程会造成阻塞直到进入doSynchronized()方法的线程退出。如果多个线程被阻塞，当某个线程退出synchronized代码块后，不确定下一次进入synchronized代码块的线程是哪个线程。</p><h5 id="2-1-使用Lock代替synchronized代码块"><a href="#2-1-使用Lock代替synchronized代码块" class="headerlink" title="2.1 使用Lock代替synchronized代码块"></a>2.1 使用Lock代替synchronized代码块</h5><p>为了提高等待线程进入同步代码块的公平性，通过自定义的Lock代替synchronized代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">    public synchronized void doSynchronized() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line"></span><br><span class="line">        lock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意doSynchronized()方法没有使用synchronized关键字声明，取而代之的是Lock类的lock()和unLock()方法，Lock类的实现可以是下面这种方式（也可以使用juc包下的Lock，这里先尝试自己实现Lock）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line">    </span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line">    private Thread lockThread &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">        lockThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        if (lockThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread is not lock thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        lockThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请仔细看Lock类的实现，你会发现当多个线程访问lock()方法时会造成阻塞，因为它使用了synchronized关键字。如果锁已经被锁定，其他线程调用lock方法进入无效状态（调用了wait方法），锁的每次释放，都将唤醒一个wait状态的线程(unLock方法里面调用了notify方法)。</p><p>之前我们提到过，当多个线程同时调用synchronized代码块会造成阻塞，synchronized关键字不会确保线程按顺序进入synchronized代码块。同样，当多个线程调用了wait方法，某个唤醒线程调用notify方法不能唤醒某个指定的等待线程。因此上面的示例是不是一个公平的锁，但是我们可以对它做修改，实现一个公平锁。</p><p><strong>公平锁</strong></p><p>可参考 java.util.concurrent.locks.ReentrantLock 类中的内部类 FairSync 同步锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个线程没有获取到CPU时间片，因为CPU时间片总是被其他线程获取，这种情况我们叫它“饥饿”。线程被“饿死”是因为没有获取CPU时间片执行指令。解决“饥饿”的办法成为“公平” —— 所有的线程公平的获取CPU时间片执行指令。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Java-
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 16. 死锁和预防死锁</title>
    <link href="http://yoursite.com/2020/08/27/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2020/08/27/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-27T12:02:54.000Z</published>
    <updated>2020-08-28T08:36:38.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程死锁"><a href="#1-线程死锁" class="headerlink" title="1. 线程死锁"></a>1. 线程死锁</h3><p>死锁：两个或多个线程因为竞争资源而造成的一种僵局。</p><p>示例：线程A拥有锁a，线程B拥有锁b，线程A尝试获取锁b，线程B尝试获取锁a，因此产生死锁。线程A将永远无法获取锁b，同样线程B也无法获取锁a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for a</span><br></pre></td></tr></table></figure><p>说明：线程A和线程B必须分别拥有锁a、锁b，同时等待彼此释放锁才会造成死锁的发生，若线程A等待获取锁B时线程B释放了锁B，那么不会造成死锁。</p><p>更复杂的死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for c</span><br><span class="line">Thread C    locks c, wait for d</span><br><span class="line">Thread D    locks d, wait for e</span><br></pre></td></tr></table></figure><p>线程A等待线程B释放锁，线程B等待线程C释放锁，线程C等待线程D释放锁，线程D等待线程A释放锁，造成更加复杂的死锁。</p><hr><h3 id="2-数据库死锁"><a href="#2-数据库死锁" class="headerlink" title="2. 数据库死锁"></a>2. 数据库死锁</h3><p>一个更加复杂的死锁，是数据库的事务。一个数据库事务可能由很多个 update 语句组成。当一条记录在某个事务中被更新时，其他事务更新这条记录需要等待第一个事务提交，同一个事务中的每个 update 语句可能会锁住数据库中的一些数据记录。</p><p>当多个事务同时需要更新一些记录，就可能产生数据库死锁。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction A   第一个update请求： 锁住记录1</span><br><span class="line">Transaction B   第一个update请求： 锁住记录2</span><br><span class="line">Transaction A   第二个update请求： 尝试修改并锁住记录2</span><br><span class="line">Transaction B   第二个update请求： 尝试修改并锁住记录1</span><br></pre></td></tr></table></figure><hr><h3 id="3-预防死锁"><a href="#3-预防死锁" class="headerlink" title="3. 预防死锁"></a>3. 预防死锁</h3><p>一些防止死锁的方法：</p><blockquote><ul><li>锁排序</li><li>锁超时</li><li>死锁检测</li></ul></blockquote><h5 id="3-1-锁排序"><a href="#3-1-锁排序" class="headerlink" title="3.1 锁排序"></a>3.1 锁排序</h5><p>当多个线程以不同的顺序竞争一些锁资源时，可能产生死锁。</p><p>如果你能确保所有的线程按照一定的顺序获取锁资源，就不会产生死锁。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread A:</span><br><span class="line">    lock a</span><br><span class="line">    lock b</span><br><span class="line"></span><br><span class="line">Thread B:</span><br><span class="line">    wait for a</span><br><span class="line">    lock c (when a lock)</span><br><span class="line"></span><br><span class="line">Thread C:</span><br><span class="line">    wait for a:</span><br><span class="line">    wait for b:</span><br><span class="line">    wait for c:</span><br></pre></td></tr></table></figure><p>示例中的线程C，它必须按照 a -&gt; b -&gt; c 的顺序获取对应的锁，在未获取顺序排在前面的锁之前线程C无法获取后的锁。</p><p>示例中：一旦线程A获得了锁a，线程B和线程C必须等待线程A释放锁a之后才竞争获取锁a，之后它们必须按顺序获取锁b或锁c.</p><p><strong>锁排序是一种非常简单有效的预防死锁机制。然而，你需要已知所有的锁，然后给它们设定顺序。我们并非总能已知所有的锁。</strong></p><h5 id="3-2-锁超时"><a href="#3-2-锁超时" class="headerlink" title="3.2 锁超时"></a>3.2 锁超时</h5><p>另外一种预防死锁的机制是：给线程在尝试获取锁的时候设置一个超时时间，如果指定时间内未获取锁则放弃。如果一个线程在给定时间范围内未获取到所有有需要的锁，它将会阻塞并释放自身拥有的所有锁资源，等待一个随机的时间之后重新进入。这个随机的等待时间内，其他的线程可以获取锁资源或释放一些锁资源，改变锁资源的状态，这样使得应用程序避免死锁的发生。</p><p>示例：假设有2个线程分别是线程1，线程2按不同的顺序获取锁A，锁B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程1获取锁资源A</span><br><span class="line">线程2获取锁资源B</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B但是锁B被线程2获取了</span><br><span class="line">线程2尝试获取锁资源A但是锁A被线程1获取了</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B 超时</span><br><span class="line">线程1阻塞并释放锁资源A</span><br><span class="line">线程1等待一个随机的时间（比如198毫秒）之后重新进入</span><br><span class="line"></span><br><span class="line">线程2尝试获取锁资源A 超时</span><br><span class="line">线程2阻塞并释放锁资源B</span><br><span class="line">线程2等待一个随机的时间（比如221毫秒）之后重新进入</span><br></pre></td></tr></table></figure><p>注意的是：线程尝试获取锁超时不一定意味着发生了死锁。因为存在其他的因素，比如持有锁的线程在设定的时间内未执行完任务，持有锁未释放锁导致其他线程尝试获取锁超时。</p><p>另外，当足够多的线程竞争同一个锁资源时，可能导致一些线程尝试获取锁时一次又一次的发生锁超时。</p><p>设置锁超时的预防死锁的机制有一个问题是：当线程进入synchronized代码块时，你无法给线程尝试进入synchronized代码块设置一个超时时间。你必须使用一个自定义的锁类或者使用 Java 5 提供的 JUC 包内的一些工具类。</p><h5 id="3-3-锁排序-vs-锁超时"><a href="#3-3-锁排序-vs-锁超时" class="headerlink" title="3.3 锁排序 vs. 锁超时"></a>3.3 锁排序 vs. 锁超时</h5><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th align="left">类型</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">锁排序</td><td align="left">简单，易实现</td><td align="left">适用于所有已知的锁资源，并设定锁的顺序</td></tr><tr><td align="left">锁超时</td><td align="left">灵活，不需要已知所有的锁资源</td><td align="left">复杂，线程获取锁资源时需设定超时时间，一般情况下使用juc工具包中的类，无法给synchronized关键字设定超时时间</td></tr></tbody></table><h5 id="3-4-死锁检测"><a href="#3-4-死锁检测" class="headerlink" title="3.4 死锁检测"></a>3.4 死锁检测</h5><p>死锁检测是一种沉重的防止死锁机制。通常在设置锁顺序、设置锁超时是不可行的情况下使用。</p><p>每个线程获取锁时需要在一个数据结构（例如map、graph）中记录线程和锁资源的信息，另外，无论何时线程请求锁也需要记录到一个数据结构中，后面通过检测这个数据结构来预防死锁的发生。</p><p>当一个线程尝试获取锁时被拒绝，这个线程可以通过定义的数据结构来检测系统是否发生了死锁。</p><p>线程A持有锁1，线程B持有锁2，线程C持有锁3，线程D持有锁4，且线程A尝试获取锁2，线程B尝试获取锁3，线程C尝试获取锁4，线程D尝试获取锁1。那么定义的数据结构示例如下：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" alt></div></p><p>当线程A持有锁1，且尝试获取锁2被拒时，那么可以通过定义的数据结构获取到持有锁2的线程B，再获取到线程B尝试获取的锁3，再循环上面的算法得到锁三的持有线程C，获取线程C尝试获取的锁4，再循环得到锁4的持有线程D，得到线程D之后获取到线程D尝试获取的锁1，这时候检测到锁1被自己（线程A）持有，那么就检测出了系统存在死锁。</p><p>简单地说，每当一个线程获取锁被拒绝时，这个线程根据定义的数据结构检测系统是否存在死锁，具体做法是以递归的形式遍历获取失败的锁以及获取失败的锁的所属线程，判断线程获取失败的锁是否与原始线程（获取锁失败并检测死锁的那个线程）持有的锁是否相同，如果原始线程拥有的锁中包含某个线程尝试获取的锁，那么就说明系统存在死锁，否则不存在死锁。</p><p>那么怎么处理死锁呢？</p><ol><li>当某个线程获取某个锁失败时，并检测到死锁，其中一种比较简单的做法是当前检测到死锁的线程释放所有的锁资源，以便其他线程获取到当前线程释放的锁资源，同时当前线程阻塞一个随机的时间段后重新进入，这有点类似于设置锁超时的做法。</li><li>另外一个更好的做法是指定一些线程的优先级，只让少量线程造成阻塞，剩余的线程在没有死锁发生的情况下继续执行任务。</li></ol><h3 id="3-5-预防死锁小结"><a href="#3-5-预防死锁小结" class="headerlink" title="3.5 预防死锁小结"></a>3.5 预防死锁小结</h3><p>通常情况下，设置获取锁的顺序是一种常见的、比较简单的预防死锁的方案，但不适用于锁数量过多和存在未知的锁资源时使用。在通过设置锁顺序方案不可行或难实行的情况下，我们可以使用juc工具包中的一些类来设置获取锁时间的方案，不过这种方案不适用于synchronized关键字。在前两种方案都比较困难实行的情况下，可以使用死锁检测的方案来检测死锁并处理死锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-线程死锁&quot;&gt;&lt;a href=&quot;#1-线程死锁&quot; class=&quot;headerlink&quot; title=&quot;1. 线程死锁&quot;&gt;&lt;/a&gt;1. 线程死锁&lt;/h3&gt;&lt;p&gt;死锁：两个或多个线程因为竞争资源而造成的一种僵局。&lt;/p&gt;
&lt;p&gt;示例：线程A拥有锁a，线程B拥有锁b，
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 15. 线程通信</title>
    <link href="http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-21T11:22:17.000Z</published>
    <updated>2020-09-03T02:32:36.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过共享对象实现线程通信"><a href="#1-通过共享对象实现线程通信" class="headerlink" title="1. 通过共享对象实现线程通信"></a>1. 通过共享对象实现线程通信</h3><p>线程通过在共享对象中发送一个信号实现与其他线程通信。如下图所示，设置一个成员变量 hasProcess，线程A通过setHasProcess同步方法设置hasProcess的值，这样线程B可以读取到成员变量hasProcess的值，实现线程之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MySignal &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasProcess &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void setHasProcess(boolean hasProcess) &#123; this.hasProcess &#x3D; hasProcess; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean getHasProcess() &#123; return this.hasProcess; &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A和线程B必须引用共享对象 MySignal 的实例来实现线程A与线程B之间的线程通信。如果线程A和线程B引用了不同的MySignal实例对象，那么线程A和线程B不会检测到彼此发送的信号，达不到线程通信的目的。</p><hr><h3 id="2-Busy-Wait"><a href="#2-Busy-Wait" class="headerlink" title="2. Busy Wait"></a>2. Busy Wait</h3><p>上例中线程B需要等待信号处理数据，因此它的业务代码很可能一直在等待信号，浪费了很多CPU资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySignal singal &#x3D; ...</span><br><span class="line"></span><br><span class="line">while (!singal.getHasProcess()) &#123;</span><br><span class="line">    &#x2F;&#x2F;do nothing... busy waiting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们不知道线程A什么时候发送信号，因此导致线程B一直等待线程A的信号，没做任何事情，浪费CPU资源。</p><hr><h3 id="3-等待通知机制：wait-、notify-、notifyAll"><a href="#3-等待通知机制：wait-、notify-、notifyAll" class="headerlink" title="3. 等待通知机制：wait()、notify()、notifyAll()"></a>3. 等待通知机制：wait()、notify()、notifyAll()</h3><p>Busy waiting 浪费了CPU资源，即使某些情况下等待的时间非常短暂。因此，让等待信号的线程在接收信号之前处于无效状态，直到接收信号之后（被唤醒）继续执行代码，这是一种非常聪明的做法。</p><p><strong>等待通知机制：</strong>让等待信号的线程在接收信号之前处于无效状态（不占用CPU资源，线程暂停执行），由发出信号的线程唤醒等待信号的线程，等待信号的线程被唤醒后继续执行，这就是等待通知机制。</p><p>Java 有一个等待机制：让等待信号的线程处于无效状态。Java Object 类定义了三个方法分别是wait()、notify()、notifyAll()，通过这三个方法我们可以实现这种机制。</p><p>一个线程调用了某个对象的 wait() 方法之后，这个线程就成为无效状态，直到另外一个线程调用了同一个对象的 notify() 方法或者 notifyAll()方法之后，原来处于无效状态的线程才结束无效状态。</p><p>线程调用某个对象的 wait() 方法或者 notify() 方法必须获取这个对象的锁，也就是说 wait() 方法或者 notify() 方法调用的代码必须包含在 synchronized 代码块中，synchronized 监视器必须是 wait() 或 nofity() 方法所属的那个对象。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;监视器对象</span><br><span class="line">public class MonitorObject &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyWaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    MonitorObject myMonitorObject &#x3D; new MonitorObject();</span><br><span class="line"></span><br><span class="line">    public void doWait() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;wait()方法必须包含在synchronized代码块中，且synchronized监视器是wait()方法所属对象myMonitorObject</span><br><span class="line">                myMonitorObject.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doNotify() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            &#x2F;&#x2F;notify()方法必须包含在synchronized代码块中，且synchronized监视器是notify()方法所属对象myMonitorObject</span><br><span class="line">            myMonitorObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程调用某个对象的notify()方法，会唤醒一个等待状态的线程；通过调用notifyAll()方法，唤醒所有处于等待状态的线程。</p><p>你可以从上例中观察到<strong>wait()方法和notify()方法都在同步代码块中，并且同步代码块的监视器对象与调用wait方法（或notify方法）的对象是同一个对象</strong>。这是强制的，一个线程不能在没有持有某个对象锁的方法上调用wait方法或notify方法，否则程序将抛出 IllegalMonitorStateException (非法监视器状态异常)。</p><p>你可能会想：当等待线程进入synchronized代码块调用wait方法使得线程进入等待状态，并没有退出synchronized代码块，那么等待线程就会阻止唤醒线程进入synchronized代码块调用notify()方法，那么唤醒线程怎么可能能够进入synchronized代码块呢？答案是唤醒线程可以进入synchronized代码块调用notify方法，原因是当一个线程调用了wait方法之后，当前线程会释放基于某个对象的持有锁，这样其他的线程就有机会进入synchronized代码块。</p><p>一旦一个线程被唤醒，它不能立即退出wait()方法，等待线程需要等待唤醒线程退出包含notify()方法的synchronized代码块之后，等待线程需要重新获取对象的持有锁之后退出wait方法，然后继续执行下面的代码。</p><p>使用notifyAll()唤醒多个等待线程，那么多个等待线程也需要等唤醒线程退出synchronized代码块之后，各个等待线程需要重新获取对象的持有锁才能退出wait()方法继续执行程序，由于各个等待线程的synchronized代码块的监视器是同一个对象，因此各个线程之间是同步退出wait()方法。</p><p>小结：</p><ul><li>Java 的等待通知机制是基于某个对象实现的一种等待通知机制。</li><li>Java Object 类定义的 wait()、notify()、notifyAll()用于线程通信，这些方法的调用必须包含在以这些方法的对象为监视器的synchronized代码块中，否则程序将抛出IllegalMonitorStateException异常。</li><li>当一个线程调用wait()方法后，线程会释放基于这个方法的对象的持有锁，并使线程进入无效状态，只有当其他线程调用了同一个对象的notify方法（或notifyAll方法）之后，这个对象才可能被唤醒，等待线程需等唤醒线程退出包含notify方法（或notifyAll方法）的synchronized代码块之后，才能重新获取对象的持有锁并退出wait方法继续执行程序。</li><li>当一个线程调用某个对象的notifyAll方法后，所有基于这个对象的等待中的线程将全部被唤醒，但这些等待中的线程需要等唤醒线程退出包含notifyAll方法的synchronized代码块之后，同步的获取对象的持有锁并退出wait()方法。</li></ul><hr><h3 id="4-丢失信号"><a href="#4-丢失信号" class="headerlink" title="4. 丢失信号"></a>4. 丢失信号</h3><p>当一个线程调用notify方法时没有线程处于等待状态，那么这个唤醒信号就被丢失了。丢失信号可能会导致程序产生一些问题，也可能不会产生一些问题，但我们需要知道这种情况可能发生。在某些情况下，丢失信号可能导致一些等待线程一直处于等待中，从未被唤醒，因为唤醒线程调用notify方法发生在等待线程调用wait方法之前。</p><p>为了避免这个问题，我们可以将信号保存在共享数据对象中，这里就不在举例了。</p><hr><h3 id="5-虚假唤醒"><a href="#5-虚假唤醒" class="headerlink" title="5. 虚假唤醒"></a>5. 虚假唤醒</h3><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 17:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static int number &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new Lock();</span><br><span class="line">        </span><br><span class="line">        Runnable myRunnable &#x3D; () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                number++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        new Thread(myRunnable, &quot;Thread A&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread B&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLocked) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现在我们来分析下上面代码中可能会存在什么问题？</strong></p><p>首先假设线程A调用了lock()方法获取到了锁，然后执行number++操作时，此时线程B进入lock()方法（锁已被线程A获取），因此线程B调用wait()方法进入等待状态，之后线程A调用了unLock()方法释放锁资源并唤醒一个线程，因为这里只有线程B处于wait状态，因此线程B被唤醒，线程B等待重新进入synchronized代码块，若此时线程C优先于线程B进入lock同步方法，锁归线程C所有，当线程C退出lock方法后，线程B进入synchronized退出wait方法，继续执行下面的程序代码，那么此时锁同时被线程B和线程C拥有，出现了不同步的操作，这样容易导致程序出现问题。</p><p><strong>现在我们来解决上面代码存在的问题</strong></p><p>我们只要将lock()方法中的if(hasLocked)判断条件换成while(hasLocked)代码块，就能很好的解决上面这个问题，while(hasLocked)我们称它为“自旋锁”。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">    while (hasLocked) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    hasLocked &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当线程B退出wait()方法后继续判断hasLocked条件是否为真，仅当锁没有被任何线程锁拥有时才真正的唤醒线程，否则线程继续等待。</p><h3 id="当多个线程等待同一个信号"><a href="#当多个线程等待同一个信号" class="headerlink" title="当多个线程等待同一个信号"></a>当多个线程等待同一个信号</h3><p>自旋锁在处理多个线程等待同一个信号时也是一种很好的方案，我们会使用notifyAll()方法唤醒等待的所有线程，同时只有一个线程能够退出wait()方法，当某个线程退出wait()方法后，这个线程会修改hasLocked的值，当其他线程退出wait方法时会自旋判断hasLocked，若锁被其他线程拥有，会继续进入等待状态，从而避免程序产生一些不正常的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-通过共享对象实现线程通信&quot;&gt;&lt;a href=&quot;#1-通过共享对象实现线程通信&quot; class=&quot;headerlink&quot; title=&quot;1. 通过共享对象实现线程通信&quot;&gt;&lt;/a&gt;1. 通过共享对象实现线程通信&lt;/h3&gt;&lt;p&gt;线程通过在共享对象中发送一个信号实现与其
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 14. ThreadLocal</title>
    <link href="http://yoursite.com/2020/08/21/ThreadLocal/"/>
    <id>http://yoursite.com/2020/08/21/ThreadLocal/</id>
    <published>2020-08-21T02:45:56.000Z</published>
    <updated>2020-08-21T11:20:57.464Z</updated>
    
    <content type="html"><![CDATA[<p>Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 ThreadLocal 类以一种非常简单的方式确保了线程安全。</p><p>建议: 看这篇博客的同时，阅读一遍 java.lang.ThreadLocal 的源码，相信您从源码中获取的知识点会更多一些。</p><h3 id="1-创建一个线程变量"><a href="#1-创建一个线程变量" class="headerlink" title="1. 创建一个线程变量"></a>1. 创建一个线程变量</h3><p>我们可以通过下面这种方式创建一个ThreadLocal对象，我们还可以给它指定泛型类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这个代码只需要执行一次。然后线程就可以对它设置值（set）或者读取值（get），每个线程只能获取到它们自己设置的值。</p><hr><h3 id="2-设置-ThreadLocal-的值"><a href="#2-设置-ThreadLocal-的值" class="headerlink" title="2. 设置 ThreadLocal 的值"></a>2. 设置 ThreadLocal 的值</h3><p>一旦创建了ThreadLocal对象，就可以设置ThreadLocal的值，我们通过set()方法设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="2-获取-ThreadLocal-的值"><a href="#2-获取-ThreadLocal-的值" class="headerlink" title="2. 获取 ThreadLocal 的值"></a>2. 获取 ThreadLocal 的值</h3><p>通过get()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure><hr><h3 id="3-移除-ThreadLocal-的值"><a href="#3-移除-ThreadLocal-的值" class="headerlink" title="3. 移除 ThreadLocal 的值"></a>3. 移除 ThreadLocal 的值</h3><p>通过remove()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure><hr><h3 id="4-ThreadLocal-泛型"><a href="#4-ThreadLocal-泛型" class="headerlink" title="4. ThreadLocal 泛型"></a>4. ThreadLocal 泛型</h3><p>我们可以给ThreadLocal指定泛型类型，指定泛型类型之后只能设置泛型类型的值，另外，获取ThreadLocal的值时不需要做类型转换。</p><p>正如我们上面提出的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定泛型类型为String</span><br><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置值</span><br><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值</span><br><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 13. volatile关键字</title>
    <link href="http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-19T13:01:24.000Z</published>
    <updated>2020-08-26T02:08:25.023Z</updated>
    
    <content type="html"><![CDATA[<p>volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。</p><p>实际上，自 Java 5 起，volatile 关键字不仅仅保证从主内存中读取数据或者写回数据至主内存中。下面一起来探索下 volatile 关键字的作用吧。</p><h3 id="1-volatile-可见性问题"><a href="#1-volatile-可见性问题" class="headerlink" title="1. volatile 可见性问题"></a>1. volatile 可见性问题</h3><p>volatile 关键字保证了当某个线程改变了 volatile 变量的值时对其他线程可见。</p><p>在多线程应用系统中，线程操作 non-volatile 变量时，每个线程会拷贝 non-volatile 变量（拷贝引用）至CPU高速缓存中。如果你的计算机包含多个CPU，每个线程在不同的CPU上运行时，这就意味着每个线程拷贝这些变量至不同的CPU的CPU高速缓存中，如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" alt></div></p><p>对于 non-volatile 变量，JVM每次读取变量数据时不会保证从主内存中拷贝至CPU高速缓存中，或者每次写数据时不会保证把CPU高速缓存的数据写回至主内存中。</p><p>下面我们来看个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，有2个线程，第一个线程对 count 的值做修改，第二个的线程能读取到 count 被修改后的值吗？？？</p><p>由于这个 count 变量没有被 volatile 关键字声明，当2个CPU运行的2个线程分别读取 count 的值时，会从主内存中将count的值拷贝至各自的CPU高速缓存中，其中一个线程修改count的值，由于它没有被volatile声明，因此不会保证被修改后的值写回至主内存中。请看下图：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" alt></div></p><p>由于count变量值被修改后没有写回主内存中，并且线程每次读取count变量值也没有保证从主内存中读取，这个问题被称为数据可见性问题，我们可以通过使用volatile关键字解决数据可见性问题，也可以使用其他方式解决。</p><hr><h3 id="2-volatile-可见性保证"><a href="#2-volatile-可见性保证" class="headerlink" title="2. volatile 可见性保证"></a>2. volatile 可见性保证</h3><p>volatile 关键字解决了数据可见性问题。通过使用 volatile 关键字声明变量是一个volatile变量，保证了每次读取变量数据时从主内存读取，写数据时把数据写回主内存中。</p><p>通过 volatile 声明变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public volatile int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的这种情况，当线程一修改了count的值，线程二没有修改count的值，只读取了count的值，这种情况下，使用volatile关键字声明count变量足够保证数据的线程二读取到的是最新的数据。</p><p><strong>注意：当存在多个线程对同一个共享变量做修改操作时，使用volatile是远远不够的，volatile关键字只能保证数据可见性，并不能保证数据操作是原子性的，我们可以使用synchronized关键字或者Java提供的JUC工具包。</strong></p><h5 id="2-1-所有变量可见性保证"><a href="#2-1-所有变量可见性保证" class="headerlink" title="2.1 所有变量可见性保证"></a>2.1 所有变量可见性保证</h5><p>实际上，volatile 关键字的作用超越了 volatile 变量本身，有更多的作用。包括：</p><blockquote><ul><li>当某个线程写回volatile变量的值至主内存时，这个<strong>线程可见的所有变量的值</strong>都会写回至主内存中</li><li>当某个线程从主内存中读取volatile变量的值时，这个<strong>线程可见的所有变量的值</strong>都会重新从主内存中读取</li></ul></blockquote><p>上面提到的这些内容我们在博客<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">[Java 并发编程] 11. Java Happen Before Guarantee</a>提到过，这里不再举例证明。</p><hr><h3 id="3-指令重排挑战"><a href="#3-指令重排挑战" class="headerlink" title="3. 指令重排挑战"></a>3. 指令重排挑战</h3><p>JVM和CPU为了提升性能允许指令重排，只要满足语义不变（单线程情况下执行结果不变）即可指令重排。</p><p>请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>指令重排后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line">int b &#x3D; 2;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>然而，当一个变量被volatile修饰时，存在一些指令重排的挑战。请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int years;</span><br><span class="line">    private int months</span><br><span class="line">    private volatile int days;</span><br><span class="line"></span><br><span class="line">    public void update(int years, int months, int days)&#123;</span><br><span class="line">        this.years  &#x3D; years;</span><br><span class="line">        this.months &#x3D; months;</span><br><span class="line">        this.days   &#x3D; days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦执行上面的update()方法，执行到修改days的指令时，years和months修改后的值也会被写回到主内存中。但是如果发生了指令重排，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void update(int years, int months, int days)&#123;</span><br><span class="line">    this.days   &#x3D; days;</span><br><span class="line">    this.years  &#x3D; years;</span><br><span class="line">    this.months &#x3D; months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样执行到days修改的指令时，years和months的值也会被写回到主内存中，但此时years和months的值未被修改（指令重排导致years和months修改的指令在days指令下面），写回数据至主内存的操作发生在years和months修改指令的前面，当执行完years和months的修改指令后，不会同步数据至主内存，因此years和months的新值对其他线程不可见（未使用volatile关键字），这样的指令重排导致程序的语义发生了改变。</p><p>Java 有解决这个问题，让我们看下一章节。</p><h3 id="4-volatile-happens-before-保证"><a href="#4-volatile-happens-before-保证" class="headerlink" title="4. volatile happens-before 保证"></a>4. volatile happens-before 保证</h3><p>为了解决指令重排可能产生的问题，java volatile 关键字除了提供可见性保证之外，还提供提供了happens-before保证，如下：</p><blockquote><ul><li>当其他变量的读写指令原本就在volatile写指令前面时，那么其他变量的读写指令不会被重排序到 volatile 写指令后面。（请注意：这里只提出了原本在volatile变量写指令前面的指令，不会被重排序到volatile指令后面，原本在volatile写指令前面的指令之间可以发生指令重排。）</li><li>当其他变量的读写指令原本就在volatile读指令后面时，那么其他变量的读写指令不会被重排序到 volatile 读指令前面。（同样：原本在 volatile 读指令后面的指令之间可以发生指令重排）</li></ul></blockquote><h3 id="5-volatile-不足"><a href="#5-volatile-不足" class="headerlink" title="5. volatile 不足"></a>5. volatile 不足</h3><p>即使 volatile 关键字保证了线程每次读取 volatile 变量时从主内存中读取数据，每次写数据时把数据写回主内存中，但在一些情况下，声明volatile变量是不够的。</p><p>上面我们提到过当一个线程修改volatile变量时，能保证其他线程可以读取到volatile变量的最新值。</p><p>事实上，在多个线程修改volatile变量的情况下，也能确保最新值被写回到主内存中。但这样可能会存在一些问题，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int totalPrice &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public int addPrice(int price) &#123;</span><br><span class="line">    totalPrice +&#x3D; price;</span><br><span class="line">    return totalPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initTotalPrice() &#123;</span><br><span class="line">    totalPrice &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程一、线程二分别在执行addPrice()方法和initTotalPrice()方法时，线程一执行完totalPrice += price指令后，把totalPrice的最新值刷回到主内存中，若此时线程二正巧执行完initTotalPrice()方法，totalPrice的值被重新刷回0，当线程一再读取totalPrice值并返回，导致最终返回的值是0，这可能不是我们程序最终想要的结果。（备注：当然我们不会去写这种程序代码，这个示例我只用来说明问题，并没有实际测试过这种场景。）</p><p>上例其实就是为了说明一个问题：<strong>volatile 只是保证了数据的可见性，并没有保证原子性，如果要执行原子性操作，使用volatile关键字是远远不够的。这里顺便提一下，synchronized关键字不仅保证了数据可见性，同时也保证了原子性。</strong></p><p>再来看下一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明volatile变量</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自增</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>当2个线程同时对变量 i 做自增操作，当他们同时把 i 的值写回到主内存中时，最终写回的值时1，实际上i做了2次自增。</p><p>因此：在多个线程同时存在修改共享数据的情况时，仅仅使用volatile变量是不够的。请记住：volatile 关键字只保证了数据可见性，并不保证原子性。</p><h3 id="6-什么时候使用-volatile"><a href="#6-什么时候使用-volatile" class="headerlink" title="6. 什么时候使用 volatile ?"></a>6. 什么时候使用 volatile ?</h3><p>正如前面提到的，如果多个线程同时对共享数据进行读写操作，这种情况下使用volatile关键字是不够的。我们需要使用synchronized关键字保证数据读写的可见性和原子性。</p><p>除了使用synchronized关键字之外，我们还可以使用 java.util.concurrent 包提供的各种工具类，比如 AtomicLong 、 AtomicReference 等等。</p><p>当只有一个线程会对共享变量的值进行修改，其他的线程只读取共享变量的值时，我们使用volatile关键字是足够的。</p><p>另外: volatile 关键字工作在32位或者64位的变量上。</p><h3 id="7-volatile-性能考虑"><a href="#7-volatile-性能考虑" class="headerlink" title="7. volatile 性能考虑"></a>7. volatile 性能考虑</h3><p>我们都知道，CPU操作CPU高速缓存的速度远远快于操作主内存的速度。CPU每次操作volatile关键字都会操作主内存会带来额外的性能开销。另外，volatile 关键字防止指令重排是正常性能增强技术。在条件允许的情况下，使用volatile关键字代替synchronized代码块能节省性能开销。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。&lt;/p&gt;
&lt;p&gt;实际上，自 Ja
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 12. synchronized关键字</title>
    <link href="http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-16T06:56:35.000Z</published>
    <updated>2020-08-28T03:30:24.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-synchronized-同步机制"><a href="#1-synchronized-同步机制" class="headerlink" title="1. synchronized 同步机制"></a>1. synchronized 同步机制</h3><p>synchronized 同步机制是 Java 第一个多线程同步访问共享对象（数据）的机制。显然刚开始的时候Java 同步机制不是很好，因此在 jdk 1.5 提出了一些并发工具类帮助开发者实现比synchronized同步机制更好的并发控制。随着 jdk 版本的不断更新发布，synchronized 关键的性能已经做了很多的优化，在多数情况下，使用 synchronized 关键字能够满足并发控制。</p><hr><h3 id="2-synchronized-关键字"><a href="#2-synchronized-关键字" class="headerlink" title="2. synchronized 关键字"></a>2. synchronized 关键字</h3><p>通过 synchronized 关键字标记 synchronized 代码块。Java 中 synchronized 代码块是在某个对象上做同步（这个对象我们称为锁），所有作用在某个对象的同步代码块同时只能被一个执行，其他线程尝试执行同步代码块时必须等待正在执行同步代码块的线程退出之后才能进入同步代码块。</p><p>synchronized 关键字三种用法：</p><ul><li>作用于实例方法（普通方法）</li><li>作用于静态方法</li><li>作用于代码块</li></ul><p>建议：在需要使用synchronized 关键字时，首先考虑作用于代码块，其次是普通方法，最后是静态方法（代码块 &gt; 普通方法 &gt; 静态方法）。</p><h5 id="2-1-作用于普通方法"><a href="#2-1-作用于普通方法" class="headerlink" title="2.1 作用于普通方法"></a>2.1 作用于普通方法</h5><p>通过使用 synchronized 关键字声明一个同步的普通方法。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyCounter &#123;</span><br><span class="line"></span><br><span class="line">  private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public synchronized void add(int value)&#123;</span><br><span class="line">      this.count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用  声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步实例方法：给当前实例对象加锁，当某个线程进入执行synchronized实例方法时需要获取当前实例对象的锁。因此当synchronized作用于普通方法时，每个实例的同步方法只作用于自己的实例对象。</strong></p><p><strong>只有一个线程可以执行实例同步方法。如果存在多个线程，那么只有一个线程能够同时执行实例同步方法，其他线程必须等待正在执行同步方法的线程执行完毕同步方法，获取到实例锁之后才能执行同步方法。</strong></p><h5 id="2-2-作用于静态方法"><a href="#2-2-作用于静态方法" class="headerlink" title="2.2 作用于静态方法"></a>2.2 作用于静态方法</h5><p>通过使用 synchronized 关键字声明一个同步的静态方法，与普通方法不同的是，静态方法需要通过 static 关键字声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">      count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用 synchronized 声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步静态方法：给当前类的 class 对象加锁，当某个线程进入synchronized静态方法时需要获取当前类的class对象的锁。</strong></p><p><strong>因为JVM中每个类只有一个class对象，因此只有一个线程能够同时执行静态同步方法。</strong></p><p>如果一个类声明了多个静态同步方法，只有一个线程可以同时执行这些方法。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">    count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static synchronized void subtract(int value)&#123;</span><br><span class="line">    count -&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于静态同步方法的锁作用于当前类的class对象，所以当多个线程需要执行同一个类中声明的不同的静态同步方法时，同一时间只有一个线程能拿到类的class对象锁，因此只有一个线程能在给定的时间内执行某个静态方法。</p><p>上例中声明了2个静态同步方法，分别是add()方法和subtract()方法，当某个线程执行add()方法时，其他线程只能等待正在执行add()方法执行完毕，并释放类的class对象锁后，才能获取到锁并执行对应的静态同步方法。</p><h5 id="2-3-作用于代码块"><a href="#2-3-作用于代码块" class="headerlink" title="2.3 作用于代码块"></a>2.3 作用于代码块</h5><p>通常情况下，我们不需要同步整个方法，可以在方法内部声明同步代码块，当多个线程执行到同步代码时，使线程的变得同步执行。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (object) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：object 表示接收某个对象作为锁，可以是任意对象，也可以是class对象。</strong> </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void add(int value)&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">       this.count +&#x3D; value;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上例中通过使用synchronized标记这段代码块是同步的，当多个线程需要执行这段代码时，线程会变得同步执行。</p><p>synchronized代码块接收一个对象作为同步锁，只有获取到同步锁才能执行同步代码，这个对象可以是我们自定义的任意对象，包括class对象。通常包括下面三种情况：</p><blockquote><ul><li>this 对象</li><li>class 对象</li><li>其他自定义对象</li></ul></blockquote><h6 id="2-3-1-this对象作为synchronized同步代码块的锁"><a href="#2-3-1-this对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.1 this对象作为synchronized同步代码块的锁"></a>2.3.1 this对象作为synchronized同步代码块的锁</h6><p>当以this对象（表示当前实例对象）作为同步代码块的锁时，只有获取到当前实例对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：如果某个线程正在执行log2()方法中的同步代码块，那么会阻塞其他线程执行log1()方法和log2()方法中的同步代码块（log1方法是普通同步方法，也是以当前实例对象作为锁）。</p><p>以this为对象锁的同步代码块，和普通同步方法的锁对象相同，都是某个实例对象作为同步锁。这种情况下，我们要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-class对象作为synchronized同步代码块的锁"><a href="#2-3-2-class对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 class对象作为synchronized同步代码块的锁"></a>2.3.2 class对象作为synchronized同步代码块的锁</h6><p>当以class对象作为同步代码块的锁时，只有获取到class对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (MyClass.class) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：当某个线程正在执行log1()方法中的同步代码块或者log2()方法时，会阻塞其他线程执行这两个方法中的任意一个方法。</p><p>以class为对象锁的同步代码块，和静态同步方法的锁对象相同，都是某个类的class对象作为同步锁。这种情况下，我们也要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-其他对象作为synchronized同步代码块的锁"><a href="#2-3-2-其他对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 其他对象作为synchronized同步代码块的锁"></a>2.3.2 其他对象作为synchronized同步代码块的锁</h6><p>可以指定任意对象作为同步代码块的对象锁，通常情况下我们使用共享资源对象作为指定的对象锁。备注：如果存在多个共享资源，那么一定要注意锁的顺序，有效防止死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    private String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (lock) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以任意自定义对象作为锁时，似乎要比以this对象和class对象作为synchronized同步锁要灵活的多，不过也要根据场景来使用不同的对象作为同步锁。</p><h6 id="2-3-3-Lambda-表达式中的同步代码块"><a href="#2-3-3-Lambda-表达式中的同步代码块" class="headerlink" title="2.3.3 Lambda 表达式中的同步代码块"></a>2.3.3 Lambda 表达式中的同步代码块</h6><p>我们可以在Lambda表达式中声明synchronized同步代码块，其使用方式跟我们上面提到的知识点是一样的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; s -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F;do something...</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-synchronized-数据可见性"><a href="#3-synchronized-数据可见性" class="headerlink" title="3. synchronized 数据可见性"></a>3. synchronized 数据可见性</h3><p>上一篇博客我们讲<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">《Java Happens Before Guarantee》</a> 时提到过 volatile 关键字和 synchronize 关键字的数据可见性保证。</p><p>这里我们简单回忆一下：没有使用 volatile 关键字或 synchronized 关键字时，当某个线程改变了共享资源的值时对其他线程不可见，原因是不会保证存储于CPU寄存器或者CPU高速缓存的数据重新写回主内存中。</p><p>synchronized 数据可见性：<strong>通过使用synchronized关键字声明同步方法或者同步代码块时，某个线程进入synchronized代码块时，会从主内存中读取最新的数据保存至CPU高速缓存或者CPU寄存器中；当某个线程退出synchronized代码块时，会将CPU寄存器中最新的数据刷回到CPU高速缓存中，再将CPU高速缓存中的最新数据刷新到主内存中，以此保证数据可见性。</strong></p><hr><h3 id="4-synchronized-和指令重排"><a href="#4-synchronized-和指令重排" class="headerlink" title="4. synchronized 和指令重排"></a>4. synchronized 和指令重排</h3><p>上一篇博客中提到过： synchronized 在一定程度上限制了指令重排。</p><p>JVM 和 CPU 为了让程序更快的执行，允许指令重排，通过指令重排让指令并行执行。（前提条件是并行执行的指令没有依赖关系，也就是重排的指令之间不存在依赖关系）</p><p>指令重排在多线程中可能会产生一些问题，比如synchronized同步代码块中写一个变量的代码被重排到synchronized外面。为了防止这种问题产生，synchronized 关键字限制了一些指令重排的发生（与volatile关键字限制指令重排相似）。</p><p>最终的结果是：你可以确定你的代码正确的工作 ———— synchronized限制了指令重排的发生。</p><hr><h3 id="5-什么对象用来做同步对象锁？"><a href="#5-什么对象用来做同步对象锁？" class="headerlink" title="5. 什么对象用来做同步对象锁？"></a>5. 什么对象用来做同步对象锁？</h3><p>正如我们前面多次提到的一样，synchronized 关键字必须作用于某个对象上做同步（通常情况下我们称这个对象为同步对象锁）。</p><p>你可以使用任意对象作为同步对象锁，但是不建议你使用某些String类型的对象和原始基本数据类型的包装类对象作为同步对象锁。因为编译器会优化它们，最终的结果是当你使用他们在不同的同步代码块中作为对象锁时，你以为你使用了不同的对象作为对象锁，实际上只使用了同一个对象作为对象锁。</p><p>出于安全考虑，使用 this 对象或者 new Object() 作为同步对象锁，这种情况下不会被Java编译器或JVM缓存。</p><hr><h3 id="6-synchronized-代码块的限制和替代品"><a href="#6-synchronized-代码块的限制和替代品" class="headerlink" title="6. synchronized 代码块的限制和替代品"></a>6. synchronized 代码块的限制和替代品</h3><p>Java 中的 synchronized代码块存在一些限制，比如同一时间只允许一个线程进入同步代码块。如果多个线程只读取共享数据，不更新共享数据，这是线程安全的，这种情况下我们可以使用 Read / Write Lock 代替 synchronized 代码块。</p><p>你想要多个线程进入同步代码块还是只是一个线程进入同步代码块？我们可以通过使用 Semaphore（计数信号量：限流的作用） 来实现指定数量的线程进入同步代码块(这个点说的同步代码块不是指synchronized代码块)，后面的博客我们来讲解这种实现方式。</p><p>synchronized代码块不会保证等待线程按顺序执行同步代码块。如果我们需要线程按顺序执行同步代码块，可以通过实现 Fairness（公平锁） 来达到这个目的。</p><p>如果只有一个线程修改共享变量，其他的线程只读取共享变量的值，我们可以使用 volatile 关键字，不需要任何同步代码块。</p><hr><h3 id="7-synchronized-性能消耗"><a href="#7-synchronized-性能消耗" class="headerlink" title="7. synchronized 性能消耗"></a>7. synchronized 性能消耗</h3><p>当线程进入和退出 synchronized 代码块时存在一些性能消耗。随着 JDK 版本的发布，性能的消耗变得越来越小，但是使用synchronized代码块还是不可避免地需要付出一些代价。</p><p>如果在循环内不断地进入和退出同步代码块，无疑会让放大性能的损耗。</p><p>尽量避免大的同步代码块，换句话说，只把真正需要的同步操作的代码放进同步代码块，避免其他线程执行不需要同步操作的代码时造成阻塞，同时也能提高执行代码的性能。</p><hr><h3 id="8-synchronized-锁重入"><a href="#8-synchronized-锁重入" class="headerlink" title="8. synchronized 锁重入"></a>8. synchronized 锁重入</h3><p>锁重入：当一个线程进入某个同步代码块时，线程持有同步代码块的同步锁，若同步代码块还调用了具有相同同步锁的同步代码块，线程不需要再次获取锁，可以直接进入相同同步锁的其他同步代码块。</p><p>synchronized 支持锁重入。</p><p>备注：设计多重同步代码块时，需要合理的设计，错误的实现容易导致死锁产生，保持同步代码的锁的顺序一致是一种设计方案。</p><hr><h3 id="9-集群中的-synchronized-代码块"><a href="#9-集群中的-synchronized-代码块" class="headerlink" title="9. 集群中的 synchronized 代码块"></a>9. 集群中的 synchronized 代码块</h3><p>请记住：synchronized 代码块只针对于同一个 JVM 中不同的线程能起到同步作用，如果你拥有相同的 Java 应用程序在多个 JVM 上面运行 ———— 集群，可能导致每个JVM都有一个线程在同时访问共享资源。 </p><p>如果你需要所有的JVM同步访问共享资源，可以使用其他的同步机制，而不是使用 synchronized 代码块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-synchronized-同步机制&quot;&gt;&lt;a href=&quot;#1-synchronized-同步机制&quot; class=&quot;headerlink&quot; title=&quot;1. synchronized 同步机制&quot;&gt;&lt;/a&gt;1. synchronized 同步机制&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 11. Java Happen Before Guarantee</title>
    <link href="http://yoursite.com/2020/08/14/Guarantee/"/>
    <id>http://yoursite.com/2020/08/14/Guarantee/</id>
    <published>2020-08-14T09:11:03.000Z</published>
    <updated>2020-08-26T02:08:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。</p><h3 id="1-指令重排"><a href="#1-指令重排" class="headerlink" title="1. 指令重排"></a>1. 指令重排</h3><p>现代计算机有能力并行执行指令，当一个指令不依赖其他指令时，可能发生指令重排。如下所示：两个指令不相互依赖，计算机可以并行执行这两个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e + f;</span><br></pre></td></tr></table></figure><p>下面这2个指令不会发生指令重排，因为第二个指令依赖第一个指令产生的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a + e;</span><br></pre></td></tr></table></figure><p>指令重排的结果可以让指令在CPU中并行执行，以提高性能。指令重排在JVM和CPU中是被允许的，前提是程序中的语句没有发生改变。指令重排后程序执行的结果必须与没有指令重排时程序执行的结果保持一致。</p><hr><h3 id="2-指令重排在多CPU计算机中的问题"><a href="#2-指令重排在多CPU计算机中的问题" class="headerlink" title="2. 指令重排在多CPU计算机中的问题"></a>2. 指令重排在多CPU计算机中的问题</h3><p>指令重排在多线程、多CPU系统中存在一些挑战。请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int a &#x3D; 0;</span><br><span class="line">private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;有点意思&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>在第一个线程中，a = 1 与 b = 1 两个指令不相互影响，CPU为了提高执行性能，可能并行执行这两个指令，这种情况下， b = 1 指令可能在 a = 1 前面执行，若执行 b = 1 后（假定 a = 1 指令还未执行，此时 a 的值为初始值 0），此时第二个线程正在执行判断条件 a == 0 &amp;&amp; b == 1，那么将会打印数据 ‘有点意思’。为了验证这个问题，我们来循环执行这段代码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-08-13 15:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int a &#x3D; 0;</span><br><span class="line">    private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    System.out.println(&quot;有点意思&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            a &#x3D; 0;</span><br><span class="line">            b &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这段代码有意思，不妨自己试一试。多等待一会，你会发现控制台输出了“有点意思”。</p><hr><h3 id="3-volatile-可见性保证"><a href="#3-volatile-可见性保证" class="headerlink" title="3. volatile 可见性保证"></a>3. volatile 可见性保证</h3><p>Java volatile 关键字提供了读写的可见性保证，当线程读volatile变量时会从主内存中读取数据，当线程修改volatile变量时会将变量的值写回到主内存中。这种同步到主内存的机制保证了变量的值对其他线程可见，这就是volatile可见性保证。</p><h5 id="3-1-volatile-修改数据可见性保证"><a href="#3-1-volatile-修改数据可见性保证" class="headerlink" title="3.1 volatile 修改数据可见性保证"></a>3.1 volatile 修改数据可见性保证</h5><p>当线程修改volatile变量的值时，修改后的值会被同步到主内存中。另外，<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。（请注意这句话，线程所有的变量都会随volatile变量写回到主内存中，不只是volatile变量写回到主内存中）</strong></p><p>请看示例：<br>(1) 首先我们用简单的代码证明使用 volatile 定义的变量的值被某个线程修改后对其他线程可见。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意这里没有使用volatile关键字</span><br><span class="line">    private boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public boolean isKeepRunning() &#123;</span><br><span class="line">        return keepRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;子线程把keepRunning的值改为true</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程中循环尝试获取子线程修改后的keepRunning的值，如果获取到，输出有点意思</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (myRunnable.isKeepRunning()) &#123;</span><br><span class="line">            System.out.println(&quot;有点意思&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你亲手运行了这段代码，你会发现这个程序永远不会输出“有点意思”。现在我们使用volatile定义keepRunning属性，其他代码不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用volatile定义</span><br><span class="line">private volatile boolean keepRunning &#x3D; false;</span><br></pre></td></tr></table></figure><p>使用volatile关键字后，程序循环输出“有点意思”。</p><p><strong>因此我们可以得出结论：volatile 定义的变量的值被某个线程修改后对其他线程可见。</strong></p><p>(2) 现在我们来证明下我们前面说的：<strong>线程里包含的所有变量都会随 volatile 变量写回到主内存中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用了 volatile 关键字的属性</span><br><span class="line">    private volatile boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;未使用 volatile 关键字的属性</span><br><span class="line">    private String strA &#x3D; &quot;A&quot;;</span><br><span class="line">    private String strB &#x3D; &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">        strA &#x3D; &quot;a&quot;;</span><br><span class="line">        strB &#x3D; &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyRunnable&#123;&quot; +</span><br><span class="line">                &quot;keepRunning&#x3D;&quot; + keepRunning +</span><br><span class="line">                &quot;, strA&#x3D;&#39;&quot; + strA + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, strB&#x3D;&#39;&quot; + strB + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(200L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(myRunnable.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序最终输出：MyRunnable{keepRunning=true, strA=’a’, strB=’b’}</p><p>这个结果我们不难看出：子线程修改了keepRunning、strA和strB的值（strA和strB未使用volatile关键字），主线程不仅读取到了keepRunning更新后的值，还读取到了strA和strB更新后的值。所以请记住：<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。</strong></p><h5 id="3-2-volatile-读取数据可见性保证"><a href="#3-2-volatile-读取数据可见性保证" class="headerlink" title="3.2 volatile 读取数据可见性保证"></a>3.2 volatile 读取数据可见性保证</h5><p>当线程读取被 volatile 关键字修饰的变量时，会从主内存中读取。<strong>另外：线程里所有的变量都会随着 volatile 变量读取到CPU缓存或者寄存器中。</strong></p><p>比如下面三个变量，当线程读取strA的值时，会重定向到主内存中读取strA的值，如果strB，strC同样在线程中，也会从主内存中读取strB，strC的值。我们本章3.1节的例子同样能证明此特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valatile String strA &#x3D; &quot;A&quot;;</span><br><span class="line">String strB &#x3D; &quot;B&quot;;</span><br><span class="line">String strC &#x3D; &quot;C&quot;;</span><br></pre></td></tr></table></figure><h5 id="3-3-volatile-happens-before-保证"><a href="#3-3-volatile-happens-before-保证" class="headerlink" title="3.3 volatile happens-before 保证"></a>3.3 volatile happens-before 保证</h5><p>volatile happens-before 保证设置了一些关于volatile变量指令重排的限制（规定）。</p><p><strong>volatile write happens-before guarantee</strong></p><p>volatile write happens-before guarantee: <strong>所有volatile写之前的指令不允许被重排序到volatile指令后面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>示例中 nonVolatileVariableA、nonVolatileVariableB两个变量是没有被volatile修饰的变量，volatileVariableC变量被volatile修饰。volatile write happens-before 保证了前面两个指令不能重排序到第三个指令后面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br></pre></td></tr></table></figure><p>但是示例可能会发生下面这种重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p><strong>volatile read happens-before guarantee</strong></p><p>volatile read happens-before guarantee: <strong>所有volatile读之后的指令不允许被重排序到volatile指令前面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br></pre></td></tr></table></figure><p>volatile read happens-before 保证了最后两个指令不能重排序到第一个指令前面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">volatileVariableC;</span><br></pre></td></tr></table></figure><p>示例可能会发生下面这种重排序的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">nonVolatileVariableA;</span><br></pre></td></tr></table></figure><p><strong>总结volatile happens-before guarantee：所有volatile写之前的指令不允许被重排序到volatile指令后面；所有volatile读之后的指令不允许被重排序到volatile指令前面。（简记：volatile写之前读之后）</strong></p><hr><h3 id="4-synchronized-可见性保证"><a href="#4-synchronized-可见性保证" class="headerlink" title="4. synchronized 可见性保证"></a>4. synchronized 可见性保证</h3><p>synchronized 可见性保证 与 volatile 可见性保证非常相似。</p><h5 id="4-1-synchronized-锁进入可见性保证"><a href="#4-1-synchronized-锁进入可见性保证" class="headerlink" title="4.1 synchronized 锁进入可见性保证"></a>4.1 synchronized 锁进入可见性保证</h5><p>当一个进程进入 synchronized同步代码块（或同步方法），线程内所有可见变量都将从主内存中读取数据。</p><h5 id="4-2-synchronized-锁退出可见性保证"><a href="#4-2-synchronized-锁退出可见性保证" class="headerlink" title="4.2 synchronized 锁退出可见性保证"></a>4.2 synchronized 锁退出可见性保证</h5><p>当一个进程退出 synchronized同步代码块（或同步方法），线程内所有可见变量数据都将写回到主内存中。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line"></span><br><span class="line">    private int numberA &#x3D; 1;</span><br><span class="line">    private int numberB &#x3D; 2;</span><br><span class="line">    private int numberC &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter方法</span><br><span class="line"></span><br><span class="line">    void copyNumber(Demo demo) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">        &#125;</span><br><span class="line">        this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">        this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：当某个线程进入 copyNumber() 方法的 synchronized 代码块时，线程内所有的可见变量都会从主内存中加载数据，也就是说 this 对象的 numberA, numberB也会从主内存中读取数据；退出synchronized 代码块时，线程内所有的可见变量都会写回到主内存中，this 对象的 numberA, numberB修改后的值也会被写回到主内存中。</p><h5 id="4-3-synchronized-happens-before-guarantee"><a href="#4-3-synchronized-happens-before-guarantee" class="headerlink" title="4.3 synchronized happens-before guarantee"></a>4.3 synchronized happens-before guarantee</h5><p>synchronized 提供了两种 happens-before guarantee ：一种与开始进入synchronized 代码块有关；另外一种与退出synchronized 代码块有关。</p><p><strong>synchronized beginning happens-before guarantee :</strong></p><p>我们已经知道，当线程进入 synchronized 代码块时，线程所有可见变量都将从主内存中读取数据。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程进入 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 都将从主内存中读取数据。</p><p>对于上面这个示例，<strong>所有的变量的读取指令都不会重排序到进入 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Number n) &#123;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized end happens-before guarantee :</strong></p><p>我们已经知道，当线程退出 synchronized 代码块时，线程所有可见变量的数据都将写回到主内存中。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程退出 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 的数据都将写回到主内存中。</p><p>对于上面这个示例，<strong>所有的变量的写的指令都不会重排序到退出 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void copyNumber(Number n) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 synchronized happens-before时，我总感觉把它总结的太复杂了，你可以简单的理解为 synchronized 不与其他指令发生指令重排，因为 synchronized happens-before 保证了线程在读取数据和写回数据时都会限制指令重排的发生。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 10. Java内存模型</title>
    <link href="http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-12T08:39:30.000Z</published>
    <updated>2020-08-26T02:08:25.081Z</updated>
    
    <content type="html"><![CDATA[<p>Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。</p><p>如果你想要设计出正确的并发程序，那么理解JMM是非常重要的。Java内存模型会提到一个线程怎样获取被别的线程修改后的共享变量的值；也会提到当有必要的时候，怎样让多个线程顺序的访问共享变量。</p><p>注意：原来的Java内存模型进行过修订，从Java 1.5 到 Java 14+，这个版本的内存模型仍然适用。</p><h3 id="1-Java-Memory-Model"><a href="#1-Java-Memory-Model" class="headerlink" title="1. Java Memory Model"></a>1. Java Memory Model</h3><p>在JVM中，JMM包含两种内存模型：Thread Stacks(线程栈)、Heap(堆内存)。如图所示</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt></div></p><p><strong>内存模型</strong></p><ol><li>每个在JVM中运行的线程都有自己的线程栈。这个线程栈包含线程中调用的方法信息和程序计数器（当前程序所执行的字节码的行号指示器）。</li><li>在开始执行某个方法的时候，会在线程栈中存储方法内所有的local variable(局部变量)，局部变量只对创建它的线程可见，其他线程无法访问。即使两个线程同时执行同一个方法，这两个线程都会创建局部变量保存至属于自己的线程栈中，线程只能访问自己线程栈中的数据。</li><li>所有基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量都保存在线程栈中，并且对其他线程不可见。一个线程可能拷贝一个基本数据类型变量给其他线程，但不会共享原始的局部变量（这里是值传递）。</li><li>堆内存中包含Java应用程序中所有对象的创建，不论哪个线程创建的对象都存储在堆内存中，并且包含基础数据类型的包装类也存储于堆内存中。对象的创建不管是作为局部变量、还是作为对象的成员，都始终保存于堆内存中。</li></ol><p>如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt></div></p><ol><li>一个本地变量可能是一个基本数据类型，这种情况下本地变量将完全保存在线程栈中。</li><li>一个本地变量可能引用一个对象，这种情况下对象的引用保存在线程栈中，对象保存在堆内存中。</li><li>一个对象可能包含一些方法，方法包含一些本地变量。本地变量保存在线程栈中，方法保存随对象保存在堆内存中。</li><li>一个对象的成员变量随对象保存在堆内存中，不论这个成员变量是基本数据类型还是引用其他对象，成员变量都保存在堆内存中。</li><li>静态变量随 class(类) 保存在堆内存中。</li></ol><p>堆内存的对象可以被任何具有该对象引用的线程访问。</p><hr><h3 id="2-计算机硬件内存结构"><a href="#2-计算机硬件内存结构" class="headerlink" title="2. 计算机硬件内存结构"></a>2. 计算机硬件内存结构</h3><p>现代硬件内存结构与Java内存模型有些不同，为了更好的理解Java内存模型，了解硬件内存结果是很重要的。</p><p>通常的硬件内存结构。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt></div></p><p>现代计算机通常拥有2个以上的CPU，有些CPU有多个内核。重点是多CPU计算机可以同时执行多个线程。当你的Java应用程序是多线程应用程序，在你的应用程序中可能同时出现每个CPU都在执行线程的情况。</p><ol><li>每个CPU有一组（注意是一组，多个）CPU寄存器，CPU操作寄存器的速度比操作主内存更快，这也意味着CPU访问寄存器的速度比访问内存更快。</li><li>每个CPU也可能有一个CPU缓存（CPU Cache Memory），事实上，每个CPU可能有一定数量的CPU缓存。CPU访问CPU缓存的速度比访问内存的速度快，通常情况下CPU访问CPU缓存的速度没有访问寄存器的速度快。因此你可以认为CPU访问内存的顺序依次是：寄存器 &gt; CPU缓存 &gt; 主内存。另外，一些CPU可能会有多级CPU缓存（L1,L2,L3等）。</li><li>每个计算机都包含一个主内存，主内存的容量比CPU缓存的容量更大。</li><li>通常情况下，CPU访问内存会读取主内存中的一些数据拷贝至CPU缓存，甚至拷贝至CPU内部的寄存器，然后可以在CPU缓存或者寄存器操作数据。当CPU需要写回数据至主内存中时，它首先会将寄存器中的结果值提交至CPU缓存中，然后再将CPU缓存的值提交至主内存中。</li><li>当CPU需要将CPU缓存的数据提交至主内存中时，CPU缓存的数据将会被写回主内存中。</li></ol><h5 id="2-1-桥接Java内存模型和计算机硬件内存结构"><a href="#2-1-桥接Java内存模型和计算机硬件内存结构" class="headerlink" title="2.1 桥接Java内存模型和计算机硬件内存结构"></a>2.1 桥接Java内存模型和计算机硬件内存结构</h5><p>如您所知，Java内存模型与现代计算机硬件内存结构不同，硬件内存结构没有区分线程栈内存和堆内存。也就是说：线程栈内存和堆内存可以都存在于硬件的主内存、CPU高速缓存、寄存器中。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt></div></p><p>当Java对象和变量可以保存在不同的计算机内存区域中，这就可能会导致一些问题的发生。主要的两个问题是：</p><ol><li>当线程更新共享数据时，共享数据在多个线程中的可见性。</li><li>当多个线程读、写、检查共享数据时，产生竞争条件。</li></ol><p>下面我们来解释这2个问题</p><h5 id="2-2-共享数据的可见性"><a href="#2-2-共享数据的可见性" class="headerlink" title="2.2. 共享数据的可见性"></a>2.2. 共享数据的可见性</h5><p>如果多个线程共享一个对象，并且代码中没有使用 volatile 关键字和 synchronized 同步代码块。当一个线程更新这个共享对象后，修改后的对象的值可能对其他线程不可见。</p><p>想象一下，当一个共享对象保存在主内存中时，一个CPU正在执行某个线程时把主内存中共享对象缓存至CPU高速缓存上，另外一个CPU也把共享对象缓存到CPU高速缓存中，其中一个CPU在CPU高速缓存中更新了共享数据并把共享数据写回到主内存中，此时另外一个CPU的CPU高速缓存还是旧的共享资源数据。</p><p>下图中解释了上面这种场景。下图左边的正在执行某个线程的CPU将 obj.count 加载到CPU高速缓存中，同时将 obj.count 的值改为 2。左边这个线程对 obj.count 的值进行修改后，对执行其他线程的CPU并不可见。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 volatile 关键字。这个关键字用于修饰某个成员变量，当线程要读取这个变量的值时，会从读取主内存中读取变量的值，并且每次修改变量的值时都会重新写回到主内存中。（后面会有文章详细介绍 volatile 关键字）</p><h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>如果多个线程共享一个对象，并且有多个线程修改共享变量，可能产生竞争条件。</p><p>想象一下，如果一个线程A从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，同时线程B也从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，线程A和线程B同时对 obj.count 做自增操作，也就是说 obj.count 同时被自增2次，在每个CPU里面自增一次。如果变量 obj.count 的同步执行递增2次，那么这个变量写回主内存时值应该是 obj.count + 2，然而这2次递增没有同步执行，实际上是在线程A和线程B并行执行，最终线程A和线程B把 obj.count 的值写回数据到主内存后，实际值变成了 obj.count + 1。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 synchronized 锁。synchronized 可以分别用于 代码块、普通方法、静态方法。后面有文章介绍 synchronized，这里不做过多描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。&lt;/p&gt;
&lt;p&gt;如果你想要设计出正确的并发程序，那么理解JMM是非常重
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 9. 线程安全和不变性</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</id>
    <published>2020-08-12T07:50:16.000Z</published>
    <updated>2020-08-26T02:08:24.984Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。</p><p>下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ImmutableValue&#123;</span><br><span class="line"></span><br><span class="line">  private int value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue(int value)&#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 ImmutableValue 提供了一个传入指定 value 的构造函数，一旦对象被创建，该对象没有提供任何修改value值的方法，所以value的值无法被修改。</p><h3 id="特别注意：对象引用不是线程安全的"><a href="#特别注意：对象引用不是线程安全的" class="headerlink" title="特别注意：对象引用不是线程安全的"></a>特别注意：对象引用不是线程安全的</h3><p>需要注意的是，当一个对象不可变时对象本身是线程安全的，但是对象的引用可能不是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  private ImmutableValue currentValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue getImmutableValue()&#123;</span><br><span class="line">    return currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setImmutableValue(ImmutableValue newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void add(int newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; new ImmutableValue(currentValue.getValue() + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator 类引用了一个 ImmutableValue 对象，请注意它可以通过 setImmutableValue() 方法和 add() 方法改变了 ImmutableValue 对象的引用。换句话说，即使 ImmutableValue 对象是不可变的，但它也是非线程安全的。ImmutableValue 类是线程安全的，但对象的引用是非线程安全的。<strong>所以特别注意：对象的引用可能是非线程安全的。</strong> 可以通过给 setImmutableValue() 方法和 add() 方法加锁（使用 synchronized 关键字等）保证线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。&lt;/p&gt;
&lt;p&gt;下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 8. 线程安全和共享资源</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</id>
    <published>2020-08-12T06:56:11.000Z</published>
    <updated>2020-08-26T02:08:25.092Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。</p><h3 id="1-Local-variables-本地变量-局部变量"><a href="#1-Local-variables-本地变量-局部变量" class="headerlink" title="1. Local variables (本地变量/局部变量)"></a>1. Local variables (本地变量/局部变量)</h3><p>局部变量保存在每个线程独有的线程栈中，因此局部变量在线程之间是不共享的。也就是说所有的局部变量都是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void someMethod()&#123;</span><br><span class="line">    long threadSafeInt &#x3D; 0;</span><br><span class="line">    threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-Local-Object-References-本地对象引用-局部对象引用"><a href="#2-Local-Object-References-本地对象引用-局部对象引用" class="headerlink" title="2. Local Object References (本地对象引用/局部对象引用)"></a>2. Local Object References (本地对象引用/局部对象引用)</h3><p>本地对象引用有所不同，引用本身是不共享的，同样也是保存在线程独有的线程栈中，线程之间不共享引用。但是引用的对象不是保存在线程栈中，而是保存在主内存堆中，理论上讲所有的线程都能够访问内存堆中存储的对象（但是要有对象的引用）。</p><p>如果一个对象创建之后没有离开创建它的方法，那么是线程安全的。事实上传递这个对象的引用给其他的方法，只要这个对象的引用没有传递给其他的线程，那么这个对象都不会成为共享对象，始终是线程安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void methodOne()&#123;</span><br><span class="line">  LocalObject localObject &#x3D; new LocalObject();</span><br><span class="line">  methodTwo(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo(LocalObject localObject)&#123;</span><br><span class="line">  localObject.setValue(&quot;value&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中：对象 localObject 在 methodOne() 方法中被创建，然后传递给 methodTwo()，localObject 没有传递给其他线程; 每个线程执行 methodOne() 时会都创建一个新的 LocalObject 对象，且 LocalObject 对象的引用都保存在各自的线程栈中，因此是 methodOne() 线程安全的，尽管 LocalObject 存在多个实例对象，但使用它们是线程安全的。</p><p><strong>但有一种场景例外：</strong> 当某个方法将 localObject 对象的引用作为参数传递给了其他线程，那么可能会造成线程不安全。</p><h3 id="3-Object-Member-Variables-对象成员变量"><a href="#3-Object-Member-Variables-对象成员变量" class="headerlink" title="3. Object Member Variables (对象成员变量)"></a>3. Object Member Variables (对象成员变量)</h3><p>对象成员变量随对象保存在堆内存中。因此当两个线程调用了某个方法，这个方法引用了同一个对象并修改了这个对象的成员变量时，那么这个方法时线程不安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public add(String text)&#123;</span><br><span class="line">        this.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程同时调用同一个 NotThreadSafe 对象的 add() 方法时，会导致竞争条件发生。 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotThreadSafe sharedInstance &#x3D; new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"></span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance &#x3D; instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    this.instance.add(&quot;some text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意有 2 个 MyRunnable 对象共享了 sharedInstance 对象，因此当他们同时调用 sharedInstance.add() 方法时，会发生竞争条件。</p><p>然而，当 2 个线程同时调用不对对象的 add() 方法时，不会产生竞争条件。示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br></pre></td></tr></table></figure><h3 id="4-线程安全规则"><a href="#4-线程安全规则" class="headerlink" title="4. 线程安全规则"></a>4. 线程安全规则</h3><p>当你想确认你的代码访问某些资源的时候是否是线程安全的，你可以使用下面这个规则：</p><blockquote><p><strong>如果资源的创建、使用和销毁都没有离开某个方法，并且没有分享给其他线程，那么使用这个资源是线程安全的。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。&lt;/p&gt;
&lt;h3 id=&quot;1-Local-variables-本地变量-局部变
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 7. 竞争条件和临界区</title>
    <link href="http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</id>
    <published>2020-08-12T06:41:07.000Z</published>
    <updated>2020-08-26T02:08:25.013Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 6. 创建和开始Java线程</title>
    <link href="http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-12T02:32:54.000Z</published>
    <updated>2020-09-03T13:33:26.959Z</updated>
    
    <content type="html"><![CDATA[<p>一个Java线程就像一个可以执行你的Java代码的虚拟CPU。</p><p>当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。</p><p>Java 线程都是对象，就像其他的Java对象一样，线程对象都是 java.lang.Tread 的实例或者其子类的实例。</p><h3 id="1-创建和开始线程"><a href="#1-创建和开始线程" class="headerlink" title="1 创建和开始线程"></a>1 创建和开始线程</h3><p>你可以像这样创建一个线程对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread myThread &#x3D; new Thread();</span><br></pre></td></tr></table></figure><p>你可以像这样开始一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><p>创建线程的几种方式：</p><blockquote><ul><li>继承 java.lang.Thread 类并重写 run() 方法。</li><li>实现 java.lang.Runnable 接口并重写 run() 方法。</li><li>实现 java.util.concurrent.Callable 接口并重写 call() 方法。（备注：这种实现方式后面有 JUC 专题）</li></ul></blockquote><hr><h3 id="2-Thread-子类"><a href="#2-Thread-子类" class="headerlink" title="2 Thread 子类"></a>2 Thread 子类</h3><p>继承 java.lang.Thread 类并重写 run() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">       System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyThread myThread &#x3D; new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start() 方法不会等线程执行完 run()方法，run() 方法将会由其他不同的CPU执行。</p><hr><h3 id="3-实现-Runnable-接口"><a href="#3-实现-Runnable-接口" class="headerlink" title="3 实现 Runnable 接口"></a>3 实现 Runnable 接口</h3><p>第二种创建线程的方式是实现 java.lang.Runnable 接口并重写该接口的 run() 方法。一个 Java 对象实现 Runnable 接口 可以被Java Thread 类执行。</p><p>Runnable 接口由 JDK 提供，仅有一个 run 方法，是一个函数式接口。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 的方式有3种：</p><blockquote><ol><li>创建一个 Java 类实现 Runnable 接口</li><li>创建一个 Java 匿名类实现 Runnable 接口</li><li>使用 Java 8 Lambda 表达式实现 Runnable 接口</li></ol></blockquote><h5 id="3-1-创建一个-Java-类实现-Runnable-接口"><a href="#3-1-创建一个-Java-类实现-Runnable-接口" class="headerlink" title="3.1 创建一个 Java 类实现 Runnable 接口"></a>3.1 创建一个 Java 类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-创建一个-Java-匿名类实现-Runnable-接口"><a href="#3-2-创建一个-Java-匿名类实现-Runnable-接口" class="headerlink" title="3.2 创建一个 Java 匿名类实现 Runnable 接口"></a>3.2 创建一个 Java 匿名类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable &#x3D; new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口"><a href="#3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口" class="headerlink" title="3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口"></a>3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable &#x3D; () -&gt; &#123; System.out.println(&quot;Lambda Runnable running&quot;); &#125;;</span><br></pre></td></tr></table></figure><h5 id="3-4-开启一个实现了-Runnable-接口的线程"><a href="#3-4-开启一个实现了-Runnable-接口的线程" class="headerlink" title="3.4 开启一个实现了 Runnable 接口的线程"></a>3.4 开启一个实现了 Runnable 接口的线程</h5><p>java.lang.Thread的包含传入一个Runnable接口的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;or an anonymous class, or lambda...</span><br><span class="line">    Runnable runnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;executed by a thread</span><br><span class="line">    Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-使用哪种方式创建线程更好"><a href="#4-使用哪种方式创建线程更好" class="headerlink" title="4. 使用哪种方式创建线程更好 ?"></a>4. 使用哪种方式创建线程更好 ?</h3><p>关于继承Thread和实现Runnable接口，没有明确的规定用哪种方式创建线程更好，两种方式都可以让线程运行。我更倾向于使用实现Runnable接口的方式，后面我还们会了解到另外一种创建线程的方式，通过线程池创建线程的方式更加合理。</p><h3 id="5-常见陷阱：调用-run-代替-start"><a href="#5-常见陷阱：调用-run-代替-start" class="headerlink" title="5. 常见陷阱：调用 run() 代替 start()"></a>5. 常见陷阱：调用 run() 代替 start()</h3><p>通过调用start()，程序会告诉 CPU 线程已准备就绪，等待CPU执行 run() 方法。若直接调用 run() 方法则不会开启一个新的线程去执行 run() 方法，而是在原来的线程中去执行 run() 方法，所以当我们需要一个新的线程去执行 run() 方法中的代码时，应该调用 start() 方法启动一个线程，而不是直接调用 run() 方法。</p><h3 id="6-线程名（Thread-Names）"><a href="#6-线程名（Thread-Names）" class="headerlink" title="6. 线程名（Thread Names）"></a>6. 线程名（Thread Names）</h3><p>创建线程的时候可以指定线程名称，详见 java.lang.Thread API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable myRunnable &#x3D; () -&gt; System.out.println(&quot;Thread name is &quot; + Thread.currantThread().getName());</span><br><span class="line">    </span><br><span class="line">    new Thread(myRunnable, &quot;Thread One&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console out: Thread name is Thread One</span><br></pre></td></tr></table></figure><h3 id="7-Thread-currentThread"><a href="#7-Thread-currentThread" class="headerlink" title="7. Thread.currentThread()"></a>7. Thread.currentThread()</h3><p>通过 Thread.currentThread() 获取当前正在执行的线程对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread currentThread &#x3D; Thread.currentThread();</span><br></pre></td></tr></table></figure><h3 id="8-暂停线程"><a href="#8-暂停线程" class="headerlink" title="8. 暂停线程"></a>8. 暂停线程</h3><p>可以通过 Thread.sheep() 让线程睡眠指定毫秒数。这里不建议使用 thread.suspend() 方法，该方法和 Thread 类的 resume()、stop()、destroy() 都是 JDK 标注废弃方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： Thread.sheep() 方法不会释放CPU资源，如果设置锁的话也不会释放锁资源，只是让线程睡眠指定毫秒数。与 Object 类的 wait() 方法不同， wait() 方法主要用于线程通信，且 wait() 方法会释放锁资源。</p><h3 id="9-停止一个线程"><a href="#9-停止一个线程" class="headerlink" title="9. 停止一个线程"></a>9. 停止一个线程</h3><p>不建议使用 Thread 类提供的 stop() 方法去停止一个线程，stop() 方法会暴力停止一个线程，对程序不友好，可以通过更友好的方式停止一个线程。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private boolean doStop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.doStop &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized boolean keepRunning() &#123;</span><br><span class="line">        return this.doStop &#x3D;&#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(keepRunning()) &#123;</span><br><span class="line">            &#x2F;&#x2F; keep doing what this thread should do.</span><br><span class="line">            System.out.println(&quot;Running&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3L * 1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 doStop() 方法和 keepRunning() 方法使用了 synchronized 关键字，后面会详细讲解 synchronized 关键字的作用，这里不做过多描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnableMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10L * 1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例通过设置一个标识，主线程里面启动子线程，然后主线程睡眠10秒钟后调用 doStop() 方法，实现在主线程中停止子线程的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个Java线程就像一个可以执行你的Java代码的虚拟CPU。&lt;/p&gt;
&lt;p&gt;当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。&lt;/p&gt;
&lt;p&gt;Java 线程都是对象，就像其他的Java对
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 5. 并发和并行</title>
    <link href="http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</id>
    <published>2020-08-11T02:23:36.000Z</published>
    <updated>2020-08-26T02:08:24.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Concurrency-并发"><a href="#1-Concurrency-并发" class="headerlink" title="1. Concurrency 并发"></a>1. Concurrency 并发</h3><p>应用程序中（Application）同时进行一个以上的任务（Task）。对于单CPU的电脑而言，不可能同时进行一个以上的任务，CPU通过交换的执行任务直到任务都被执行完成。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" alt></div></p><hr><h3 id="2-Parallelism-并行"><a href="#2-Parallelism-并行" class="headerlink" title="2. Parallelism 并行"></a>2. Parallelism 并行</h3><p>应用程序中的任务（Task）被切割成多个子任务（SubTask）同时执行。实现并行你的应用程序必须有多个线程在同时执行，并且至少有一个任务在执行（Task）。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" alt></div></p><hr><h3 id="3-Concurrency-vs-Parallelism"><a href="#3-Concurrency-vs-Parallelism" class="headerlink" title="3. Concurrency vs. Parallelism"></a>3. Concurrency vs. Parallelism</h3><ul><li>并发是一个应用程序同时执行多个任务。</li><li>并行是一个应用程序处理单个任务，将单个任务切割成多个子任务并行执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Concurrency-并发&quot;&gt;&lt;a href=&quot;#1-Concurrency-并发&quot; class=&quot;headerlink&quot; title=&quot;1. Concurrency 并发&quot;&gt;&lt;/a&gt;1. Concurrency 并发&lt;/h3&gt;&lt;p&gt;应用程序中（Applic
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 4. 相同线程</title>
    <link href="http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-11T01:02:36.000Z</published>
    <updated>2020-08-26T02:08:25.063Z</updated>
    
    <content type="html"><![CDATA[<p>相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。</p><p>一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。</p><h3 id="1-为什么用单线程系统？"><a href="#1-为什么用单线程系统？" class="headerlink" title="1. 为什么用单线程系统？"></a>1. 为什么用单线程系统？</h3><p>你可能会想为什么每个人都能设计出单线程系统。单线程系统受欢迎的原因是因为单线程系统的并发模型比多线程系统的并发模型更加简单。单线程系统线程之间不共享任何状态（对象/数据），单线程系统可以不使用任何并发数据结构，并且更好地利用CPU和CPU缓存。</p><p>遗憾的是，单线程系统不能很好的利用现代CPU，现代CPU通常情况下拥有多个CPU内核，每个CPU内核的功能就像一个独立的单核CPU，一个单线程系统只能利用CPU中的一个内核，模型如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" alt></div></p><hr><h3 id="2-相同线程（单线程系统的扩展）"><a href="#2-相同线程（单线程系统的扩展）" class="headerlink" title="2. 相同线程（单线程系统的扩展）"></a>2. 相同线程（单线程系统的扩展）</h3><p>为了充分的利用CPU的内核，一个单线程系统可以扩展到利用整个计算机。</p><h5 id="一个CPU内核执行一个线程"><a href="#一个CPU内核执行一个线程" class="headerlink" title="一个CPU内核执行一个线程"></a>一个CPU内核执行一个线程</h5><p>相同线程系统通常让计算机中每个CPU内核执行一个线程，如果一个计算机有4个CPU，每个CPU拥有4个CPU内核，让每个CPU内核执行一个线程的示例如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" alt></div></p><hr><h3 id="3-不共享状态（数据）"><a href="#3-不共享状态（数据）" class="headerlink" title="3. 不共享状态（数据）"></a>3. 不共享状态（数据）</h3><p>一个相同线程系统与传统的多线程系统相似，因为一个相同线程系统有多个线程同时执行，但是两者有一些区别。</p><p>相同线程系统与多线程系统不同的是相同线程系统不共享状态（或不共享数据），当产生并发访问时不共享数据，没有并发数据结构等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" alt></div></p><p>不共享数据让相同线程系统看上去像单线程系统。因为相同线程系统可以包含多个单线程，因此取名相同线程系统更加合理。</p><p>相同线程系统基本含义是进程同时包含处理多个相同的线程，在相同线程系统中并发时没有线程共享数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。&lt;/p&gt;
&lt;p&gt;一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
