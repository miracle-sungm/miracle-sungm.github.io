<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miracle&#39;s Blog</title>
  
  <subtitle>Miracles happen every day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-03T02:58:39.293Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sungm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发编程] 10. Lock</title>
    <link href="http://yoursite.com/2020/09/02/Lock-In-Java/"/>
    <id>http://yoursite.com/2020/09/02/Lock-In-Java/</id>
    <published>2020-09-02T08:15:37.000Z</published>
    <updated>2020-09-03T02:58:39.293Z</updated>
    
    <content type="html"><![CDATA[<p>Lock 是除synchronized代码块的另外一种线程同步机制，Lock可以具有比synchronized代码块更复杂的作用。Lock可以使用synchronized关键字，所以它并不能让我们摆脱synchronized关键字。</p><p>自JDK 5开始，java.util.concurrent.locks包提供了一些Lock的实现类，比如ReentrantLock、ReadWriteLock、Condition，因此你可能不需要自己自定义Lock，但是你可能需要知道如何使用它们并了解其中的原理。这里我们不详细讲解，更多的细节，后面我将总结JUC工具包的相关知识点。</p><h3 id="1-简单的Lock"><a href="#1-简单的Lock" class="headerlink" title="1. 简单的Lock"></a>1. 简单的Lock</h3><p>先看看synchronized的同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line"></span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public int inc() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            return ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意inc()方法里面的synchronized(this)代码块，这个代码块确保了同一时间只有一个线程能够执行 ++count 指令。下面我们看看使用自定义的Lock代替上面这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Counter&#123;</span><br><span class="line">    </span><br><span class="line">    private Lock lock  &#x3D; new Lock();</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public int inc() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        int newCount &#x3D; ++count;</span><br><span class="line">        lock.unLock();</span><br><span class="line">        return newCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意lock()方法中的while (hasLock)循环，我们称它为“自旋锁”，自旋锁解决了线程通信的虚假唤醒的问题。</p><hr><h3 id="2-锁重入"><a href="#2-锁重入" class="headerlink" title="2. 锁重入"></a>2. 锁重入</h3><p>当某个线程进入同步代码块时，首先会尝试获取同步代码块的对象锁，一个线程可以拥有多个对象锁，由于不同同步代码块可能具有相同的对象锁，当线程拥有某个对象锁时，进入这个对象锁的同步代码块不需要再次获取锁，我们称它为可重入锁。</p><p>synchronized 具有重入锁的机制。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Reentrant &#123;</span><br><span class="line">    </span><br><span class="line">    public synchronized void methodA() &#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void methodB() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意普通方法A和普通方法B都使用了synchronized关键字声明，它的监视器对象是Reentrant的一个实例对象，methodA()中调用了methodB()，当某个线程进入进入methodA()，获取到对应的锁，进入methodB()不需要再次获取锁，可以直接进入methodB()。</p><p>JUC中还提供了一些重入锁，比如ReentrantLock、ReentrantReadWriteLock等等，这里我们不细讲，后面请看JUC博客专题。</p><p>现在我们自定义一个可重入锁。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义可重入锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-03 10:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CustomReentrantLock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line">    private Thread lockedBy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLocked &amp;&amp; lockedBy !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">        lockedBy &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        lockedBy &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，while 循环中不仅要判断hasLocked是否被锁住还要判断当前线程是否是锁被拥有的线程，这就是可重入的锁。</p><hr><h3 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="3. 公平锁"></a>3. 公平锁</h3><p>在上一章<a href="https://www.runoob.com" target="_blank" rel="noopener">饥饿与公平</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lock 是除synchronized代码块的另外一种线程同步机制，Lock可以具有比synchronized代码块更复杂的作用。Lock可以使用synchronized关键字，所以它并不能让我们摆脱synchronized关键字。&lt;/p&gt;
&lt;p&gt;自JDK 5开始，java
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 17. 饥饿与公平</title>
    <link href="http://yoursite.com/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <id>http://yoursite.com/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/</id>
    <published>2020-09-01T06:39:45.000Z</published>
    <updated>2020-09-01T11:50:24.059Z</updated>
    
    <content type="html"><![CDATA[<p>一个线程没有获取到CPU时间片，因为CPU时间片总是被其他线程获取，这种情况我们叫它“饥饿”。线程被“饿死”是因为没有获取CPU时间片执行指令。解决“饥饿”的办法成为“公平” —— 所有的线程公平的获取CPU时间片执行指令。</p><hr><h3 id="1-Java-中常见饥饿的场景"><a href="#1-Java-中常见饥饿的场景" class="headerlink" title="1. Java 中常见饥饿的场景"></a>1. Java 中常见饥饿的场景</h3><blockquote><ul><li>具有高优先性的线程比低优先性的线程更容易获取CPU时间片。</li><li>线程无限期阻塞等待进入synchronized代码块，因为其他线程在不断地被允许访问synchronized代码块。</li><li>线程调用了wait方法，一直未被唤醒，因为总有其他的线程被唤醒（调用notify方法），而不是它。</li></ul></blockquote><h5 id="1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片"><a href="#1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片" class="headerlink" title="1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片"></a>1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片</h5><p>你可以通过setPriority()方法（Thread类的方法，取值范围是[1-10]）设置每个线程的优先级。具有高优先性的线程比低优先性的线程更容易获取CPU时间片，具体怎么执行依赖于我们的操作系统。</p><h5 id="1-2-线程无限期阻塞等待进入synchronized代码块"><a href="#1-2-线程无限期阻塞等待进入synchronized代码块" class="headerlink" title="1.2 线程无限期阻塞等待进入synchronized代码块"></a>1.2 线程无限期阻塞等待进入synchronized代码块</h5><p>Java synchronized 代码块不保证线程按照等待进入synchronized代码块的顺序进入synchronized代码块，首先等待进入synchronized代码块的线程不一定先进入synchronized代码快。这就意味着系统可能存在某些线程无限期的等待进入synchronized代码块的风险，因为其他线程在不断的访问它。</p><h5 id="1-3-线程调用了wait方法，一直未被唤醒"><a href="#1-3-线程调用了wait方法，一直未被唤醒" class="headerlink" title="1.3 线程调用了wait方法，一直未被唤醒"></a>1.3 线程调用了wait方法，一直未被唤醒</h5><p>我们都知道wait()、notify()、notifyAll() 方法用于线程通信。在多个等待线程调用了wait()方法时，某个唤醒线程调用了notify() 方法会唤醒某个等待线程，但它不保证某个线程一定会被唤醒，它唤醒的是等待线程中的任意一个线程。因此当多个线程调用了wait方法，其中某些线程可能一直处于等待状态，因为总有线程被唤醒，而不是它们。</p><hr><h3 id="2-Java-中实现公平"><a href="#2-Java-中实现公平" class="headerlink" title="2. Java 中实现公平"></a>2. Java 中实现公平</h3><p>尽管Java中不可能百分之百实现公平，但我们可以实现我们的同步机制来提高不同线程之间的公平性。</p><p>示例：synchronized 代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">  public synchronized void doSynchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;do a lot of work which takes a long time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个线程调用doSynchronized()方法，只有一个线程能够进入该方法，其他线程会造成阻塞直到进入doSynchronized()方法的线程退出。如果多个线程被阻塞，当某个线程退出synchronized代码块后，不确定下一次进入synchronized代码块的线程是哪个线程。</p><h5 id="2-1-使用Lock代替synchronized代码块"><a href="#2-1-使用Lock代替synchronized代码块" class="headerlink" title="2.1 使用Lock代替synchronized代码块"></a>2.1 使用Lock代替synchronized代码块</h5><p>为了提高等待线程进入同步代码块的公平性，通过自定义的Lock代替synchronized代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">    public synchronized void doSynchronized() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line"></span><br><span class="line">        lock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意doSynchronized()方法没有使用synchronized关键字声明，取而代之的是Lock类的lock()和unLock()方法，Lock类的实现可以是下面这种方式（也可以使用juc包下的Lock，这里先尝试自己实现Lock）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line">    </span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line">    private Thread lockThread &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">        lockThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        if (lockThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread is not lock thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        lockThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请仔细看Lock类的实现，你会发现当多个线程访问lock()方法时会造成阻塞，因为它使用了synchronized关键字。如果锁已经被锁定，其他线程调用lock方法进入无效状态（调用了wait方法），锁的每次释放，都将唤醒一个wait状态的线程(unLock方法里面调用了notify方法)。</p><p>之前我们提到过，当多个线程同时调用synchronized代码块会造成阻塞，synchronized关键字不会确保线程按顺序进入synchronized代码块。同样，当多个线程调用了wait方法，某个唤醒线程调用notify方法不能唤醒某个指定的等待线程。因此上面的示例是不是一个公平的锁，但是我们可以对它做修改，实现一个公平锁。</p><p><strong>公平锁</strong></p><p>可参考 java.util.concurrent.locks.ReentrantLock 类中的内部类 FairSync 同步锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个线程没有获取到CPU时间片，因为CPU时间片总是被其他线程获取，这种情况我们叫它“饥饿”。线程被“饿死”是因为没有获取CPU时间片执行指令。解决“饥饿”的办法成为“公平” —— 所有的线程公平的获取CPU时间片执行指令。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Java-
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 16. 死锁和预防死锁</title>
    <link href="http://yoursite.com/2020/08/27/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2020/08/27/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/</id>
    <published>2020-08-27T12:02:54.000Z</published>
    <updated>2020-08-28T08:36:38.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程死锁"><a href="#1-线程死锁" class="headerlink" title="1. 线程死锁"></a>1. 线程死锁</h3><p>死锁：两个或多个线程因为竞争资源而造成的一种僵局。</p><p>示例：线程A拥有锁a，线程B拥有锁b，线程A尝试获取锁b，线程B尝试获取锁a，因此产生死锁。线程A将永远无法获取锁b，同样线程B也无法获取锁a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for a</span><br></pre></td></tr></table></figure><p>说明：线程A和线程B必须分别拥有锁a、锁b，同时等待彼此释放锁才会造成死锁的发生，若线程A等待获取锁B时线程B释放了锁B，那么不会造成死锁。</p><p>更复杂的死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for c</span><br><span class="line">Thread C    locks c, wait for d</span><br><span class="line">Thread D    locks d, wait for e</span><br></pre></td></tr></table></figure><p>线程A等待线程B释放锁，线程B等待线程C释放锁，线程C等待线程D释放锁，线程D等待线程A释放锁，造成更加复杂的死锁。</p><hr><h3 id="2-数据库死锁"><a href="#2-数据库死锁" class="headerlink" title="2. 数据库死锁"></a>2. 数据库死锁</h3><p>一个更加复杂的死锁，是数据库的事务。一个数据库事务可能由很多个 update 语句组成。当一条记录在某个事务中被更新时，其他事务更新这条记录需要等待第一个事务提交，同一个事务中的每个 update 语句可能会锁住数据库中的一些数据记录。</p><p>当多个事务同时需要更新一些记录，就可能产生数据库死锁。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction A   第一个update请求： 锁住记录1</span><br><span class="line">Transaction B   第一个update请求： 锁住记录2</span><br><span class="line">Transaction A   第二个update请求： 尝试修改并锁住记录2</span><br><span class="line">Transaction B   第二个update请求： 尝试修改并锁住记录1</span><br></pre></td></tr></table></figure><hr><h3 id="3-预防死锁"><a href="#3-预防死锁" class="headerlink" title="3. 预防死锁"></a>3. 预防死锁</h3><p>一些防止死锁的方法：</p><blockquote><ul><li>锁排序</li><li>锁超时</li><li>死锁检测</li></ul></blockquote><h5 id="3-1-锁排序"><a href="#3-1-锁排序" class="headerlink" title="3.1 锁排序"></a>3.1 锁排序</h5><p>当多个线程以不同的顺序竞争一些锁资源时，可能产生死锁。</p><p>如果你能确保所有的线程按照一定的顺序获取锁资源，就不会产生死锁。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread A:</span><br><span class="line">    lock a</span><br><span class="line">    lock b</span><br><span class="line"></span><br><span class="line">Thread B:</span><br><span class="line">    wait for a</span><br><span class="line">    lock c (when a lock)</span><br><span class="line"></span><br><span class="line">Thread C:</span><br><span class="line">    wait for a:</span><br><span class="line">    wait for b:</span><br><span class="line">    wait for c:</span><br></pre></td></tr></table></figure><p>示例中的线程C，它必须按照 a -&gt; b -&gt; c 的顺序获取对应的锁，在未获取顺序排在前面的锁之前线程C无法获取后的锁。</p><p>示例中：一旦线程A获得了锁a，线程B和线程C必须等待线程A释放锁a之后才竞争获取锁a，之后它们必须按顺序获取锁b或锁c.</p><p><strong>锁排序是一种非常简单有效的预防死锁机制。然而，你需要已知所有的锁，然后给它们设定顺序。我们并非总能已知所有的锁。</strong></p><h5 id="3-2-锁超时"><a href="#3-2-锁超时" class="headerlink" title="3.2 锁超时"></a>3.2 锁超时</h5><p>另外一种预防死锁的机制是：给线程在尝试获取锁的时候设置一个超时时间，如果指定时间内未获取锁则放弃。如果一个线程在给定时间范围内未获取到所有有需要的锁，它将会阻塞并释放自身拥有的所有锁资源，等待一个随机的时间之后重新进入。这个随机的等待时间内，其他的线程可以获取锁资源或释放一些锁资源，改变锁资源的状态，这样使得应用程序避免死锁的发生。</p><p>示例：假设有2个线程分别是线程1，线程2按不同的顺序获取锁A，锁B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程1获取锁资源A</span><br><span class="line">线程2获取锁资源B</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B但是锁B被线程2获取了</span><br><span class="line">线程2尝试获取锁资源A但是锁A被线程1获取了</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B 超时</span><br><span class="line">线程1阻塞并释放锁资源A</span><br><span class="line">线程1等待一个随机的时间（比如198毫秒）之后重新进入</span><br><span class="line"></span><br><span class="line">线程2尝试获取锁资源A 超时</span><br><span class="line">线程2阻塞并释放锁资源B</span><br><span class="line">线程2等待一个随机的时间（比如221毫秒）之后重新进入</span><br></pre></td></tr></table></figure><p>注意的是：线程尝试获取锁超时不一定意味着发生了死锁。因为存在其他的因素，比如持有锁的线程在设定的时间内未执行完任务，持有锁未释放锁导致其他线程尝试获取锁超时。</p><p>另外，当足够多的线程竞争同一个锁资源时，可能导致一些线程尝试获取锁时一次又一次的发生锁超时。</p><p>设置锁超时的预防死锁的机制有一个问题是：当线程进入synchronized代码块时，你无法给线程尝试进入synchronized代码块设置一个超时时间。你必须使用一个自定义的锁类或者使用 Java 5 提供的 JUC 包内的一些工具类。</p><h5 id="3-3-锁排序-vs-锁超时"><a href="#3-3-锁排序-vs-锁超时" class="headerlink" title="3.3 锁排序 vs. 锁超时"></a>3.3 锁排序 vs. 锁超时</h5><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th align="left">类型</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">锁排序</td><td align="left">简单，易实现</td><td align="left">适用于所有已知的锁资源，并设定锁的顺序</td></tr><tr><td align="left">锁超时</td><td align="left">灵活，不需要已知所有的锁资源</td><td align="left">复杂，线程获取锁资源时需设定超时时间，一般情况下使用juc工具包中的类，无法给synchronized关键字设定超时时间</td></tr></tbody></table><h5 id="3-4-死锁检测"><a href="#3-4-死锁检测" class="headerlink" title="3.4 死锁检测"></a>3.4 死锁检测</h5><p>死锁检测是一种沉重的防止死锁机制。通常在设置锁顺序、设置锁超时是不可行的情况下使用。</p><p>每个线程获取锁时需要在一个数据结构（例如map、graph）中记录线程和锁资源的信息，另外，无论何时线程请求锁也需要记录到一个数据结构中，后面通过检测这个数据结构来预防死锁的发生。</p><p>当一个线程尝试获取锁时被拒绝，这个线程可以通过定义的数据结构来检测系统是否发生了死锁。</p><p>线程A持有锁1，线程B持有锁2，线程C持有锁3，线程D持有锁4，且线程A尝试获取锁2，线程B尝试获取锁3，线程C尝试获取锁4，线程D尝试获取锁1。那么定义的数据结构示例如下：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" alt></div></p><p>当线程A持有锁1，且尝试获取锁2被拒时，那么可以通过定义的数据结构获取到持有锁2的线程B，再获取到线程B尝试获取的锁3，再循环上面的算法得到锁三的持有线程C，获取线程C尝试获取的锁4，再循环得到锁4的持有线程D，得到线程D之后获取到线程D尝试获取的锁1，这时候检测到锁1被自己（线程A）持有，那么就检测出了系统存在死锁。</p><p>简单地说，每当一个线程获取锁被拒绝时，这个线程根据定义的数据结构检测系统是否存在死锁，具体做法是以递归的形式遍历获取失败的锁以及获取失败的锁的所属线程，判断线程获取失败的锁是否与原始线程（获取锁失败并检测死锁的那个线程）持有的锁是否相同，如果原始线程拥有的锁中包含某个线程尝试获取的锁，那么就说明系统存在死锁，否则不存在死锁。</p><p>那么怎么处理死锁呢？</p><ol><li>当某个线程获取某个锁失败时，并检测到死锁，其中一种比较简单的做法是当前检测到死锁的线程释放所有的锁资源，以便其他线程获取到当前线程释放的锁资源，同时当前线程阻塞一个随机的时间段后重新进入，这有点类似于设置锁超时的做法。</li><li>另外一个更好的做法是指定一些线程的优先级，只让少量线程造成阻塞，剩余的线程在没有死锁发生的情况下继续执行任务。</li></ol><h3 id="3-5-预防死锁小结"><a href="#3-5-预防死锁小结" class="headerlink" title="3.5 预防死锁小结"></a>3.5 预防死锁小结</h3><p>通常情况下，设置获取锁的顺序是一种常见的、比较简单的预防死锁的方案，但不适用于锁数量过多和存在未知的锁资源时使用。在通过设置锁顺序方案不可行或难实行的情况下，我们可以使用juc工具包中的一些类来设置获取锁时间的方案，不过这种方案不适用于synchronized关键字。在前两种方案都比较困难实行的情况下，可以使用死锁检测的方案来检测死锁并处理死锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-线程死锁&quot;&gt;&lt;a href=&quot;#1-线程死锁&quot; class=&quot;headerlink&quot; title=&quot;1. 线程死锁&quot;&gt;&lt;/a&gt;1. 线程死锁&lt;/h3&gt;&lt;p&gt;死锁：两个或多个线程因为竞争资源而造成的一种僵局。&lt;/p&gt;
&lt;p&gt;示例：线程A拥有锁a，线程B拥有锁b，
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 15. 线程通信</title>
    <link href="http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-21T11:22:17.000Z</published>
    <updated>2020-09-03T02:32:36.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过共享对象实现线程通信"><a href="#1-通过共享对象实现线程通信" class="headerlink" title="1. 通过共享对象实现线程通信"></a>1. 通过共享对象实现线程通信</h3><p>线程通过在共享对象中发送一个信号实现与其他线程通信。如下图所示，设置一个成员变量 hasProcess，线程A通过setHasProcess同步方法设置hasProcess的值，这样线程B可以读取到成员变量hasProcess的值，实现线程之间的通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MySignal &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasProcess &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void setHasProcess(boolean hasProcess) &#123; this.hasProcess &#x3D; hasProcess; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean getHasProcess() &#123; return this.hasProcess; &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A和线程B必须引用共享对象 MySignal 的实例来实现线程A与线程B之间的线程通信。如果线程A和线程B引用了不同的MySignal实例对象，那么线程A和线程B不会检测到彼此发送的信号，达不到线程通信的目的。</p><hr><h3 id="2-Busy-Wait"><a href="#2-Busy-Wait" class="headerlink" title="2. Busy Wait"></a>2. Busy Wait</h3><p>上例中线程B需要等待信号处理数据，因此它的业务代码很可能一直在等待信号，浪费了很多CPU资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySignal singal &#x3D; ...</span><br><span class="line"></span><br><span class="line">while (!singal.getHasProcess()) &#123;</span><br><span class="line">    &#x2F;&#x2F;do nothing... busy waiting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们不知道线程A什么时候发送信号，因此导致线程B一直等待线程A的信号，没做任何事情，浪费CPU资源。</p><hr><h3 id="3-等待通知机制：wait-、notify-、notifyAll"><a href="#3-等待通知机制：wait-、notify-、notifyAll" class="headerlink" title="3. 等待通知机制：wait()、notify()、notifyAll()"></a>3. 等待通知机制：wait()、notify()、notifyAll()</h3><p>Busy waiting 浪费了CPU资源，即使某些情况下等待的时间非常短暂。因此，让等待信号的线程在接收信号之前处于无效状态，直到接收信号之后（被唤醒）继续执行代码，这是一种非常聪明的做法。</p><p><strong>等待通知机制：</strong>让等待信号的线程在接收信号之前处于无效状态（不占用CPU资源，线程暂停执行），由发出信号的线程唤醒等待信号的线程，等待信号的线程被唤醒后继续执行，这就是等待通知机制。</p><p>Java 有一个等待机制：让等待信号的线程处于无效状态。Java Object 类定义了三个方法分别是wait()、notify()、notifyAll()，通过这三个方法我们可以实现这种机制。</p><p>一个线程调用了某个对象的 wait() 方法之后，这个线程就成为无效状态，直到另外一个线程调用了同一个对象的 notify() 方法或者 notifyAll()方法之后，原来处于无效状态的线程才结束无效状态。</p><p>线程调用某个对象的 wait() 方法或者 notify() 方法必须获取这个对象的锁，也就是说 wait() 方法或者 notify() 方法调用的代码必须包含在 synchronized 代码块中，synchronized 监视器必须是 wait() 或 nofity() 方法所属的那个对象。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;监视器对象</span><br><span class="line">public class MonitorObject &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyWaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    MonitorObject myMonitorObject &#x3D; new MonitorObject();</span><br><span class="line"></span><br><span class="line">    public void doWait() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;wait()方法必须包含在synchronized代码块中，且synchronized监视器是wait()方法所属对象myMonitorObject</span><br><span class="line">                myMonitorObject.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doNotify() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            &#x2F;&#x2F;notify()方法必须包含在synchronized代码块中，且synchronized监视器是notify()方法所属对象myMonitorObject</span><br><span class="line">            myMonitorObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程调用某个对象的notify()方法，会唤醒一个等待状态的线程；通过调用notifyAll()方法，唤醒所有处于等待状态的线程。</p><p>你可以从上例中观察到<strong>wait()方法和notify()方法都在同步代码块中，并且同步代码块的监视器对象与调用wait方法（或notify方法）的对象是同一个对象</strong>。这是强制的，一个线程不能在没有持有某个对象锁的方法上调用wait方法或notify方法，否则程序将抛出 IllegalMonitorStateException (非法监视器状态异常)。</p><p>你可能会想：当等待线程进入synchronized代码块调用wait方法使得线程进入等待状态，并没有退出synchronized代码块，那么等待线程就会阻止唤醒线程进入synchronized代码块调用notify()方法，那么唤醒线程怎么可能能够进入synchronized代码块呢？答案是唤醒线程可以进入synchronized代码块调用notify方法，原因是当一个线程调用了wait方法之后，当前线程会释放基于某个对象的持有锁，这样其他的线程就有机会进入synchronized代码块。</p><p>一旦一个线程被唤醒，它不能立即退出wait()方法，等待线程需要等待唤醒线程退出包含notify()方法的synchronized代码块之后，等待线程需要重新获取对象的持有锁之后退出wait方法，然后继续执行下面的代码。</p><p>使用notifyAll()唤醒多个等待线程，那么多个等待线程也需要等唤醒线程退出synchronized代码块之后，各个等待线程需要重新获取对象的持有锁才能退出wait()方法继续执行程序，由于各个等待线程的synchronized代码块的监视器是同一个对象，因此各个线程之间是同步退出wait()方法。</p><p>小结：</p><ul><li>Java 的等待通知机制是基于某个对象实现的一种等待通知机制。</li><li>Java Object 类定义的 wait()、notify()、notifyAll()用于线程通信，这些方法的调用必须包含在以这些方法的对象为监视器的synchronized代码块中，否则程序将抛出IllegalMonitorStateException异常。</li><li>当一个线程调用wait()方法后，线程会释放基于这个方法的对象的持有锁，并使线程进入无效状态，只有当其他线程调用了同一个对象的notify方法（或notifyAll方法）之后，这个对象才可能被唤醒，等待线程需等唤醒线程退出包含notify方法（或notifyAll方法）的synchronized代码块之后，才能重新获取对象的持有锁并退出wait方法继续执行程序。</li><li>当一个线程调用某个对象的notifyAll方法后，所有基于这个对象的等待中的线程将全部被唤醒，但这些等待中的线程需要等唤醒线程退出包含notifyAll方法的synchronized代码块之后，同步的获取对象的持有锁并退出wait()方法。</li></ul><hr><h3 id="4-丢失信号"><a href="#4-丢失信号" class="headerlink" title="4. 丢失信号"></a>4. 丢失信号</h3><p>当一个线程调用notify方法时没有线程处于等待状态，那么这个唤醒信号就被丢失了。丢失信号可能会导致程序产生一些问题，也可能不会产生一些问题，但我们需要知道这种情况可能发生。在某些情况下，丢失信号可能导致一些等待线程一直处于等待中，从未被唤醒，因为唤醒线程调用notify方法发生在等待线程调用wait方法之前。</p><p>为了避免这个问题，我们可以将信号保存在共享数据对象中，这里就不在举例了。</p><hr><h3 id="5-虚假唤醒"><a href="#5-虚假唤醒" class="headerlink" title="5. 虚假唤醒"></a>5. 虚假唤醒</h3><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 17:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static int number &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new Lock();</span><br><span class="line">        </span><br><span class="line">        Runnable myRunnable &#x3D; () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                number++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        new Thread(myRunnable, &quot;Thread A&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread B&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLocked) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现在我们来分析下上面代码中可能会存在什么问题？</strong></p><p>首先假设线程A调用了lock()方法获取到了锁，然后执行number++操作时，此时线程B进入lock()方法（锁已被线程A获取），因此线程B调用wait()方法进入等待状态，之后线程A调用了unLock()方法释放锁资源并唤醒一个线程，因为这里只有线程B处于wait状态，因此线程B被唤醒，线程B等待重新进入synchronized代码块，若此时线程C优先于线程B进入lock同步方法，锁归线程C所有，当线程C退出lock方法后，线程B进入synchronized退出wait方法，继续执行下面的程序代码，那么此时锁同时被线程B和线程C拥有，出现了不同步的操作，这样容易导致程序出现问题。</p><p><strong>现在我们来解决上面代码存在的问题</strong></p><p>我们只要将lock()方法中的if(hasLocked)判断条件换成while(hasLocked)代码块，就能很好的解决上面这个问题，while(hasLocked)我们称它为“自旋锁”。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">    while (hasLocked) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    hasLocked &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当线程B退出wait()方法后继续判断hasLocked条件是否为真，仅当锁没有被任何线程锁拥有时才真正的唤醒线程，否则线程继续等待。</p><h3 id="当多个线程等待同一个信号"><a href="#当多个线程等待同一个信号" class="headerlink" title="当多个线程等待同一个信号"></a>当多个线程等待同一个信号</h3><p>自旋锁在处理多个线程等待同一个信号时也是一种很好的方案，我们会使用notifyAll()方法唤醒等待的所有线程，同时只有一个线程能够退出wait()方法，当某个线程退出wait()方法后，这个线程会修改hasLocked的值，当其他线程退出wait方法时会自旋判断hasLocked，若锁被其他线程拥有，会继续进入等待状态，从而避免程序产生一些不正常的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-通过共享对象实现线程通信&quot;&gt;&lt;a href=&quot;#1-通过共享对象实现线程通信&quot; class=&quot;headerlink&quot; title=&quot;1. 通过共享对象实现线程通信&quot;&gt;&lt;/a&gt;1. 通过共享对象实现线程通信&lt;/h3&gt;&lt;p&gt;线程通过在共享对象中发送一个信号实现与其
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 14. ThreadLocal</title>
    <link href="http://yoursite.com/2020/08/21/ThreadLocal/"/>
    <id>http://yoursite.com/2020/08/21/ThreadLocal/</id>
    <published>2020-08-21T02:45:56.000Z</published>
    <updated>2020-08-21T11:20:57.464Z</updated>
    
    <content type="html"><![CDATA[<p>Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 ThreadLocal 类以一种非常简单的方式确保了线程安全。</p><p>建议: 看这篇博客的同时，阅读一遍 java.lang.ThreadLocal 的源码，相信您从源码中获取的知识点会更多一些。</p><h3 id="1-创建一个线程变量"><a href="#1-创建一个线程变量" class="headerlink" title="1. 创建一个线程变量"></a>1. 创建一个线程变量</h3><p>我们可以通过下面这种方式创建一个ThreadLocal对象，我们还可以给它指定泛型类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这个代码只需要执行一次。然后线程就可以对它设置值（set）或者读取值（get），每个线程只能获取到它们自己设置的值。</p><hr><h3 id="2-设置-ThreadLocal-的值"><a href="#2-设置-ThreadLocal-的值" class="headerlink" title="2. 设置 ThreadLocal 的值"></a>2. 设置 ThreadLocal 的值</h3><p>一旦创建了ThreadLocal对象，就可以设置ThreadLocal的值，我们通过set()方法设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="2-获取-ThreadLocal-的值"><a href="#2-获取-ThreadLocal-的值" class="headerlink" title="2. 获取 ThreadLocal 的值"></a>2. 获取 ThreadLocal 的值</h3><p>通过get()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure><hr><h3 id="3-移除-ThreadLocal-的值"><a href="#3-移除-ThreadLocal-的值" class="headerlink" title="3. 移除 ThreadLocal 的值"></a>3. 移除 ThreadLocal 的值</h3><p>通过remove()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure><hr><h3 id="4-ThreadLocal-泛型"><a href="#4-ThreadLocal-泛型" class="headerlink" title="4. ThreadLocal 泛型"></a>4. ThreadLocal 泛型</h3><p>我们可以给ThreadLocal指定泛型类型，指定泛型类型之后只能设置泛型类型的值，另外，获取ThreadLocal的值时不需要做类型转换。</p><p>正如我们上面提出的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定泛型类型为String</span><br><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置值</span><br><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值</span><br><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 13. volatile关键字</title>
    <link href="http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-19T13:01:24.000Z</published>
    <updated>2020-08-26T02:08:25.023Z</updated>
    
    <content type="html"><![CDATA[<p>volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。</p><p>实际上，自 Java 5 起，volatile 关键字不仅仅保证从主内存中读取数据或者写回数据至主内存中。下面一起来探索下 volatile 关键字的作用吧。</p><h3 id="1-volatile-可见性问题"><a href="#1-volatile-可见性问题" class="headerlink" title="1. volatile 可见性问题"></a>1. volatile 可见性问题</h3><p>volatile 关键字保证了当某个线程改变了 volatile 变量的值时对其他线程可见。</p><p>在多线程应用系统中，线程操作 non-volatile 变量时，每个线程会拷贝 non-volatile 变量（拷贝引用）至CPU高速缓存中。如果你的计算机包含多个CPU，每个线程在不同的CPU上运行时，这就意味着每个线程拷贝这些变量至不同的CPU的CPU高速缓存中，如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" alt></div></p><p>对于 non-volatile 变量，JVM每次读取变量数据时不会保证从主内存中拷贝至CPU高速缓存中，或者每次写数据时不会保证把CPU高速缓存的数据写回至主内存中。</p><p>下面我们来看个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，有2个线程，第一个线程对 count 的值做修改，第二个的线程能读取到 count 被修改后的值吗？？？</p><p>由于这个 count 变量没有被 volatile 关键字声明，当2个CPU运行的2个线程分别读取 count 的值时，会从主内存中将count的值拷贝至各自的CPU高速缓存中，其中一个线程修改count的值，由于它没有被volatile声明，因此不会保证被修改后的值写回至主内存中。请看下图：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" alt></div></p><p>由于count变量值被修改后没有写回主内存中，并且线程每次读取count变量值也没有保证从主内存中读取，这个问题被称为数据可见性问题，我们可以通过使用volatile关键字解决数据可见性问题，也可以使用其他方式解决。</p><hr><h3 id="2-volatile-可见性保证"><a href="#2-volatile-可见性保证" class="headerlink" title="2. volatile 可见性保证"></a>2. volatile 可见性保证</h3><p>volatile 关键字解决了数据可见性问题。通过使用 volatile 关键字声明变量是一个volatile变量，保证了每次读取变量数据时从主内存读取，写数据时把数据写回主内存中。</p><p>通过 volatile 声明变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public volatile int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的这种情况，当线程一修改了count的值，线程二没有修改count的值，只读取了count的值，这种情况下，使用volatile关键字声明count变量足够保证数据的线程二读取到的是最新的数据。</p><p><strong>注意：当存在多个线程对同一个共享变量做修改操作时，使用volatile是远远不够的，volatile关键字只能保证数据可见性，并不能保证数据操作是原子性的，我们可以使用synchronized关键字或者Java提供的JUC工具包。</strong></p><h5 id="2-1-所有变量可见性保证"><a href="#2-1-所有变量可见性保证" class="headerlink" title="2.1 所有变量可见性保证"></a>2.1 所有变量可见性保证</h5><p>实际上，volatile 关键字的作用超越了 volatile 变量本身，有更多的作用。包括：</p><blockquote><ul><li>当某个线程写回volatile变量的值至主内存时，这个<strong>线程可见的所有变量的值</strong>都会写回至主内存中</li><li>当某个线程从主内存中读取volatile变量的值时，这个<strong>线程可见的所有变量的值</strong>都会重新从主内存中读取</li></ul></blockquote><p>上面提到的这些内容我们在博客<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">[Java 并发编程] 11. Java Happen Before Guarantee</a>提到过，这里不再举例证明。</p><hr><h3 id="3-指令重排挑战"><a href="#3-指令重排挑战" class="headerlink" title="3. 指令重排挑战"></a>3. 指令重排挑战</h3><p>JVM和CPU为了提升性能允许指令重排，只要满足语义不变（单线程情况下执行结果不变）即可指令重排。</p><p>请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>指令重排后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line">int b &#x3D; 2;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>然而，当一个变量被volatile修饰时，存在一些指令重排的挑战。请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int years;</span><br><span class="line">    private int months</span><br><span class="line">    private volatile int days;</span><br><span class="line"></span><br><span class="line">    public void update(int years, int months, int days)&#123;</span><br><span class="line">        this.years  &#x3D; years;</span><br><span class="line">        this.months &#x3D; months;</span><br><span class="line">        this.days   &#x3D; days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦执行上面的update()方法，执行到修改days的指令时，years和months修改后的值也会被写回到主内存中。但是如果发生了指令重排，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void update(int years, int months, int days)&#123;</span><br><span class="line">    this.days   &#x3D; days;</span><br><span class="line">    this.years  &#x3D; years;</span><br><span class="line">    this.months &#x3D; months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样执行到days修改的指令时，years和months的值也会被写回到主内存中，但此时years和months的值未被修改（指令重排导致years和months修改的指令在days指令下面），写回数据至主内存的操作发生在years和months修改指令的前面，当执行完years和months的修改指令后，不会同步数据至主内存，因此years和months的新值对其他线程不可见（未使用volatile关键字），这样的指令重排导致程序的语义发生了改变。</p><p>Java 有解决这个问题，让我们看下一章节。</p><h3 id="4-volatile-happens-before-保证"><a href="#4-volatile-happens-before-保证" class="headerlink" title="4. volatile happens-before 保证"></a>4. volatile happens-before 保证</h3><p>为了解决指令重排可能产生的问题，java volatile 关键字除了提供可见性保证之外，还提供提供了happens-before保证，如下：</p><blockquote><ul><li>当其他变量的读写指令原本就在volatile写指令前面时，那么其他变量的读写指令不会被重排序到 volatile 写指令后面。（请注意：这里只提出了原本在volatile变量写指令前面的指令，不会被重排序到volatile指令后面，原本在volatile写指令前面的指令之间可以发生指令重排。）</li><li>当其他变量的读写指令原本就在volatile读指令后面时，那么其他变量的读写指令不会被重排序到 volatile 读指令前面。（同样：原本在 volatile 读指令后面的指令之间可以发生指令重排）</li></ul></blockquote><h3 id="5-volatile-不足"><a href="#5-volatile-不足" class="headerlink" title="5. volatile 不足"></a>5. volatile 不足</h3><p>即使 volatile 关键字保证了线程每次读取 volatile 变量时从主内存中读取数据，每次写数据时把数据写回主内存中，但在一些情况下，声明volatile变量是不够的。</p><p>上面我们提到过当一个线程修改volatile变量时，能保证其他线程可以读取到volatile变量的最新值。</p><p>事实上，在多个线程修改volatile变量的情况下，也能确保最新值被写回到主内存中。但这样可能会存在一些问题，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int totalPrice &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public int addPrice(int price) &#123;</span><br><span class="line">    totalPrice +&#x3D; price;</span><br><span class="line">    return totalPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initTotalPrice() &#123;</span><br><span class="line">    totalPrice &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程一、线程二分别在执行addPrice()方法和initTotalPrice()方法时，线程一执行完totalPrice += price指令后，把totalPrice的最新值刷回到主内存中，若此时线程二正巧执行完initTotalPrice()方法，totalPrice的值被重新刷回0，当线程一再读取totalPrice值并返回，导致最终返回的值是0，这可能不是我们程序最终想要的结果。（备注：当然我们不会去写这种程序代码，这个示例我只用来说明问题，并没有实际测试过这种场景。）</p><p>上例其实就是为了说明一个问题：<strong>volatile 只是保证了数据的可见性，并没有保证原子性，如果要执行原子性操作，使用volatile关键字是远远不够的。这里顺便提一下，synchronized关键字不仅保证了数据可见性，同时也保证了原子性。</strong></p><p>再来看下一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明volatile变量</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自增</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>当2个线程同时对变量 i 做自增操作，当他们同时把 i 的值写回到主内存中时，最终写回的值时1，实际上i做了2次自增。</p><p>因此：在多个线程同时存在修改共享数据的情况时，仅仅使用volatile变量是不够的。请记住：volatile 关键字只保证了数据可见性，并不保证原子性。</p><h3 id="6-什么时候使用-volatile"><a href="#6-什么时候使用-volatile" class="headerlink" title="6. 什么时候使用 volatile ?"></a>6. 什么时候使用 volatile ?</h3><p>正如前面提到的，如果多个线程同时对共享数据进行读写操作，这种情况下使用volatile关键字是不够的。我们需要使用synchronized关键字保证数据读写的可见性和原子性。</p><p>除了使用synchronized关键字之外，我们还可以使用 java.util.concurrent 包提供的各种工具类，比如 AtomicLong 、 AtomicReference 等等。</p><p>当只有一个线程会对共享变量的值进行修改，其他的线程只读取共享变量的值时，我们使用volatile关键字是足够的。</p><p>另外: volatile 关键字工作在32位或者64位的变量上。</p><h3 id="7-volatile-性能考虑"><a href="#7-volatile-性能考虑" class="headerlink" title="7. volatile 性能考虑"></a>7. volatile 性能考虑</h3><p>我们都知道，CPU操作CPU高速缓存的速度远远快于操作主内存的速度。CPU每次操作volatile关键字都会操作主内存会带来额外的性能开销。另外，volatile 关键字防止指令重排是正常性能增强技术。在条件允许的情况下，使用volatile关键字代替synchronized代码块能节省性能开销。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。&lt;/p&gt;
&lt;p&gt;实际上，自 Ja
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 12. synchronized关键字</title>
    <link href="http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-16T06:56:35.000Z</published>
    <updated>2020-08-28T03:30:24.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-synchronized-同步机制"><a href="#1-synchronized-同步机制" class="headerlink" title="1. synchronized 同步机制"></a>1. synchronized 同步机制</h3><p>synchronized 同步机制是 Java 第一个多线程同步访问共享对象（数据）的机制。显然刚开始的时候Java 同步机制不是很好，因此在 jdk 1.5 提出了一些并发工具类帮助开发者实现比synchronized同步机制更好的并发控制。随着 jdk 版本的不断更新发布，synchronized 关键的性能已经做了很多的优化，在多数情况下，使用 synchronized 关键字能够满足并发控制。</p><hr><h3 id="2-synchronized-关键字"><a href="#2-synchronized-关键字" class="headerlink" title="2. synchronized 关键字"></a>2. synchronized 关键字</h3><p>通过 synchronized 关键字标记 synchronized 代码块。Java 中 synchronized 代码块是在某个对象上做同步（这个对象我们称为锁），所有作用在某个对象的同步代码块同时只能被一个执行，其他线程尝试执行同步代码块时必须等待正在执行同步代码块的线程退出之后才能进入同步代码块。</p><p>synchronized 关键字三种用法：</p><ul><li>作用于实例方法（普通方法）</li><li>作用于静态方法</li><li>作用于代码块</li></ul><p>建议：在需要使用synchronized 关键字时，首先考虑作用于代码块，其次是普通方法，最后是静态方法（代码块 &gt; 普通方法 &gt; 静态方法）。</p><h5 id="2-1-作用于普通方法"><a href="#2-1-作用于普通方法" class="headerlink" title="2.1 作用于普通方法"></a>2.1 作用于普通方法</h5><p>通过使用 synchronized 关键字声明一个同步的普通方法。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyCounter &#123;</span><br><span class="line"></span><br><span class="line">  private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public synchronized void add(int value)&#123;</span><br><span class="line">      this.count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用  声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步实例方法：给当前实例对象加锁，当某个线程进入执行synchronized实例方法时需要获取当前实例对象的锁。因此当synchronized作用于普通方法时，每个实例的同步方法只作用于自己的实例对象。</strong></p><p><strong>只有一个线程可以执行实例同步方法。如果存在多个线程，那么只有一个线程能够同时执行实例同步方法，其他线程必须等待正在执行同步方法的线程执行完毕同步方法，获取到实例锁之后才能执行同步方法。</strong></p><h5 id="2-2-作用于静态方法"><a href="#2-2-作用于静态方法" class="headerlink" title="2.2 作用于静态方法"></a>2.2 作用于静态方法</h5><p>通过使用 synchronized 关键字声明一个同步的静态方法，与普通方法不同的是，静态方法需要通过 static 关键字声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">      count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中通过使用 synchronized 声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p><p><strong>synchronized 同步静态方法：给当前类的 class 对象加锁，当某个线程进入synchronized静态方法时需要获取当前类的class对象的锁。</strong></p><p><strong>因为JVM中每个类只有一个class对象，因此只有一个线程能够同时执行静态同步方法。</strong></p><p>如果一个类声明了多个静态同步方法，只有一个线程可以同时执行这些方法。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">    count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static synchronized void subtract(int value)&#123;</span><br><span class="line">    count -&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于静态同步方法的锁作用于当前类的class对象，所以当多个线程需要执行同一个类中声明的不同的静态同步方法时，同一时间只有一个线程能拿到类的class对象锁，因此只有一个线程能在给定的时间内执行某个静态方法。</p><p>上例中声明了2个静态同步方法，分别是add()方法和subtract()方法，当某个线程执行add()方法时，其他线程只能等待正在执行add()方法执行完毕，并释放类的class对象锁后，才能获取到锁并执行对应的静态同步方法。</p><h5 id="2-3-作用于代码块"><a href="#2-3-作用于代码块" class="headerlink" title="2.3 作用于代码块"></a>2.3 作用于代码块</h5><p>通常情况下，我们不需要同步整个方法，可以在方法内部声明同步代码块，当多个线程执行到同步代码时，使线程的变得同步执行。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (object) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：object 表示接收某个对象作为锁，可以是任意对象，也可以是class对象。</strong> </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void add(int value)&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">       this.count +&#x3D; value;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上例中通过使用synchronized标记这段代码块是同步的，当多个线程需要执行这段代码时，线程会变得同步执行。</p><p>synchronized代码块接收一个对象作为同步锁，只有获取到同步锁才能执行同步代码，这个对象可以是我们自定义的任意对象，包括class对象。通常包括下面三种情况：</p><blockquote><ul><li>this 对象</li><li>class 对象</li><li>其他自定义对象</li></ul></blockquote><h6 id="2-3-1-this对象作为synchronized同步代码块的锁"><a href="#2-3-1-this对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.1 this对象作为synchronized同步代码块的锁"></a>2.3.1 this对象作为synchronized同步代码块的锁</h6><p>当以this对象（表示当前实例对象）作为同步代码块的锁时，只有获取到当前实例对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：如果某个线程正在执行log2()方法中的同步代码块，那么会阻塞其他线程执行log1()方法和log2()方法中的同步代码块（log1方法是普通同步方法，也是以当前实例对象作为锁）。</p><p>以this为对象锁的同步代码块，和普通同步方法的锁对象相同，都是某个实例对象作为同步锁。这种情况下，我们要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-class对象作为synchronized同步代码块的锁"><a href="#2-3-2-class对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 class对象作为synchronized同步代码块的锁"></a>2.3.2 class对象作为synchronized同步代码块的锁</h6><p>当以class对象作为同步代码块的锁时，只有获取到class对象锁的线程才能执行相应的同步代码。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (MyClass.class) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中：当某个线程正在执行log1()方法中的同步代码块或者log2()方法时，会阻塞其他线程执行这两个方法中的任意一个方法。</p><p>以class为对象锁的同步代码块，和静态同步方法的锁对象相同，都是某个类的class对象作为同步锁。这种情况下，我们也要考虑多线程竞争锁对象时造成的不必要的损耗。</p><h6 id="2-3-2-其他对象作为synchronized同步代码块的锁"><a href="#2-3-2-其他对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 其他对象作为synchronized同步代码块的锁"></a>2.3.2 其他对象作为synchronized同步代码块的锁</h6><p>可以指定任意对象作为同步代码块的对象锁，通常情况下我们使用共享资源对象作为指定的对象锁。备注：如果存在多个共享资源，那么一定要注意锁的顺序，有效防止死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    private String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (lock) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以任意自定义对象作为锁时，似乎要比以this对象和class对象作为synchronized同步锁要灵活的多，不过也要根据场景来使用不同的对象作为同步锁。</p><h6 id="2-3-3-Lambda-表达式中的同步代码块"><a href="#2-3-3-Lambda-表达式中的同步代码块" class="headerlink" title="2.3.3 Lambda 表达式中的同步代码块"></a>2.3.3 Lambda 表达式中的同步代码块</h6><p>我们可以在Lambda表达式中声明synchronized同步代码块，其使用方式跟我们上面提到的知识点是一样的。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; s -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F;do something...</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-synchronized-数据可见性"><a href="#3-synchronized-数据可见性" class="headerlink" title="3. synchronized 数据可见性"></a>3. synchronized 数据可见性</h3><p>上一篇博客我们讲<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">《Java Happens Before Guarantee》</a> 时提到过 volatile 关键字和 synchronize 关键字的数据可见性保证。</p><p>这里我们简单回忆一下：没有使用 volatile 关键字或 synchronized 关键字时，当某个线程改变了共享资源的值时对其他线程不可见，原因是不会保证存储于CPU寄存器或者CPU高速缓存的数据重新写回主内存中。</p><p>synchronized 数据可见性：<strong>通过使用synchronized关键字声明同步方法或者同步代码块时，某个线程进入synchronized代码块时，会从主内存中读取最新的数据保存至CPU高速缓存或者CPU寄存器中；当某个线程退出synchronized代码块时，会将CPU寄存器中最新的数据刷回到CPU高速缓存中，再将CPU高速缓存中的最新数据刷新到主内存中，以此保证数据可见性。</strong></p><hr><h3 id="4-synchronized-和指令重排"><a href="#4-synchronized-和指令重排" class="headerlink" title="4. synchronized 和指令重排"></a>4. synchronized 和指令重排</h3><p>上一篇博客中提到过： synchronized 在一定程度上限制了指令重排。</p><p>JVM 和 CPU 为了让程序更快的执行，允许指令重排，通过指令重排让指令并行执行。（前提条件是并行执行的指令没有依赖关系，也就是重排的指令之间不存在依赖关系）</p><p>指令重排在多线程中可能会产生一些问题，比如synchronized同步代码块中写一个变量的代码被重排到synchronized外面。为了防止这种问题产生，synchronized 关键字限制了一些指令重排的发生（与volatile关键字限制指令重排相似）。</p><p>最终的结果是：你可以确定你的代码正确的工作 ———— synchronized限制了指令重排的发生。</p><hr><h3 id="5-什么对象用来做同步对象锁？"><a href="#5-什么对象用来做同步对象锁？" class="headerlink" title="5. 什么对象用来做同步对象锁？"></a>5. 什么对象用来做同步对象锁？</h3><p>正如我们前面多次提到的一样，synchronized 关键字必须作用于某个对象上做同步（通常情况下我们称这个对象为同步对象锁）。</p><p>你可以使用任意对象作为同步对象锁，但是不建议你使用某些String类型的对象和原始基本数据类型的包装类对象作为同步对象锁。因为编译器会优化它们，最终的结果是当你使用他们在不同的同步代码块中作为对象锁时，你以为你使用了不同的对象作为对象锁，实际上只使用了同一个对象作为对象锁。</p><p>出于安全考虑，使用 this 对象或者 new Object() 作为同步对象锁，这种情况下不会被Java编译器或JVM缓存。</p><hr><h3 id="6-synchronized-代码块的限制和替代品"><a href="#6-synchronized-代码块的限制和替代品" class="headerlink" title="6. synchronized 代码块的限制和替代品"></a>6. synchronized 代码块的限制和替代品</h3><p>Java 中的 synchronized代码块存在一些限制，比如同一时间只允许一个线程进入同步代码块。如果多个线程只读取共享数据，不更新共享数据，这是线程安全的，这种情况下我们可以使用 Read / Write Lock 代替 synchronized 代码块。</p><p>你想要多个线程进入同步代码块还是只是一个线程进入同步代码块？我们可以通过使用 Semaphore（计数信号量：限流的作用） 来实现指定数量的线程进入同步代码块(这个点说的同步代码块不是指synchronized代码块)，后面的博客我们来讲解这种实现方式。</p><p>synchronized代码块不会保证等待线程按顺序执行同步代码块。如果我们需要线程按顺序执行同步代码块，可以通过实现 Fairness（公平锁） 来达到这个目的。</p><p>如果只有一个线程修改共享变量，其他的线程只读取共享变量的值，我们可以使用 volatile 关键字，不需要任何同步代码块。</p><hr><h3 id="7-synchronized-性能消耗"><a href="#7-synchronized-性能消耗" class="headerlink" title="7. synchronized 性能消耗"></a>7. synchronized 性能消耗</h3><p>当线程进入和退出 synchronized 代码块时存在一些性能消耗。随着 JDK 版本的发布，性能的消耗变得越来越小，但是使用synchronized代码块还是不可避免地需要付出一些代价。</p><p>如果在循环内不断地进入和退出同步代码块，无疑会让放大性能的损耗。</p><p>尽量避免大的同步代码块，换句话说，只把真正需要的同步操作的代码放进同步代码块，避免其他线程执行不需要同步操作的代码时造成阻塞，同时也能提高执行代码的性能。</p><hr><h3 id="8-synchronized-锁重入"><a href="#8-synchronized-锁重入" class="headerlink" title="8. synchronized 锁重入"></a>8. synchronized 锁重入</h3><p>锁重入：当一个线程进入某个同步代码块时，线程持有同步代码块的同步锁，若同步代码块还调用了具有相同同步锁的同步代码块，线程不需要再次获取锁，可以直接进入相同同步锁的其他同步代码块。</p><p>synchronized 支持锁重入。</p><p>备注：设计多重同步代码块时，需要合理的设计，错误的实现容易导致死锁产生，保持同步代码的锁的顺序一致是一种设计方案。</p><hr><h3 id="9-集群中的-synchronized-代码块"><a href="#9-集群中的-synchronized-代码块" class="headerlink" title="9. 集群中的 synchronized 代码块"></a>9. 集群中的 synchronized 代码块</h3><p>请记住：synchronized 代码块只针对于同一个 JVM 中不同的线程能起到同步作用，如果你拥有相同的 Java 应用程序在多个 JVM 上面运行 ———— 集群，可能导致每个JVM都有一个线程在同时访问共享资源。 </p><p>如果你需要所有的JVM同步访问共享资源，可以使用其他的同步机制，而不是使用 synchronized 代码块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-synchronized-同步机制&quot;&gt;&lt;a href=&quot;#1-synchronized-同步机制&quot; class=&quot;headerlink&quot; title=&quot;1. synchronized 同步机制&quot;&gt;&lt;/a&gt;1. synchronized 同步机制&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 11. Java Happen Before Guarantee</title>
    <link href="http://yoursite.com/2020/08/14/Guarantee/"/>
    <id>http://yoursite.com/2020/08/14/Guarantee/</id>
    <published>2020-08-14T09:11:03.000Z</published>
    <updated>2020-08-26T02:08:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。</p><h3 id="1-指令重排"><a href="#1-指令重排" class="headerlink" title="1. 指令重排"></a>1. 指令重排</h3><p>现代计算机有能力并行执行指令，当一个指令不依赖其他指令时，可能发生指令重排。如下所示：两个指令不相互依赖，计算机可以并行执行这两个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e + f;</span><br></pre></td></tr></table></figure><p>下面这2个指令不会发生指令重排，因为第二个指令依赖第一个指令产生的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a + e;</span><br></pre></td></tr></table></figure><p>指令重排的结果可以让指令在CPU中并行执行，以提高性能。指令重排在JVM和CPU中是被允许的，前提是程序中的语句没有发生改变。指令重排后程序执行的结果必须与没有指令重排时程序执行的结果保持一致。</p><hr><h3 id="2-指令重排在多CPU计算机中的问题"><a href="#2-指令重排在多CPU计算机中的问题" class="headerlink" title="2. 指令重排在多CPU计算机中的问题"></a>2. 指令重排在多CPU计算机中的问题</h3><p>指令重排在多线程、多CPU系统中存在一些挑战。请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int a &#x3D; 0;</span><br><span class="line">private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;有点意思&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>在第一个线程中，a = 1 与 b = 1 两个指令不相互影响，CPU为了提高执行性能，可能并行执行这两个指令，这种情况下， b = 1 指令可能在 a = 1 前面执行，若执行 b = 1 后（假定 a = 1 指令还未执行，此时 a 的值为初始值 0），此时第二个线程正在执行判断条件 a == 0 &amp;&amp; b == 1，那么将会打印数据 ‘有点意思’。为了验证这个问题，我们来循环执行这段代码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-08-13 15:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int a &#x3D; 0;</span><br><span class="line">    private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    System.out.println(&quot;有点意思&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            a &#x3D; 0;</span><br><span class="line">            b &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这段代码有意思，不妨自己试一试。多等待一会，你会发现控制台输出了“有点意思”。</p><hr><h3 id="3-volatile-可见性保证"><a href="#3-volatile-可见性保证" class="headerlink" title="3. volatile 可见性保证"></a>3. volatile 可见性保证</h3><p>Java volatile 关键字提供了读写的可见性保证，当线程读volatile变量时会从主内存中读取数据，当线程修改volatile变量时会将变量的值写回到主内存中。这种同步到主内存的机制保证了变量的值对其他线程可见，这就是volatile可见性保证。</p><h5 id="3-1-volatile-修改数据可见性保证"><a href="#3-1-volatile-修改数据可见性保证" class="headerlink" title="3.1 volatile 修改数据可见性保证"></a>3.1 volatile 修改数据可见性保证</h5><p>当线程修改volatile变量的值时，修改后的值会被同步到主内存中。另外，<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。（请注意这句话，线程所有的变量都会随volatile变量写回到主内存中，不只是volatile变量写回到主内存中）</strong></p><p>请看示例：<br>(1) 首先我们用简单的代码证明使用 volatile 定义的变量的值被某个线程修改后对其他线程可见。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意这里没有使用volatile关键字</span><br><span class="line">    private boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public boolean isKeepRunning() &#123;</span><br><span class="line">        return keepRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;子线程把keepRunning的值改为true</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程中循环尝试获取子线程修改后的keepRunning的值，如果获取到，输出有点意思</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (myRunnable.isKeepRunning()) &#123;</span><br><span class="line">            System.out.println(&quot;有点意思&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你亲手运行了这段代码，你会发现这个程序永远不会输出“有点意思”。现在我们使用volatile定义keepRunning属性，其他代码不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用volatile定义</span><br><span class="line">private volatile boolean keepRunning &#x3D; false;</span><br></pre></td></tr></table></figure><p>使用volatile关键字后，程序循环输出“有点意思”。</p><p><strong>因此我们可以得出结论：volatile 定义的变量的值被某个线程修改后对其他线程可见。</strong></p><p>(2) 现在我们来证明下我们前面说的：<strong>线程里包含的所有变量都会随 volatile 变量写回到主内存中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用了 volatile 关键字的属性</span><br><span class="line">    private volatile boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;未使用 volatile 关键字的属性</span><br><span class="line">    private String strA &#x3D; &quot;A&quot;;</span><br><span class="line">    private String strB &#x3D; &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">        strA &#x3D; &quot;a&quot;;</span><br><span class="line">        strB &#x3D; &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyRunnable&#123;&quot; +</span><br><span class="line">                &quot;keepRunning&#x3D;&quot; + keepRunning +</span><br><span class="line">                &quot;, strA&#x3D;&#39;&quot; + strA + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, strB&#x3D;&#39;&quot; + strB + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(200L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(myRunnable.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序最终输出：MyRunnable{keepRunning=true, strA=’a’, strB=’b’}</p><p>这个结果我们不难看出：子线程修改了keepRunning、strA和strB的值（strA和strB未使用volatile关键字），主线程不仅读取到了keepRunning更新后的值，还读取到了strA和strB更新后的值。所以请记住：<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。</strong></p><h5 id="3-2-volatile-读取数据可见性保证"><a href="#3-2-volatile-读取数据可见性保证" class="headerlink" title="3.2 volatile 读取数据可见性保证"></a>3.2 volatile 读取数据可见性保证</h5><p>当线程读取被 volatile 关键字修饰的变量时，会从主内存中读取。<strong>另外：线程里所有的变量都会随着 volatile 变量读取到CPU缓存或者寄存器中。</strong></p><p>比如下面三个变量，当线程读取strA的值时，会重定向到主内存中读取strA的值，如果strB，strC同样在线程中，也会从主内存中读取strB，strC的值。我们本章3.1节的例子同样能证明此特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valatile String strA &#x3D; &quot;A&quot;;</span><br><span class="line">String strB &#x3D; &quot;B&quot;;</span><br><span class="line">String strC &#x3D; &quot;C&quot;;</span><br></pre></td></tr></table></figure><h5 id="3-3-volatile-happens-before-保证"><a href="#3-3-volatile-happens-before-保证" class="headerlink" title="3.3 volatile happens-before 保证"></a>3.3 volatile happens-before 保证</h5><p>volatile happens-before 保证设置了一些关于volatile变量指令重排的限制（规定）。</p><p><strong>volatile write happens-before guarantee</strong></p><p>volatile write happens-before guarantee: <strong>所有volatile写之前的指令不允许被重排序到volatile指令后面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>示例中 nonVolatileVariableA、nonVolatileVariableB两个变量是没有被volatile修饰的变量，volatileVariableC变量被volatile修饰。volatile write happens-before 保证了前面两个指令不能重排序到第三个指令后面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br></pre></td></tr></table></figure><p>但是示例可能会发生下面这种重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure><p><strong>volatile read happens-before guarantee</strong></p><p>volatile read happens-before guarantee: <strong>所有volatile读之后的指令不允许被重排序到volatile指令前面。</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br></pre></td></tr></table></figure><p>volatile read happens-before 保证了最后两个指令不能重排序到第一个指令前面，也就是不会发生下面这类重排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">volatileVariableC;</span><br></pre></td></tr></table></figure><p>示例可能会发生下面这种重排序的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">nonVolatileVariableA;</span><br></pre></td></tr></table></figure><p><strong>总结volatile happens-before guarantee：所有volatile写之前的指令不允许被重排序到volatile指令后面；所有volatile读之后的指令不允许被重排序到volatile指令前面。（简记：volatile写之前读之后）</strong></p><hr><h3 id="4-synchronized-可见性保证"><a href="#4-synchronized-可见性保证" class="headerlink" title="4. synchronized 可见性保证"></a>4. synchronized 可见性保证</h3><p>synchronized 可见性保证 与 volatile 可见性保证非常相似。</p><h5 id="4-1-synchronized-锁进入可见性保证"><a href="#4-1-synchronized-锁进入可见性保证" class="headerlink" title="4.1 synchronized 锁进入可见性保证"></a>4.1 synchronized 锁进入可见性保证</h5><p>当一个进程进入 synchronized同步代码块（或同步方法），线程内所有可见变量都将从主内存中读取数据。</p><h5 id="4-2-synchronized-锁退出可见性保证"><a href="#4-2-synchronized-锁退出可见性保证" class="headerlink" title="4.2 synchronized 锁退出可见性保证"></a>4.2 synchronized 锁退出可见性保证</h5><p>当一个进程退出 synchronized同步代码块（或同步方法），线程内所有可见变量数据都将写回到主内存中。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line"></span><br><span class="line">    private int numberA &#x3D; 1;</span><br><span class="line">    private int numberB &#x3D; 2;</span><br><span class="line">    private int numberC &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter方法</span><br><span class="line"></span><br><span class="line">    void copyNumber(Demo demo) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">        &#125;</span><br><span class="line">        this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">        this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：当某个线程进入 copyNumber() 方法的 synchronized 代码块时，线程内所有的可见变量都会从主内存中加载数据，也就是说 this 对象的 numberA, numberB也会从主内存中读取数据；退出synchronized 代码块时，线程内所有的可见变量都会写回到主内存中，this 对象的 numberA, numberB修改后的值也会被写回到主内存中。</p><h5 id="4-3-synchronized-happens-before-guarantee"><a href="#4-3-synchronized-happens-before-guarantee" class="headerlink" title="4.3 synchronized happens-before guarantee"></a>4.3 synchronized happens-before guarantee</h5><p>synchronized 提供了两种 happens-before guarantee ：一种与开始进入synchronized 代码块有关；另外一种与退出synchronized 代码块有关。</p><p><strong>synchronized beginning happens-before guarantee :</strong></p><p>我们已经知道，当线程进入 synchronized 代码块时，线程所有可见变量都将从主内存中读取数据。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程进入 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 都将从主内存中读取数据。</p><p>对于上面这个示例，<strong>所有的变量的读取指令都不会重排序到进入 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Number n) &#123;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized end happens-before guarantee :</strong></p><p>我们已经知道，当线程退出 synchronized 代码块时，线程所有可见变量的数据都将写回到主内存中。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程退出 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 的数据都将写回到主内存中。</p><p>对于上面这个示例，<strong>所有的变量的写的指令都不会重排序到退出 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void copyNumber(Number n) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 synchronized happens-before时，我总感觉把它总结的太复杂了，你可以简单的理解为 synchronized 不与其他指令发生指令重排，因为 synchronized happens-before 保证了线程在读取数据和写回数据时都会限制指令重排的发生。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 10. Java内存模型</title>
    <link href="http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-12T08:39:30.000Z</published>
    <updated>2020-08-26T02:08:25.081Z</updated>
    
    <content type="html"><![CDATA[<p>Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。</p><p>如果你想要设计出正确的并发程序，那么理解JMM是非常重要的。Java内存模型会提到一个线程怎样获取被别的线程修改后的共享变量的值；也会提到当有必要的时候，怎样让多个线程顺序的访问共享变量。</p><p>注意：原来的Java内存模型进行过修订，从Java 1.5 到 Java 14+，这个版本的内存模型仍然适用。</p><h3 id="1-Java-Memory-Model"><a href="#1-Java-Memory-Model" class="headerlink" title="1. Java Memory Model"></a>1. Java Memory Model</h3><p>在JVM中，JMM包含两种内存模型：Thread Stacks(线程栈)、Heap(堆内存)。如图所示</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt></div></p><p><strong>内存模型</strong></p><ol><li>每个在JVM中运行的线程都有自己的线程栈。这个线程栈包含线程中调用的方法信息和程序计数器（当前程序所执行的字节码的行号指示器）。</li><li>在开始执行某个方法的时候，会在线程栈中存储方法内所有的local variable(局部变量)，局部变量只对创建它的线程可见，其他线程无法访问。即使两个线程同时执行同一个方法，这两个线程都会创建局部变量保存至属于自己的线程栈中，线程只能访问自己线程栈中的数据。</li><li>所有基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量都保存在线程栈中，并且对其他线程不可见。一个线程可能拷贝一个基本数据类型变量给其他线程，但不会共享原始的局部变量（这里是值传递）。</li><li>堆内存中包含Java应用程序中所有对象的创建，不论哪个线程创建的对象都存储在堆内存中，并且包含基础数据类型的包装类也存储于堆内存中。对象的创建不管是作为局部变量、还是作为对象的成员，都始终保存于堆内存中。</li></ol><p>如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt></div></p><ol><li>一个本地变量可能是一个基本数据类型，这种情况下本地变量将完全保存在线程栈中。</li><li>一个本地变量可能引用一个对象，这种情况下对象的引用保存在线程栈中，对象保存在堆内存中。</li><li>一个对象可能包含一些方法，方法包含一些本地变量。本地变量保存在线程栈中，方法保存随对象保存在堆内存中。</li><li>一个对象的成员变量随对象保存在堆内存中，不论这个成员变量是基本数据类型还是引用其他对象，成员变量都保存在堆内存中。</li><li>静态变量随 class(类) 保存在堆内存中。</li></ol><p>堆内存的对象可以被任何具有该对象引用的线程访问。</p><hr><h3 id="2-计算机硬件内存结构"><a href="#2-计算机硬件内存结构" class="headerlink" title="2. 计算机硬件内存结构"></a>2. 计算机硬件内存结构</h3><p>现代硬件内存结构与Java内存模型有些不同，为了更好的理解Java内存模型，了解硬件内存结果是很重要的。</p><p>通常的硬件内存结构。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt></div></p><p>现代计算机通常拥有2个以上的CPU，有些CPU有多个内核。重点是多CPU计算机可以同时执行多个线程。当你的Java应用程序是多线程应用程序，在你的应用程序中可能同时出现每个CPU都在执行线程的情况。</p><ol><li>每个CPU有一组（注意是一组，多个）CPU寄存器，CPU操作寄存器的速度比操作主内存更快，这也意味着CPU访问寄存器的速度比访问内存更快。</li><li>每个CPU也可能有一个CPU缓存（CPU Cache Memory），事实上，每个CPU可能有一定数量的CPU缓存。CPU访问CPU缓存的速度比访问内存的速度快，通常情况下CPU访问CPU缓存的速度没有访问寄存器的速度快。因此你可以认为CPU访问内存的顺序依次是：寄存器 &gt; CPU缓存 &gt; 主内存。另外，一些CPU可能会有多级CPU缓存（L1,L2,L3等）。</li><li>每个计算机都包含一个主内存，主内存的容量比CPU缓存的容量更大。</li><li>通常情况下，CPU访问内存会读取主内存中的一些数据拷贝至CPU缓存，甚至拷贝至CPU内部的寄存器，然后可以在CPU缓存或者寄存器操作数据。当CPU需要写回数据至主内存中时，它首先会将寄存器中的结果值提交至CPU缓存中，然后再将CPU缓存的值提交至主内存中。</li><li>当CPU需要将CPU缓存的数据提交至主内存中时，CPU缓存的数据将会被写回主内存中。</li></ol><h5 id="2-1-桥接Java内存模型和计算机硬件内存结构"><a href="#2-1-桥接Java内存模型和计算机硬件内存结构" class="headerlink" title="2.1 桥接Java内存模型和计算机硬件内存结构"></a>2.1 桥接Java内存模型和计算机硬件内存结构</h5><p>如您所知，Java内存模型与现代计算机硬件内存结构不同，硬件内存结构没有区分线程栈内存和堆内存。也就是说：线程栈内存和堆内存可以都存在于硬件的主内存、CPU高速缓存、寄存器中。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt></div></p><p>当Java对象和变量可以保存在不同的计算机内存区域中，这就可能会导致一些问题的发生。主要的两个问题是：</p><ol><li>当线程更新共享数据时，共享数据在多个线程中的可见性。</li><li>当多个线程读、写、检查共享数据时，产生竞争条件。</li></ol><p>下面我们来解释这2个问题</p><h5 id="2-2-共享数据的可见性"><a href="#2-2-共享数据的可见性" class="headerlink" title="2.2. 共享数据的可见性"></a>2.2. 共享数据的可见性</h5><p>如果多个线程共享一个对象，并且代码中没有使用 volatile 关键字和 synchronized 同步代码块。当一个线程更新这个共享对象后，修改后的对象的值可能对其他线程不可见。</p><p>想象一下，当一个共享对象保存在主内存中时，一个CPU正在执行某个线程时把主内存中共享对象缓存至CPU高速缓存上，另外一个CPU也把共享对象缓存到CPU高速缓存中，其中一个CPU在CPU高速缓存中更新了共享数据并把共享数据写回到主内存中，此时另外一个CPU的CPU高速缓存还是旧的共享资源数据。</p><p>下图中解释了上面这种场景。下图左边的正在执行某个线程的CPU将 obj.count 加载到CPU高速缓存中，同时将 obj.count 的值改为 2。左边这个线程对 obj.count 的值进行修改后，对执行其他线程的CPU并不可见。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 volatile 关键字。这个关键字用于修饰某个成员变量，当线程要读取这个变量的值时，会从读取主内存中读取变量的值，并且每次修改变量的值时都会重新写回到主内存中。（后面会有文章详细介绍 volatile 关键字）</p><h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>如果多个线程共享一个对象，并且有多个线程修改共享变量，可能产生竞争条件。</p><p>想象一下，如果一个线程A从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，同时线程B也从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，线程A和线程B同时对 obj.count 做自增操作，也就是说 obj.count 同时被自增2次，在每个CPU里面自增一次。如果变量 obj.count 的同步执行递增2次，那么这个变量写回主内存时值应该是 obj.count + 2，然而这2次递增没有同步执行，实际上是在线程A和线程B并行执行，最终线程A和线程B把 obj.count 的值写回数据到主内存后，实际值变成了 obj.count + 1。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 synchronized 锁。synchronized 可以分别用于 代码块、普通方法、静态方法。后面有文章介绍 synchronized，这里不做过多描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。&lt;/p&gt;
&lt;p&gt;如果你想要设计出正确的并发程序，那么理解JMM是非常重
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 9. 线程安全和不变性</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</id>
    <published>2020-08-12T07:50:16.000Z</published>
    <updated>2020-08-26T02:08:24.984Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。</p><p>下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ImmutableValue&#123;</span><br><span class="line"></span><br><span class="line">  private int value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue(int value)&#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 ImmutableValue 提供了一个传入指定 value 的构造函数，一旦对象被创建，该对象没有提供任何修改value值的方法，所以value的值无法被修改。</p><h3 id="特别注意：对象引用不是线程安全的"><a href="#特别注意：对象引用不是线程安全的" class="headerlink" title="特别注意：对象引用不是线程安全的"></a>特别注意：对象引用不是线程安全的</h3><p>需要注意的是，当一个对象不可变时对象本身是线程安全的，但是对象的引用可能不是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  private ImmutableValue currentValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue getImmutableValue()&#123;</span><br><span class="line">    return currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setImmutableValue(ImmutableValue newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void add(int newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; new ImmutableValue(currentValue.getValue() + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator 类引用了一个 ImmutableValue 对象，请注意它可以通过 setImmutableValue() 方法和 add() 方法改变了 ImmutableValue 对象的引用。换句话说，即使 ImmutableValue 对象是不可变的，但它也是非线程安全的。ImmutableValue 类是线程安全的，但对象的引用是非线程安全的。<strong>所以特别注意：对象的引用可能是非线程安全的。</strong> 可以通过给 setImmutableValue() 方法和 add() 方法加锁（使用 synchronized 关键字等）保证线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。&lt;/p&gt;
&lt;p&gt;下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 8. 线程安全和共享资源</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</id>
    <published>2020-08-12T06:56:11.000Z</published>
    <updated>2020-08-26T02:08:25.092Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。</p><h3 id="1-Local-variables-本地变量-局部变量"><a href="#1-Local-variables-本地变量-局部变量" class="headerlink" title="1. Local variables (本地变量/局部变量)"></a>1. Local variables (本地变量/局部变量)</h3><p>局部变量保存在每个线程独有的线程栈中，因此局部变量在线程之间是不共享的。也就是说所有的局部变量都是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void someMethod()&#123;</span><br><span class="line">    long threadSafeInt &#x3D; 0;</span><br><span class="line">    threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-Local-Object-References-本地对象引用-局部对象引用"><a href="#2-Local-Object-References-本地对象引用-局部对象引用" class="headerlink" title="2. Local Object References (本地对象引用/局部对象引用)"></a>2. Local Object References (本地对象引用/局部对象引用)</h3><p>本地对象引用有所不同，引用本身是不共享的，同样也是保存在线程独有的线程栈中，线程之间不共享引用。但是引用的对象不是保存在线程栈中，而是保存在主内存堆中，理论上讲所有的线程都能够访问内存堆中存储的对象（但是要有对象的引用）。</p><p>如果一个对象创建之后没有离开创建它的方法，那么是线程安全的。事实上传递这个对象的引用给其他的方法，只要这个对象的引用没有传递给其他的线程，那么这个对象都不会成为共享对象，始终是线程安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void methodOne()&#123;</span><br><span class="line">  LocalObject localObject &#x3D; new LocalObject();</span><br><span class="line">  methodTwo(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo(LocalObject localObject)&#123;</span><br><span class="line">  localObject.setValue(&quot;value&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中：对象 localObject 在 methodOne() 方法中被创建，然后传递给 methodTwo()，localObject 没有传递给其他线程; 每个线程执行 methodOne() 时会都创建一个新的 LocalObject 对象，且 LocalObject 对象的引用都保存在各自的线程栈中，因此是 methodOne() 线程安全的，尽管 LocalObject 存在多个实例对象，但使用它们是线程安全的。</p><p><strong>但有一种场景例外：</strong> 当某个方法将 localObject 对象的引用作为参数传递给了其他线程，那么可能会造成线程不安全。</p><h3 id="3-Object-Member-Variables-对象成员变量"><a href="#3-Object-Member-Variables-对象成员变量" class="headerlink" title="3. Object Member Variables (对象成员变量)"></a>3. Object Member Variables (对象成员变量)</h3><p>对象成员变量随对象保存在堆内存中。因此当两个线程调用了某个方法，这个方法引用了同一个对象并修改了这个对象的成员变量时，那么这个方法时线程不安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public add(String text)&#123;</span><br><span class="line">        this.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程同时调用同一个 NotThreadSafe 对象的 add() 方法时，会导致竞争条件发生。 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotThreadSafe sharedInstance &#x3D; new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"></span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance &#x3D; instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    this.instance.add(&quot;some text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意有 2 个 MyRunnable 对象共享了 sharedInstance 对象，因此当他们同时调用 sharedInstance.add() 方法时，会发生竞争条件。</p><p>然而，当 2 个线程同时调用不对对象的 add() 方法时，不会产生竞争条件。示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br></pre></td></tr></table></figure><h3 id="4-线程安全规则"><a href="#4-线程安全规则" class="headerlink" title="4. 线程安全规则"></a>4. 线程安全规则</h3><p>当你想确认你的代码访问某些资源的时候是否是线程安全的，你可以使用下面这个规则：</p><blockquote><p><strong>如果资源的创建、使用和销毁都没有离开某个方法，并且没有分享给其他线程，那么使用这个资源是线程安全的。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。&lt;/p&gt;
&lt;h3 id=&quot;1-Local-variables-本地变量-局部变
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 7. 竞争条件和临界区</title>
    <link href="http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</id>
    <published>2020-08-12T06:41:07.000Z</published>
    <updated>2020-08-26T02:08:25.013Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 6. 创建和开始Java线程</title>
    <link href="http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-12T02:32:54.000Z</published>
    <updated>2020-08-26T02:08:25.034Z</updated>
    
    <content type="html"><![CDATA[<p>一个Java线程就像一个可以执行你的Java代码的虚拟CPU。</p><p>当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。</p><p>Java 线程都是对象，就像其他的Java对象一样，线程对象都是 java.lang.Tread 的实例或者其子类的实例。</p><h3 id="1-创建和开始线程"><a href="#1-创建和开始线程" class="headerlink" title="1 创建和开始线程"></a>1 创建和开始线程</h3><p>你可以像这样创建一个线程对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread myThread &#x3D; new Thread();</span><br></pre></td></tr></table></figure><p>你可以像这样开始一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><p>创建线程的几种方式：</p><blockquote><ul><li>继承 java.lang.Thread 类并重写 run() 方法。</li><li>实现 java.lang.Runnable 接口并重写 run() 方法。</li><li>实现 java.util.concurrent.Callable 接口并重写 call() 方法。（备注：这种实现方式后面有 JUC 专题）</li></ul></blockquote><hr><h3 id="2-Thread-子类"><a href="#2-Thread-子类" class="headerlink" title="2 Thread 子类"></a>2 Thread 子类</h3><p>继承 java.lang.Thread 类并重写 run() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyThread myThread &#x3D; new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start() 方法不会等线程执行完 run()方法，run() 方法将会由其他不同的CPU执行。</p><hr><h3 id="3-实现-Runnable-接口"><a href="#3-实现-Runnable-接口" class="headerlink" title="3 实现 Runnable 接口"></a>3 实现 Runnable 接口</h3><p>第二种创建线程的方式是实现 java.lang.Runnable 接口并重写该接口的 run() 方法。一个 Java 对象实现 Runnable 接口 可以被Java Thread 类执行。</p><p>Runnable 接口由 JDK 提供，仅有一个 run 方法，是一个函数式接口。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 的方式有3种：</p><blockquote><ol><li>创建一个 Java 类实现 Runnable 接口</li><li>创建一个 Java 匿名类实现 Runnable 接口</li><li>使用 Java 8 Lambda 表达式实现 Runnable 接口</li></ol></blockquote><h5 id="3-1-创建一个-Java-类实现-Runnable-接口"><a href="#3-1-创建一个-Java-类实现-Runnable-接口" class="headerlink" title="3.1 创建一个 Java 类实现 Runnable 接口"></a>3.1 创建一个 Java 类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-创建一个-Java-匿名类实现-Runnable-接口"><a href="#3-2-创建一个-Java-匿名类实现-Runnable-接口" class="headerlink" title="3.2 创建一个 Java 匿名类实现 Runnable 接口"></a>3.2 创建一个 Java 匿名类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable &#x3D; new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口"><a href="#3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口" class="headerlink" title="3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口"></a>3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable &#x3D; () -&gt; &#123; System.out.println(&quot;Lambda Runnable running&quot;); &#125;;</span><br></pre></td></tr></table></figure><h5 id="3-4-开启一个实现了-Runnable-接口的线程"><a href="#3-4-开启一个实现了-Runnable-接口的线程" class="headerlink" title="3.4 开启一个实现了 Runnable 接口的线程"></a>3.4 开启一个实现了 Runnable 接口的线程</h5><p>java.lang.Thread的包含传入一个Runnable接口的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;or an anonymous class, or lambda...</span><br><span class="line">    Runnable runnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;executed by a thread</span><br><span class="line">    Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-使用哪种方式创建线程更好"><a href="#4-使用哪种方式创建线程更好" class="headerlink" title="4. 使用哪种方式创建线程更好 ?"></a>4. 使用哪种方式创建线程更好 ?</h3><p>关于继承Thread和实现Runnable接口，没有明确的规定用哪种方式创建线程更好，两种方式都可以让线程运行。我更倾向于使用实现Runnable接口的方式，后面我还们会了解到另外一种创建线程的方式，通过线程池创建线程的方式更加合理。</p><h3 id="5-常见陷阱：调用-run-代替-start"><a href="#5-常见陷阱：调用-run-代替-start" class="headerlink" title="5. 常见陷阱：调用 run() 代替 start()"></a>5. 常见陷阱：调用 run() 代替 start()</h3><p>通过调用start()，程序会告诉 CPU 线程已准备就绪，等待CPU执行 run() 方法。若直接调用 run() 方法则不会开启一个新的线程去执行 run() 方法，而是在原来的线程中去执行 run() 方法，所以当我们需要一个新的线程去执行 run() 方法中的代码时，应该调用 start() 方法启动一个线程，而不是直接调用 run() 方法。</p><h3 id="6-线程名（Thread-Names）"><a href="#6-线程名（Thread-Names）" class="headerlink" title="6. 线程名（Thread Names）"></a>6. 线程名（Thread Names）</h3><p>创建线程的时候可以指定线程名称，详见 java.lang.Thread API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable myRunnable &#x3D; () -&gt; System.out.println(&quot;Thread name is &quot; + Thread.currantThread().getName());</span><br><span class="line">    </span><br><span class="line">    new Thread(myRunnable, &quot;Thread One&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console out: Thread name is Thread One</span><br></pre></td></tr></table></figure><h3 id="7-Thread-currentThread"><a href="#7-Thread-currentThread" class="headerlink" title="7. Thread.currentThread()"></a>7. Thread.currentThread()</h3><p>通过 Thread.currentThread() 获取当前正在执行的线程对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread currentThread &#x3D; Thread.currentThread();</span><br></pre></td></tr></table></figure><h3 id="8-暂停线程"><a href="#8-暂停线程" class="headerlink" title="8. 暂停线程"></a>8. 暂停线程</h3><p>可以通过 Thread.sheep() 让线程睡眠指定毫秒数。这里不建议使用 thread.suspend() 方法，该方法和 Thread 类的 resume()、stop()、destroy() 都是 JDK 标注废弃方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： Thread.sheep() 方法不会释放CPU资源，如果设置锁的话也不会释放锁资源，只是让线程睡眠指定毫秒数。与 Object 类的 wait() 方法不同， wait() 方法主要用于线程通信，且 wait() 方法会释放锁资源。</p><h3 id="9-停止一个线程"><a href="#9-停止一个线程" class="headerlink" title="9. 停止一个线程"></a>9. 停止一个线程</h3><p>不建议使用 Thread 类提供的 stop() 方法去停止一个线程，stop() 方法会暴力停止一个线程，对程序不友好，可以通过更友好的方式停止一个线程。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private boolean doStop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.doStop &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized boolean keepRunning() &#123;</span><br><span class="line">        return this.doStop &#x3D;&#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(keepRunning()) &#123;</span><br><span class="line">            &#x2F;&#x2F; keep doing what this thread should do.</span><br><span class="line">            System.out.println(&quot;Running&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3L * 1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 doStop() 方法和 keepRunning() 方法使用了 synchronized 关键字，后面会详细讲解 synchronized 关键字的作用，这里不做过多描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnableMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10L * 1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例通过设置一个标识，主线程里面启动子线程，然后主线程睡眠10秒钟后调用 doStop() 方法，实现在主线程中停止子线程的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个Java线程就像一个可以执行你的Java代码的虚拟CPU。&lt;/p&gt;
&lt;p&gt;当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。&lt;/p&gt;
&lt;p&gt;Java 线程都是对象，就像其他的Java对
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 5. 并发和并行</title>
    <link href="http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</id>
    <published>2020-08-11T02:23:36.000Z</published>
    <updated>2020-08-26T02:08:24.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Concurrency-并发"><a href="#1-Concurrency-并发" class="headerlink" title="1. Concurrency 并发"></a>1. Concurrency 并发</h3><p>应用程序中（Application）同时进行一个以上的任务（Task）。对于单CPU的电脑而言，不可能同时进行一个以上的任务，CPU通过交换的执行任务直到任务都被执行完成。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" alt></div></p><hr><h3 id="2-Parallelism-并行"><a href="#2-Parallelism-并行" class="headerlink" title="2. Parallelism 并行"></a>2. Parallelism 并行</h3><p>应用程序中的任务（Task）被切割成多个子任务（SubTask）同时执行。实现并行你的应用程序必须有多个线程在同时执行，并且至少有一个任务在执行（Task）。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" alt></div></p><hr><h3 id="3-Concurrency-vs-Parallelism"><a href="#3-Concurrency-vs-Parallelism" class="headerlink" title="3. Concurrency vs. Parallelism"></a>3. Concurrency vs. Parallelism</h3><ul><li>并发是一个应用程序同时执行多个任务。</li><li>并行是一个应用程序处理单个任务，将单个任务切割成多个子任务并行执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Concurrency-并发&quot;&gt;&lt;a href=&quot;#1-Concurrency-并发&quot; class=&quot;headerlink&quot; title=&quot;1. Concurrency 并发&quot;&gt;&lt;/a&gt;1. Concurrency 并发&lt;/h3&gt;&lt;p&gt;应用程序中（Applic
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 4. 相同线程</title>
    <link href="http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-11T01:02:36.000Z</published>
    <updated>2020-08-26T02:08:25.063Z</updated>
    
    <content type="html"><![CDATA[<p>相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。</p><p>一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。</p><h3 id="1-为什么用单线程系统？"><a href="#1-为什么用单线程系统？" class="headerlink" title="1. 为什么用单线程系统？"></a>1. 为什么用单线程系统？</h3><p>你可能会想为什么每个人都能设计出单线程系统。单线程系统受欢迎的原因是因为单线程系统的并发模型比多线程系统的并发模型更加简单。单线程系统线程之间不共享任何状态（对象/数据），单线程系统可以不使用任何并发数据结构，并且更好地利用CPU和CPU缓存。</p><p>遗憾的是，单线程系统不能很好的利用现代CPU，现代CPU通常情况下拥有多个CPU内核，每个CPU内核的功能就像一个独立的单核CPU，一个单线程系统只能利用CPU中的一个内核，模型如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" alt></div></p><hr><h3 id="2-相同线程（单线程系统的扩展）"><a href="#2-相同线程（单线程系统的扩展）" class="headerlink" title="2. 相同线程（单线程系统的扩展）"></a>2. 相同线程（单线程系统的扩展）</h3><p>为了充分的利用CPU的内核，一个单线程系统可以扩展到利用整个计算机。</p><h5 id="一个CPU内核执行一个线程"><a href="#一个CPU内核执行一个线程" class="headerlink" title="一个CPU内核执行一个线程"></a>一个CPU内核执行一个线程</h5><p>相同线程系统通常让计算机中每个CPU内核执行一个线程，如果一个计算机有4个CPU，每个CPU拥有4个CPU内核，让每个CPU内核执行一个线程的示例如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" alt></div></p><hr><h3 id="3-不共享状态（数据）"><a href="#3-不共享状态（数据）" class="headerlink" title="3. 不共享状态（数据）"></a>3. 不共享状态（数据）</h3><p>一个相同线程系统与传统的多线程系统相似，因为一个相同线程系统有多个线程同时执行，但是两者有一些区别。</p><p>相同线程系统与多线程系统不同的是相同线程系统不共享状态（或不共享数据），当产生并发访问时不共享数据，没有并发数据结构等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" alt></div></p><p>不共享数据让相同线程系统看上去像单线程系统。因为相同线程系统可以包含多个单线程，因此取名相同线程系统更加合理。</p><p>相同线程系统基本含义是进程同时包含处理多个相同的线程，在相同线程系统中并发时没有线程共享数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。&lt;/p&gt;
&lt;p&gt;一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 3. 并发模型</title>
    <link href="http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-09T09:10:45.000Z</published>
    <updated>2020-09-01T09:56:58.263Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。</p><h3 id="1-并发模型与分布式系统相似"><a href="#1-并发模型与分布式系统相似" class="headerlink" title="1. 并发模型与分布式系统相似"></a>1. 并发模型与分布式系统相似</h3><blockquote><ul><li>在一个并发系统中，不同的线程之间相互通信。</li><li>在一个分布式系统中，不同的进程之间相互通信。</li></ul></blockquote><p>分布式系统比并发系统面临更多的挑战，比如可能面临网络异常、远程主机或进程停止；并发系统理论上也存在相似的问题，比如CPU异常，内存或硬盘损坏等情况，这种异常的概率相对较小，但实际上是存在的。</p><hr><h3 id="2-共享状态-vs-隔离状态"><a href="#2-共享状态-vs-隔离状态" class="headerlink" title="2. 共享状态 vs 隔离状态"></a>2. 共享状态 vs 隔离状态</h3><h5 id="2-1-共享状态"><a href="#2-1-共享状态" class="headerlink" title="2.1 共享状态"></a>2.1 共享状态</h5><p>共享状态意味着同一系统的多个线程之间共享一些状态（一般指数据，共享一个或多个对象的数据）。当线程共享状态时，容易引发一些并发问题，比如死锁，竞争条件等等，这取决于线程怎样地使用和访问共享数据等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" alt></div></p><h5 id="2-2-隔离状态"><a href="#2-2-隔离状态" class="headerlink" title="2.2 隔离状态"></a>2.2 隔离状态</h5><p>隔离状态意味着同一系统的多个线程之间不共享状态。如果不同的线程之间需要进行通信，可以通过交换不可变对象、或者使用复制的对象进行通信。当多个线程之间不存在共享状态（或共享数据），就可以避免最常见的并发问题。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" alt></div></p><p><strong>备注</strong><br>隔离状态通常情况下可以让代码实现更加简单，并且可以不用担心发生并发访问的问题，避免一些常见的并发问题。在一些特殊情况下，使用分离状态并发设计可能存在更大的挑战。</p><hr><h3 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3. 并发模型"></a>3. 并发模型</h3><h5 id="3-1-Parallel-Workers-并行工作者并发模式"><a href="#3-1-Parallel-Workers-并行工作者并发模式" class="headerlink" title="3.1 Parallel Workers (并行工作者并发模式)"></a>3.1 Parallel Workers (并行工作者并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt></div></p><p><strong>并行工作者模式：</strong><br>传入的工作被分配到不同的工作者去执行，每个工作者执行完整的工作流程。工作者在不同的线程中执行。并行工作者并发模型在 Java 应用程序中很常见，JUC包中很多并发工具类的设计都采用了这种并发模型。 </p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><blockquote><ul><li>非常容易理解：如果要提高并行效率只需要增加更多的工作者</li></ul></blockquote><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><blockquote><ul><li>存在共享状态时实现更加复杂</li><li>工作顺序不固定</li></ul></blockquote><p><strong>缺点1：存在共享状态时实现更加复杂</strong><br>并行工作者模式不同线程存在共享数据时，实现变得更加复杂。共享线程通常需要访问共享对象，不论共享对象存在于内存中还是数据库中。如下图所示<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt></div></p><p>某些共享状态是工作队列中的通信机制，也有些共享状态是业务数据、数据缓存、数据库连接池等等。</p><p>并行工作者并发模式的线程之间存在共享数据时会更加复杂，当一个线程修改了共享数据变量时，需要确保其他线程读取的共享数据变量是最新的（线程修改了共享数据变量应该把数据保存至主内存中，而不是保存至线程独有的CPU高速缓存栈中）。线程需要避免死锁、竞争条件、或者其他共享状态的并发问题。</p><p>当某个线程正在访问共享数据结构时，其他线程会等待正在访问共享数据结构的线程执行完毕，造成阻塞。这可能导致这些线程在竞争共享数据资源，高的竞争条件会导致许多线程访问共享数据时串行执行。</p><p>现代非阻塞并发算法可能降低竞争并且提高性能，但是非阻塞并发算法很难实现。</p><p>持久性数据结构是另一种选择，当持久性数据结构被修改时，他总是保持修改前版本。当多个线程引用了某个持久性数据结构，其中某个线程对持久性数据结构做了修改时，这个修改了持久性数据结构的线程获得了最新的引用数据，而其他的线程保持原来的引用的数据。在共享数据被修改时，持久性数据结构的方式是一个很好的解决方案。</p><blockquote><p>关于持久性数据结构的举例：</p><ul><li>当某个线程给ArrayList添加一个元素时，新添加的元素对其他线程并不可见</li><li>也存在某些缺陷，比如LinkedList， 由于LinkedList是链表的数据结构，链表的每个元素都是一个单独的对象，这种数据结构分布在内存块中的各个地方。然而现代CPU在访问顺序的数据结构时要快的多，比如ArrayList，所以CPU在访问ArrayList时能够表现出更加卓越的性能。CPU能够一次加载一个较大的数组类型的数据结构至高速缓存中，但是无法将一个元素分布至内存各个地方的链表（ListedList）加载到CPU的高速缓存中。</li></ul></blockquote><p><strong>无状态工作者</strong><br>共享数据可以被系统中某个线程修改，其他线程在每次访问共享数据时必须重新读取最新的内存中的数据，以保证线程在执行中时拿到的是最新的内存副本，一个线程不始终保持自己线程独有的CPU高速缓存数据的状态称为无状态。</p><p><strong>缺点2：工作顺序不固定</strong><br>工作A可能被分配给线程A执行，也可能被分配给线程B执行，因此并行工作者模式的执行顺序不是固定的。</p><h5 id="3-2-Assembly-Line-流水线并发模式"><a href="#3-2-Assembly-Line-流水线并发模式" class="headerlink" title="3.2 Assembly Line (流水线并发模式)"></a>3.2 Assembly Line (流水线并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt></div></p><p>这种模式就像工厂中流水线的工人一样，每个工作者只负责整个生产车间的一部分工作，每个工作者负责的这部分工作完成之后会传递给下一个工作者。</p><p>每个工作者在自己的线程内执行，不存在共享状态，流水线并发模式也被称为无共享并发模式。</p><p>流水线并发模式经常在非阻塞IO (NIO) 被设计使用。当一个工作者开始IO操作，其他工作者不需要等待IO操作结束。IO操作很慢，所以等待IO操作完成会浪费大量CPU时间，当IO操作完成时，IO操作的结果会被传递给其他工作者。</p><p>关于NIO， 在IO操作确定工人之间的界限。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt></div></p><p>实际上，工作模式可能不只一条流水线，大多数系统可以设计多条流水线。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt></div></p><p>工作可能并定向到一个工作者进行并行处理。比如一个工作可能同时被分配到工作执行器和日志执行器中执行。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt></div></p><p>流水线并发模式也被称为反应系统或者事件响应系统。</p><p><strong>优点：</strong></p><blockquote><ul><li>不共享状态</li><li>可以顺序执行工作</li></ul></blockquote><p><strong>缺点</strong></p><blockquote><ul><li>作业的执行分散在各个工人</li><li>调试更加复杂</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。&lt;/p&gt;
&lt;h3 id=&quot;1-并发模型与分布式系统相似&quot;&gt;&lt;a href=&quot;#1-并发模型与分布式系统相似&quot; 
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 2. 使用多线程的成本</title>
    <link href="http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/</id>
    <published>2020-08-09T08:31:10.000Z</published>
    <updated>2020-08-26T02:08:25.054Z</updated>
    
    <content type="html"><![CDATA[<p>从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不是靠猜想。</p><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><blockquote><ul><li>更复杂的程序设计</li><li>上下文切换的开销</li></ul></blockquote><p><strong>更复杂的程序设计</strong> </p><blockquote><ul><li>在某些情况下，一个多线程应用程序比单线程应用程序更加简单，但是在某些特殊情况下要更加复杂。</li><li>在多个线程引用了同一个共享变量的情况下，多线程应用程序比单线程应用程序使用起来更加复杂，因为需要考虑线程安全问题，不正确的线程同步问题出现的问题往往防不胜防。</li></ul></blockquote><p><strong>上下文切换的开销</strong> </p><blockquote><ul><li>当一个CPU从当前线程切换的执行另外一个线程时，CPU需要保存当前线程的本地数据以及程序指针等等，再有另外一个线程切换到当前线程时，需要重新读取本地数据和程序指针等，这个交换的执行过程叫做上下文切换。</li><li>上下文切换的成本并不便宜。</li></ul></blockquote><p><strong>减少上下文切换</strong></p><blockquote><ul><li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁。</li><li>CAS算法：Java的atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程：避免创建不需要的线程。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 1. 并发和多线程</title>
    <link href="http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/"/>
    <id>http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/</id>
    <published>2020-08-09T06:19:56.000Z</published>
    <updated>2020-08-26T02:08:25.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-并发和多线程"><a href="#1-并发和多线程" class="headerlink" title="1. 并发和多线程"></a>1. 并发和多线程</h3><p><strong>并发编程</strong><br>并发编程涵盖了多线程技术在内，指并发执行任务时可能出现的问题，使用的多线程技术，以及解决方案。</p><p><strong>多线程：</strong><br>同一个应用程序中，多个线程同时执行。</p><p><strong>多线程应用程序:</strong><br>多线程应用程序是一个多 CPU 同时执行不同的线程的应用程序。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" alt></div></p><p>一个线程不等于一个CPU，通常情况下一个CPU在不同时间段交换执行不同的线程，不同的CPU同时执行不同的线程。如图：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" alt></div></p><hr><h3 id="2-为什么使用多线程"><a href="#2-为什么使用多线程" class="headerlink" title="2. 为什么使用多线程"></a>2. 为什么使用多线程</h3><blockquote><ul><li>更好的利用单 CPU 资源</li><li>更好的利用多 CPU 或 CPU 内核</li><li>更快速的响应-提高用户体验</li><li>更公平的响应-提高用户体验</li></ul></blockquote><p><strong>更好的利用单 CPU 资源</strong><br>单个CPU通过分配CPU时间片达到交换地执行不同线程的目的，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒。</p><p><strong>更好的利用多 CPU 或 CPU 内核</strong><br>创建多个线程，充分地利用多个CPU同时执行不同的线程，加快程序执行速度，充分利用多CPU资源。</p><p><strong>更快速的响应-提高用户体验</strong><br>充分的利用单CPU资源和多CPU资源都能够加快程序的执行速度，以提高用户体验</p><p><strong>更公平的响应-提高用户体验</strong><br>不同的线程在单CPU中分配CPU时间片交换执行，在某些特定情况下以一种更加公平的方式执行不同的线程。比如某个线程需要调用网络资源或者其他的操作需要长时间占用CPU，导致许多线程需要等待CPU去执行，造成阻塞。</p><hr><h3 id="3-使用多线程不一定更快"><a href="#3-使用多线程不一定更快" class="headerlink" title="3. 使用多线程不一定更快"></a>3. 使用多线程不一定更快</h3><p>由于线程的创建和上下文的切换的开销，多线程的执行效率不一定比单线程的执行效率更好。</p><p><strong>线程创建的方式</strong></p><blockquote><ul><li>继承Thread类，重写 run() 方法</li><li>实现Runnable接口，重写 run() 方法</li><li>实现Callable接口，重写 call() 方法</li></ul></blockquote><p><strong>上下文切换</strong><br>单核处理器也支持多线程执行代码，CPU 通过给每个线程分配CPU时间片来实现这个机制。当前任务执行一个时间片后会切换到下一个任务。但是切换前会保存上一个任务的状态，以便于下次切换到该任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><hr><h3 id="4-多线程-vs-多任务"><a href="#4-多线程-vs-多任务" class="headerlink" title="4. 多线程 vs. 多任务"></a>4. 多线程 vs. 多任务</h3><p><strong>多任务</strong><br>不同CPU同时执行不同的应用程序的不同线程。</p><p><strong>多线程</strong><br>不同CPU同时执行相同的应用程序的不同线程。</p><p><strong>多线程技术更难实现</strong><br>多线程技术可以以一种很好的方式提高某些类型的应用程序的性能。但是多线程技术比多任务技术要面临更多的技术挑战。不同的线程在同一个应用程序中同时执行，它们可能存在一个线程在读取共享内存的数据，另外一个线程在写入数据至共享内存，造成线程不安全的问题发生，以至于产生了单线程技术通常情况下不会发生的错误。</p><p>现代计算机通常拥有多个CPU或者多个CPU内核，这意味着不同的线程可以被不同的CPU同时执行。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" alt></div></p><hr><h3 id="5-Java-中的并发和多线程"><a href="#5-Java-中的并发和多线程" class="headerlink" title="5. Java 中的并发和多线程"></a>5. Java 中的并发和多线程</h3><p><strong>并发模型</strong></p><blockquote><ul><li>共享状态并发模型（shared state concurrency model）</li><li>隔离状态并发模型（separate state concurrency model）</li></ul></blockquote><p><strong>共享状态并发模型</strong><br>同一个应用程序中的不同的线程使用了同一个共享对象（或变量）。在共享状态并发模型中存在很多问题，这些问题难以完美地解决。</p><p><strong>隔离状态并发模型</strong><br>同一个应用程序中的不同的线程不共享任何对象（或变量）。</p><hr><h3 id="Java-并发学习指南"><a href="#Java-并发学习指南" class="headerlink" title="Java 并发学习指南"></a>Java 并发学习指南</h3><p><strong>并发和多线程理论知识</strong></p><blockquote><ul><li>多线程的好处</li><li>多线程的成本</li><li>并发模型</li><li>同一线程</li><li>并发 vs. 并行</li></ul></blockquote><p><strong>Java并发的基础理论知识</strong></p><blockquote><ul><li>创建和开始一个线程</li><li>线程安全和共享资源</li><li>线程安全和不变性</li><li>JMM (Java memory model)</li><li>synchronize 关键字</li><li>volatile 关键字</li><li>ThreadLocal </li></ul></blockquote><p><strong>Java 并发常见问题</strong></p><blockquote><ul><li>死锁</li><li>预防死锁</li></ul></blockquote><p><strong>Java 提供的一些解决常见问题的工具</strong></p><blockquote><ul><li>Lock （锁）</li><li>Read / Write Lock （读写锁）</li><li>ReentrantLock （可重入锁）</li><li>Semaphores （信号）</li><li>Blocking Queues （阻塞队列）</li><li>Thread Pools （线程池）</li><li>Compare and Swap （CAS）</li></ul></blockquote><p><strong>Java 并发工具包 （JUC: java.util.concurrent）</strong></p><blockquote><ul><li>Java Concurrency Utilities - java.util.concurrent</li></ul></blockquote><hr><p><strong>推荐</strong></p><blockquote><p>&lt;Java 并发编程的艺术&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-并发和多线程&quot;&gt;&lt;a href=&quot;#1-并发和多线程&quot; class=&quot;headerlink&quot; title=&quot;1. 并发和多线程&quot;&gt;&lt;/a&gt;1. 并发和多线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;并发编程&lt;/strong&gt;&lt;br&gt;并发编程涵盖了多线程技术在内，指并发执
      
    
    </summary>
    
    
    
      <category term="Java 并发编程" scheme="http://yoursite.com/tags/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并行流</title>
    <link href="http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    <id>http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/</id>
    <published>2020-07-09T11:21:09.000Z</published>
    <updated>2020-07-09T11:21:09.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数式数据处理</title>
    <link href="http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-07-01T11:22:34.000Z</published>
    <updated>2020-07-08T06:04:24.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h2><p>概念：</p><blockquote><ul><li>Stream：支持数据处理操作的源（集合、数组、输入/输出资源）生成的元素序列 。</li><li>备注： 流是Java 8 API的新成员，它允许你以声明性方式处理数据集合。</li><li><a href="https://miracle-sungm.github.io/2020/06/13/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">Lambda表达式博客链接</a>   </li></ul></blockquote><p>定义：</p><blockquote><ol><li>源： 流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li>元素序列： 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。</li><li>数据处理操作: 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ol></blockquote><p>特点：</p><blockquote><ol><li>流水线： 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li><li>内部迭代： 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ol></blockquote><p>流的特性：</p><blockquote><ol><li>只能遍历一次。和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</li></ol></blockquote><p>Stream API 带来的好处：</p><blockquote><ul><li>声明性 ： 更简洁易读</li><li>可复合 ： 更灵活</li><li>可并行 ： 性能更好</li></ul></blockquote><p>流与集合</p><blockquote><p>粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，集合中的每个元素都得先计算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</p></blockquote><p>流与集合的差异：</p><blockquote><ol><li>遍历数据的方式不同。使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</li><li>//TODO 待补充</li></ol></blockquote><h2 id="2-使用-Stream"><a href="#2-使用-Stream" class="headerlink" title="2. 使用 Stream"></a>2. 使用 Stream</h2><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th align="left">操作</th><th align="left">类型</th><th align="left">返回类型</th><th align="left">函数式接口</th><th align="left">函数描述符</th></tr></thead><tbody><tr><td align="left">filter</td><td align="left">中间</td><td align="left">Stream<T></T></td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">distinct</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">skip</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">limit</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">map</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, R&gt;</td><td align="left">T -&gt; R</td></tr><tr><td align="left">flatMap</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, Stream<R>&gt;</R></td><td align="left">T -&gt; Stream<R></R></td></tr><tr><td align="left">sorted</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left">Comparator<T></T></td><td align="left">(T, T) -&gt; int</td></tr><tr><td align="left">anyMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">noneMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">allMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">findAny</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">findFirst</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">forEach</td><td align="left">终端</td><td align="left">void</td><td align="left">Consumer<T></T></td><td align="left">T -&gt; void</td></tr><tr><td align="left">collect</td><td align="left">终端</td><td align="left">R</td><td align="left">Collector&lt;T, A, R&gt;</td><td align="left"></td></tr><tr><td align="left">reduce</td><td align="left">终端(有状态 &amp; 有界)</td><td align="left">Optional<T></T></td><td align="left">BinaryOperator<T></T></td><td align="left">(T, T) -&gt; T</td></tr><tr><td align="left">count</td><td align="left">终端</td><td align="left">long</td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>过滤流元素：该操作会接受一个 Predicate 函数式接口对象（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;过滤出元素小于5的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().filter(number -&gt; number &lt; 5).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h4 id="2-2-distinct"><a href="#2-2-distinct" class="headerlink" title="2.2 distinct"></a>2.2 distinct</h4><p>对流元素去重：根据流元素的hashCode和equals方法判断元素是否重复。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 1, 1, 2, 2, 2, 3, 3);</span><br><span class="line">    &#x2F;&#x2F;去重数据</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="2-3-limit"><a href="#2-3-limit" class="headerlink" title="2.3 limit"></a>2.3 limit</h4><p>截断流：该操作会接受一个 int 类型的入参，返回一个不超过给定长度的流。（如果流是有序的，则最多返回前 n 个元素）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;截断前2个元素</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().limit(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><h4 id="2-4-skip"><a href="#2-4-skip" class="headerlink" title="2.4 skip"></a>2.4 skip</h4><p>跳过元素：该操作会接受一个 int 类型的入参，返回扔掉前 n 个元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;跳过前2个元素，返回剩余元素的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().skip(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>映射元素： 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;将int元素映射成String元素</span><br><span class="line">    List&lt;String&gt; result &#x3D; numbers.stream().map(Object::toString).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-6-flatMap"><a href="#2-6-flatMap" class="headerlink" title="2.6 flatMap"></a>2.6 flatMap</h4><p>扁平化流： 当流的元素可以转换成另外一个流时，扁平化流会得到一个流元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; a &#x3D; Arrays.asList(&quot;a&quot;, &quot;a1&quot;);</span><br><span class="line">    List&lt;String&gt; b &#x3D; Arrays.asList(&quot;b&quot;, &quot;b1&quot;);</span><br><span class="line">    List&lt;String&gt; c &#x3D; Arrays.asList(&quot;c&quot;, &quot;c1&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listList &#x3D; Arrays.asList(a, b, c);</span><br><span class="line">    &#x2F;&#x2F;扁平化流：将 Stream&lt;List&lt;String&gt;&gt; 流转换成一个新的 Stream&lt;String&gt; 流。</span><br><span class="line">    List&lt;String&gt; list &#x3D; listList.stream().flatMap(List::stream).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">[a, a1, b, b1, c, c1]</span><br></pre></td></tr></table></figure><h4 id="2-7-anyMatch"><a href="#2-7-anyMatch" class="headerlink" title="2.7 anyMatch"></a>2.7 anyMatch</h4><p>判断流中是否存在元素与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否存在与谓词匹配。（注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回true）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    if (numbers.stream().anyMatch(number -&gt; number &#x3D;&#x3D; 2)) &#123;</span><br><span class="line">        System.out.println(&quot;成功匹配到数字2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">成功匹配到数字2</span><br></pre></td></tr></table></figure><h4 id="2-8-allMatch"><a href="#2-8-allMatch" class="headerlink" title="2.8 allMatch"></a>2.8 allMatch</h4><p>判断流中所有元素是否都与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都与谓词匹配。 （注意：该方法执行时，若找到一个不匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39;,&#39;结尾</span><br><span class="line">    if (list.stream().allMatch(s -&gt; s.endsWith(&quot;,&quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素均以&#39;,&#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素均以&#39;,&#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-9-nonMatch"><a href="#2-9-nonMatch" class="headerlink" title="2.9 nonMatch"></a>2.9 nonMatch</h4><p>与allMatch相反，nonMatch是判断流中所有元素是否都不与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都不与谓词匹配。 （注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39; &#39;结尾</span><br><span class="line">    if (list.stream().noneMatch(s -&gt; s.endsWith(&quot; &quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素都不以&#39; &#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素都不以&#39; &#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-10-findFirst"><a href="#2-10-findFirst" class="headerlink" title="2.10 findFirst"></a>2.10 findFirst</h4><p>找到流中第一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中第一个元素。（注意：该方法执行时，找到第一个元素之后，则终止操作，并返回包含第一个元素的Optional对象）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到第一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findFirst();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="2-11-findAny"><a href="#2-11-findAny" class="headerlink" title="2.11 findAny"></a>2.11 findAny</h4><p>找到流中任何一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中任何一个元素。（注意：该方法执行时，找到任何一个元素之后，则终止操作，并返回包含匹配的元素的Optional对象。该方法在并行情况下效率更佳）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到任何一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findAny();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>何时使用 findFirst 和 findAny</strong></p><blockquote><p>你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p></blockquote><h4 id="2-12-reduce"><a href="#2-12-reduce" class="headerlink" title="2.12 reduce"></a>2.12 reduce</h4><p>规约：包含2个方法</p><p><strong>第一个方法</strong></p><p>该方法接受一个与流元素类型相同的泛型对象 T 和一个 BinaryOperator(该类继承了BiFunction)对象；返回一个与流元素类型相同的规约后的对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure></p><p><strong>第二个方法</strong></p><p>该方法接受一个 BinaryOperator<T> 对象；返回 Optional<T> 对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></T></T></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer::sum);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce((a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最大值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:max);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最小值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:min);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p><strong>2个方法的区别</strong></p><blockquote><p>第一个方法接受了一个对象，执行规约方法时会将入参与流中的元素规约到一起。<br>第二个方法只对流中的元素进行规约，因为源可能是空的，所以返回一个Optional对象。</p></blockquote><h4 id="2-13-count"><a href="#2-13-count" class="headerlink" title="2.13 count"></a>2.13 count</h4><p>对流中元素进行计数，返回一个long类型的对象。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().count();</span><br><span class="line">    System.out.println(count));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="2-14-注意："><a href="#2-14-注意：" class="headerlink" title="2.14 注意："></a>2.14 注意：</h4><blockquote><ul><li>filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你用不着为了让某些数据处理任务并行而去操心线程和锁了，Stream API都替你做好了！</li><li>对于流而言，某些操作（例如allMatch、anyMatch、noneMatch、findFirst和findAny）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流</li></ul></blockquote><hr><h2 id="3-数值流"><a href="#3-数值流" class="headerlink" title="3. 数值流"></a>3. 数值流</h2><p>我们在计算流中元素总和时，通常情况下会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码问题是它暗藏拆箱成本。每个Integer都必须拆成一个原始类型再进行求和。</p><h4 id="3-1-原始类型特化"><a href="#3-1-原始类型特化" class="headerlink" title="3.1 原始类型特化"></a>3.1 原始类型特化</h4><p>说明：</p><blockquote><p>Java 8 引入了三个原始类型特化流接口来解决上面这个暗藏拆箱成本的问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。要记住的是，这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和Integer之间的效率差异。</p></blockquote><p><strong>映射到数值流</strong></p><blockquote><ul><li>mapToInt：    映射成IntStream</li><li>mapToLong：   映射成LongStream</li><li>mapToDouble： 映射成DoubleStream</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;映射到数值流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).sum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换回对象流</strong></p><p>通过boxed()方法，转换回对象流，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过boxed()方法，转换回对象流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).boxed().reduce(0, Integer::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).boxed().reduce(0L, Long::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).boxed().reduce(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值</strong></p><p>对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。</p><p><strong>数值范围</strong></p><p>通过使用range() 和 rangeClosed() 方法生成数值范围。</p><blockquote><ul><li>range(int startInclusive, int endExclusive) 方法： 生成 [startInclusive, endExclusive) 范围内数值流（左闭右开）。</li><li>rangeClosed(int startInclusive, int endInclusive) 方法： 生成 [startInclusive, endInclusive] 范围内数值流（左闭右闭）。</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(IntStream.range(1, 100).count());</span><br><span class="line">    System.out.println(IntStream.rangeClosed(1, 100).count());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td></tr></table></figure><hr><h2 id="4-构建流"><a href="#4-构建流" class="headerlink" title="4. 构建流"></a>4. 构建流</h2><p>这里主要介绍由集合、数值、数组、文件来创建流；最后介绍下由生成函数来创建无限流。</p><h4 id="4-1-由集合生成流"><a href="#4-1-由集合生成流" class="headerlink" title="4.1 由集合生成流"></a>4.1 由集合生成流</h4><p>Java 8 的 Collection 新增了 stream() 的 Api，集合对象通过调用 stream() 方法生成流。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;sungm&quot;, &quot;other&quot;);</span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure><h4 id="4-2-由数值生成流"><a href="#4-2-由数值生成流" class="headerlink" title="4.2 由数值生成流"></a>4.2 由数值生成流</h4><p>通过 Stream.of() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;sungm&quot;, &quot;other&quot;);</span><br></pre></td></tr></table></figure><h4 id="4-3-由数组生成流"><a href="#4-3-由数组生成流" class="headerlink" title="4.3 由数组生成流"></a>4.3 由数组生成流</h4><p>通过 Arrays.stream() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(numbers);</span><br></pre></td></tr></table></figure><h4 id="4-4-由文件生成流"><a href="#4-4-由文件生成流" class="headerlink" title="4.4 由文件生成流"></a>4.4 由文件生成流</h4><p>java nio</p><blockquote><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。例如：Files.lines()方法</p></blockquote><h4 id="4-5-函数生成流：创建无限流"><a href="#4-5-函数生成流：创建无限流" class="headerlink" title="4.5 函数生成流：创建无限流"></a>4.5 函数生成流：创建无限流</h4><p>Stream.iterate()方法和Stream.generate()方法：</p><blockquote><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;我们通过使用limit()方法来截断流</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>无限流是没有固定大小的流</p></blockquote><hr><h2 id="5-用流收集数据"><a href="#5-用流收集数据" class="headerlink" title="5. 用流收集数据"></a>5. 用流收集数据</h2><h4 id="5-1-Collectors-收集器"><a href="#5-1-Collectors-收集器" class="headerlink" title="5.1 Collectors (收集器)"></a>5.1 Collectors (收集器)</h4><p><strong>简介</strong></p><blockquote><ul><li>Stream类的collect方法是一个终端操作，类似于Stream类的reduce方法，可以接受做法作为参数，将流中的元素累积成一个汇总结果，而collect方法接受的就是一个 Collector 对象。</li><li>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）；再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。</li><li>Collectors 非常有用，因为它可以简洁和灵活的定义collect用来生成结果集合的标准。更具体地说，对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）</li><li>Collectors 是 Collector 的工厂类。</li></ul></blockquote><p><strong>预定义收集器</strong></p><p>Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p><blockquote><p>将流元素归约和汇总为一个值<br>元素分组<br>元素分区</p></blockquote><h4 id="5-2-归约和汇总"><a href="#5-2-归约和汇总" class="headerlink" title="5.2 归约和汇总"></a>5.2 归约和汇总</h4><h5 id="5-2-1-counting-计数"><a href="#5-2-1-counting-计数" class="headerlink" title="5.2.1 counting (计数)"></a>5.2.1 counting (计数)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().collect(Collectors.counting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>使用 number.stream().count() 进行计数更直接，但是counting收集器在和其他收集器联合使用的时候特别有用。</p></blockquote><h5 id="5-2-2-maxBy-最大值"><a href="#5-2-2-maxBy-最大值" class="headerlink" title="5.2.2 maxBy (最大值)"></a>5.2.2 maxBy (最大值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; maxNumber &#x3D; numbers.stream().collect(Collectors.maxBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().max(Comparator.comparingInt(a -&gt; a)) 获取最大值</p></blockquote><h5 id="5-2-3-minBy-最小值"><a href="#5-2-3-minBy-最小值" class="headerlink" title="5.2.3 minBy (最小值)"></a>5.2.3 minBy (最小值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; minNumber &#x3D; numbers.stream().collect(Collectors.minBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().min(Comparator.comparingInt(a -&gt; a)) 获取最小值</p></blockquote><h5 id="5-2-4-summingInt、summarizingLong、summarizingDouble-求和"><a href="#5-2-4-summingInt、summarizingLong、summarizingDouble-求和" class="headerlink" title="5.2.4 summingInt、summarizingLong、summarizingDouble (求和)"></a>5.2.4 summingInt、summarizingLong、summarizingDouble (求和)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求和</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以将流转换成数值流之后再对数值流进行求和，例如： numbers.stream().maoToInt(a -&gt; a).sum()。</p></blockquote><h5 id="5-2-5-averagingInt、averagingLong、averagingDouble-求平均值"><a href="#5-2-5-averagingInt、averagingLong、averagingDouble-求平均值" class="headerlink" title="5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)"></a>5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求平均值</span><br><span class="line">    double averagingInt &#x3D; numbers.stream().collect(Collectors.averagingInt(a -&gt; a));</span><br><span class="line">    double averagingLong &#x3D; numbers.stream().collect(Collectors.averagingLong(a -&gt; (long) a));</span><br><span class="line">    double averagingDouble &#x3D; numbers.stream().collect(Collectors.averagingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结"><a href="#5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结" class="headerlink" title="5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)"></a>5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;对数值进行总结，获取流元素的数值和、最大值、最小值、平均值、计数。</span><br><span class="line">    IntSummaryStatistics intSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    LongSummaryStatistics longSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    DoubleSummaryStatistics doubleSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line"></span><br><span class="line">    System.out.println(intSummaryStatistics.toString());</span><br><span class="line">    System.out.println(longSummaryStatistics.toString());</span><br><span class="line">    System.out.println(doubleSummaryStatistics.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">IntSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">LongSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">DoubleSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36.000000, min&#x3D;1.000000, average&#x3D;4.500000, max&#x3D;8.000000&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>通过一次 summarizing 操作你可以就计算出元素的个数，并得到元素总和、平均值、最大值和最小值。</p></blockquote><h5 id="5-2-7-join-连接字符串"><a href="#5-2-7-join-连接字符串" class="headerlink" title="5.2.7 join 连接字符串"></a>5.2.7 join 连接字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;);</span><br><span class="line">    &#x2F;&#x2F;直接连接字符串</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining()));</span><br><span class="line">    &#x2F;&#x2F;字符串之间用指定的delimiter(定界符)连接字符</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining(&quot;, &quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">OneTwoThreeFourFiveSix</span><br><span class="line">One, Two, Three, Four, Five, Six</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>某些情况下，可以使用String.join()方法更直接。 例如：String.join(“, “, list);</p></blockquote><h4 id="5-2-8-reducing-规约-5-2章节的重点"><a href="#5-2-8-reducing-规约-5-2章节的重点" class="headerlink" title="5.2.8 reducing 规约(5.2章节的重点)"></a>5.2.8 reducing 规约(5.2章节的重点)</h4><p><strong>Collectors类中存在3个reducing()方法，下面我们逐个介绍</strong></p><blockquote><ul><li>reducing(Object, Function, BinaryOperator)</li><li>reducing(Object, BinaryOperator)</li><li>reducing(BinaryOperator)</li></ul></blockquote><p><strong>说明：</strong></p><blockquote><p>我们上面讨论的7种方法（5.2.1 - 5.2.7）都是一个可以用 reducing 工厂方法定义的归约过程的特殊情况而已。Collectors.reducing 工厂方法是所有这些特殊情况的一般化。<br>Collectors类中存在3个reducing()方法功能类似。</p></blockquote><p><strong>方法一：reducing(Object, Function, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? super T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口Function对象，该Function对象将流元素对象转换成你所需要进行规约操作的对象</li><li>该方法第三个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 成绩</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-07-05 14:32</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Grade &#123;</span><br><span class="line"></span><br><span class="line">    private String studentName;</span><br><span class="line">    private String course;</span><br><span class="line">    private Double score;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter、setter、toString、以及无参构造方法和全参构造方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().collect(Collectors.reducing(0D, Grade::getScore, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：reducing(Object, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, T&gt;</span><br><span class="line">reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0],</span><br><span class="line">            CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：reducing(BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    class OptionalBox implements Consumer&lt;T&gt; &#123;</span><br><span class="line">        T value &#x3D; null;</span><br><span class="line">        boolean present &#x3D; false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void accept(T t) &#123;</span><br><span class="line">            if (present) &#123;</span><br><span class="line">                value &#x3D; op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                value &#x3D; t;</span><br><span class="line">                present &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::new, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; if (b.present) a.accept(b.value); return a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法入参是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li><li>该方法返回一个Optional<T>类的对象。</T></li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学视所有课程的总成绩</span><br><span class="line">    Optional&lt;Double&gt; score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别"><a href="#5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别" class="headerlink" title="5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别"></a>5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别</h4><p> 示例：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 8)</span><br><span class="line">        .boxed()</span><br><span class="line">        .reduce(new ArrayList&lt;&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; &#123;</span><br><span class="line">            l.add(e);</span><br><span class="line">            return l;</span><br><span class="line">        &#125;, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; &#123;</span><br><span class="line">            l1.addAll(l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>区别:</p><blockquote><p>Stream类的reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反，collect方法的设计就是要改变容器，从而累积要输出的结果。这意味着，上面的示例的代码片段是在滥用reduce方法，因为它在原地改变了作为累加器的List。<br>以错误的语义使用Stream类的reduce方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏List本身。在这种情况下，如果你想要线程安全，就需要每次分配一个新的List，而对象分配又会影响性能。这就是collect方法特别适合表达可变容器上的归约的原因，更关键的是它适合并行操作</p></blockquote><p>使用收集器的的好处：</p><blockquote><ul><li>灵活性更强：可以以不同的方法执行同样的操作。</li><li>根据情况选择最佳解决方案：收集器在某种程度上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</li></ul></blockquote><p><strong>建议：</strong></p><blockquote><p>就实际应用而言，建议使用Collectors类的reduce方法，无轮从可读性还是性能上讲，Collectors类的reduce方法都更好。</p></blockquote><h2 id="5-3-分组"><a href="#5-3-分组" class="headerlink" title="5.3 分组"></a>5.3 分组</h2><h4 id="5-3-1-groupingBy-分组"><a href="#5-3-1-groupingBy-分组" class="headerlink" title="5.3.1 groupingBy 分组"></a>5.3.1 groupingBy 分组</h4><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(1L, &quot;miracle&quot;, 25, &quot;Boy&quot;)</span><br><span class="line">            , new Student(2L, &quot;bob&quot;, 24, &quot;Boy&quot;)</span><br><span class="line">            , new Student(3L, &quot;lucky&quot;, 22, &quot;Girl&quot;)</span><br><span class="line">            , new Student(3L, &quot;lusa&quot;, 24, &quot;Girl&quot;));</span><br><span class="line">    &#x2F;&#x2F;按照性别分组</span><br><span class="line">    Map&lt;String, List&lt;Student&gt;&gt; map &#x3D; students.stream().collect(Collectors.groupingBy(Student::getSex));</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#123;</span><br><span class="line">    Girl&#x3D;[Student&#123;id&#x3D;3, name&#x3D;&#39;lucky&#39;, age&#x3D;22, sex&#x3D;&#39;Girl&#39;&#125;, Student&#123;id&#x3D;3, name&#x3D;&#39;lusa&#39;, age&#x3D;24, sex&#x3D;&#39;Girl&#39;&#125;], </span><br><span class="line">    Boy&#x3D;[Student&#123;id&#x3D;1, name&#x3D;&#39;miracle&#39;, age&#x3D;25, sex&#x3D;&#39;Boy&#39;&#125;, Student&#123;id&#x3D;2, name&#x3D;&#39;bob&#39;, age&#x3D;24, sex&#x3D;&#39;Boy&#39;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>示例中给groupingBy传入一个Function，我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p></blockquote><p>groupingBy源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    return groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Stream&quot;&gt;&lt;a href=&quot;#1-Stream&quot; class=&quot;headerlink&quot; title=&quot;1. Stream&quot;&gt;&lt;/a&gt;1. Stream&lt;/h2&gt;&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Stream：支持数据处理操
      
    
    </summary>
    
    
    
      <category term="Java 8 新特性" scheme="http://yoursite.com/tags/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
</feed>
