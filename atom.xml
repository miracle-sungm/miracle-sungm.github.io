<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miracle&#39;s Blog</title>
  
  <subtitle>Miracles happen every day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-14T12:27:30.240Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sungm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发编程] 11. Java Happen Before Guarantee</title>
    <link href="http://yoursite.com/2020/08/14/Guarantee/"/>
    <id>http://yoursite.com/2020/08/14/Guarantee/</id>
    <published>2020-08-14T09:11:03.000Z</published>
    <updated>2020-08-14T12:27:30.240Z</updated>
    
    <content type="html"><![CDATA[<p>Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。</p><h3 id="1-指令重排"><a href="#1-指令重排" class="headerlink" title="1. 指令重排"></a>1. 指令重排</h3><p>现代计算机有能力并行执行指令，当一个指令不依赖其他指令时，可能发生指令重排。如下所示：两个指令不相互依赖，计算机可以并行执行这两个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e + f;</span><br></pre></td></tr></table></figure><p>下面这2个指令不会发生指令重排，因为第二个指令依赖第一个指令产生的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a + e;</span><br></pre></td></tr></table></figure><p>指令重排的结果可以让指令在CPU中并行执行，以提高性能。指令重排在JVM和CPU中是被允许的，前提是程序中的语句没有发生改变。指令重排后程序执行的结果必须与没有指令重排时程序执行的结果保持一致。</p><h3 id="2-指令重排在多CPU计算机中的问题"><a href="#2-指令重排在多CPU计算机中的问题" class="headerlink" title="2. 指令重排在多CPU计算机中的问题"></a>2. 指令重排在多CPU计算机中的问题</h3><p>指令重排在多线程、多CPU系统中存在一些挑战。请看下面示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int a &#x3D; 0;</span><br><span class="line">private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;有点意思&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>在第一个线程中，a = 1 与 b = 1 两个指令不相互影响，CPU为了提高执行性能，可能并行执行这两个指令，这种情况下， b = 1 指令可能在 a = 1 前面执行，若执行 b = 1 后（假定 a = 1 指令还未执行，此时 a 的值为初始值 0），此时第二个线程正在执行判断条件 a == 0 &amp;&amp; b == 1，那么将会打印数据 ‘有点意思’。为了验证这个问题，我们来循环执行这段代码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-08-13 15:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int a &#x3D; 0;</span><br><span class="line">    private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    System.out.println(&quot;有点意思&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            a &#x3D; 0;</span><br><span class="line">            b &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这段代码有意思，不妨自己试一试。多等待一会，你会发现控制台输出了“有点意思”。</p><h3 id="3-volatile-可见性保证"><a href="#3-volatile-可见性保证" class="headerlink" title="3. volatile 可见性保证"></a>3. volatile 可见性保证</h3><p>Java volatile 关键字提供了读写的可见性保证，当线程读volatile变量时会从主内存中读取数据，当线程修改volatile变量时会将变量的值写回到主内存中。这种同步到主内存的机制保证了变量的值对其他线程可见，这就是volatile可见性保证。</p><h5 id="3-1-volatile-修改数据可见性保证"><a href="#3-1-volatile-修改数据可见性保证" class="headerlink" title="3.1 volatile 修改数据可见性保证"></a>3.1 volatile 修改数据可见性保证</h5><p>当线程修改volatile变量的值时，修改后的值会被同步到主内存中。另外，<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。（请注意这句话，线程所有的变量都会随volatile变量写回到主内存中，不只是volatile变量写回到主内存中）</strong></p><p>请看示例：<br>(1) 首先我们用简单的代码证明使用 volatile 定义的变量的值被某个线程修改后对其他线程可见。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意这里没有使用volatile关键字</span><br><span class="line">    private boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public boolean isKeepRunning() &#123;</span><br><span class="line">        return keepRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;子线程把keepRunning的值改为true</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程中循环尝试获取子线程修改后的keepRunning的值，如果获取到，输出有点意思</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (myRunnable.isKeepRunning()) &#123;</span><br><span class="line">            System.out.println(&quot;有点意思&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你亲手运行了这段代码，你会发现这个程序永远不会输出“有点意思”。现在我们使用volatile定义keepRunning属性，其他代码不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用volatile定义</span><br><span class="line">private volatile boolean keepRunning &#x3D; false;</span><br></pre></td></tr></table></figure><p>使用volatile关键字后，程序循环输出“有点意思”。</p><p><strong>因此我们可以得出结论：volatile 定义的变量的值被某个线程修改后对其他线程可见。</strong></p><p>(2) 现在我们来证明下我们前面说的：<strong>线程里包含的所有变量都会随 volatile 变量写回到主内存中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用了 volatile 关键字的属性</span><br><span class="line">    private volatile boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;未使用 volatile 关键字的属性</span><br><span class="line">    private String strA &#x3D; &quot;A&quot;;</span><br><span class="line">    private String strB &#x3D; &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">        strA &#x3D; &quot;a&quot;;</span><br><span class="line">        strB &#x3D; &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyRunnable&#123;&quot; +</span><br><span class="line">                &quot;keepRunning&#x3D;&quot; + keepRunning +</span><br><span class="line">                &quot;, strA&#x3D;&#39;&quot; + strA + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, strB&#x3D;&#39;&quot; + strB + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(200L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(myRunnable.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序最终输出：MyRunnable{keepRunning=true, strA=’a’, strB=’b’}</p><p>这个结果我们不难看出：子线程修改了keepRunning、strA和strB的值（strA和strB未使用volatile关键字），主线程不仅读取到了keepRunning更新后的值，还读取到了strA和strB更新后的值。所以请记住：<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。</strong></p><h5 id="3-2-volatile-读取数据可见性保证"><a href="#3-2-volatile-读取数据可见性保证" class="headerlink" title="3.2 volatile 读取数据可见性保证"></a>3.2 volatile 读取数据可见性保证</h5><p>当线程读取被 volatile 关键字修饰的变量时，会从主内存中读取。<strong>另外：线程里所有的变量都会随着 volatile 变量读取到CPU缓存或者寄存器中。</strong></p><p>比如下面三个变量，当线程读取strA的值时，会重定向到主内存中读取strA的值，如果strB，strC同样在线程中，也会从主内存中读取strB，strC的值。我们本章3.1节的例子同样能证明此特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valatile String strA &#x3D; &quot;A&quot;;</span><br><span class="line">String strB &#x3D; &quot;B&quot;;</span><br><span class="line">String strC &#x3D; &quot;B&quot;;</span><br></pre></td></tr></table></figure><h5 id="3-3-volatile-happens-before-保证"><a href="#3-3-volatile-happens-before-保证" class="headerlink" title="3.3 volatile happens-before 保证"></a>3.3 volatile happens-before 保证</h5><p>volatile happens-before 保证设置了一些关于volatile变量指令重排的限制（规定）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 10. Java内存模型</title>
    <link href="http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-12T08:39:30.000Z</published>
    <updated>2020-08-13T03:43:16.094Z</updated>
    
    <content type="html"><![CDATA[<p>Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。</p><p>如果你想要设计出正确的并发程序，那么理解JMM是非常重要的。Java内存模型会提到一个线程怎样获取被别的线程修改后的共享变量的值；也会提到当有必要的时候，怎样让多个线程顺序的访问共享变量。</p><p>注意：原来的Java内存模型进行过修订，从Java 1.5 到 Java 14+，这个版本的内存模型仍然适用。</p><h3 id="1-Java-Memory-Model"><a href="#1-Java-Memory-Model" class="headerlink" title="1. Java Memory Model"></a>1. Java Memory Model</h3><p>在JVM中，JMM包含两种内存模型：Thread Stacks(线程栈)、Heap(堆内存)。如图所示</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt></div></p><p><strong>内存模型</strong></p><ol><li>每个在JVM中运行的线程都有自己的线程栈。这个线程栈包含线程中调用的方法信息和程序计数器（当前程序所执行的字节码的行号指示器）。</li><li>在开始执行某个方法的时候，会在线程栈中存储方法内所有的local variable(局部变量)，局部变量只对创建它的线程可见，其他线程无法访问。即使两个线程同时执行同一个方法，这两个线程都会创建局部变量保存至属于自己的线程栈中，线程只能访问自己线程栈中的数据。</li><li>所有基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量都保存在线程栈中，并且对其他线程不可见。一个线程可能拷贝一个基本数据类型变量给其他线程，但不会共享原始的局部变量（这里是值传递）。</li><li>堆内存中包含Java应用程序中所有对象的创建，不论哪个线程创建的对象都存储在堆内存中，并且包含基础数据类型的包装类也存储于堆内存中。对象的创建不管是作为局部变量、还是作为对象的成员，都始终保存于堆内存中。</li></ol><p>如下图所示：</p><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt></div></p><ol><li>一个本地变量可能是一个基本数据类型，这种情况下本地变量将完全保存在线程栈中。</li><li>一个本地变量可能引用一个对象，这种情况下对象的引用保存在线程栈中，对象保存在堆内存中。</li><li>一个对象可能包含一些方法，方法包含一些本地变量。本地变量保存在线程栈中，方法保存随对象保存在堆内存中。</li><li>一个对象的成员变量随对象保存在堆内存中，不论这个成员变量是基本数据类型还是引用其他对象，成员变量都保存在堆内存中。</li><li>静态变量随 class(类) 保存在堆内存中。</li></ol><p>堆内存的对象可以被任何具有该对象引用的线程访问。</p><hr><h3 id="2-计算机硬件内存结构"><a href="#2-计算机硬件内存结构" class="headerlink" title="2. 计算机硬件内存结构"></a>2. 计算机硬件内存结构</h3><p>现代硬件内存结构与Java内存模型有些不同，为了更好的理解Java内存模型，了解硬件内存结果是很重要的。</p><p>通常的硬件内存结构。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt></div></p><p>现代计算机通常拥有2个以上的CPU，有些CPU有多个内核。重点是多CPU计算机可以同时执行多个线程。当你的Java应用程序是多线程应用程序，在你的应用程序中可能同时出现每个CPU都在执行线程的情况。</p><ol><li>每个CPU有一组（注意是一组，多个）CPU寄存器，CPU操作寄存器的速度比操作主内存更快，这也意味着CPU访问寄存器的速度比访问内存更快。</li><li>每个CPU也可能有一个CPU缓存（CPU Cache Memory），事实上，每个CPU可能有一定数量的CPU缓存。CPU访问CPU缓存的速度比访问内存的速度快，通常情况下CPU访问CPU缓存的速度没有访问寄存器的速度快。因此你可以认为CPU访问内存的顺序依次是：寄存器 &gt; CPU缓存 &gt; 主内存。另外，一些CPU可能会有多级CPU缓存（L1,L2,L3等）。</li><li>每个计算机都包含一个主内存，主内存的容量比CPU缓存的容量更大。</li><li>通常情况下，CPU访问内存会读取主内存中的一些数据拷贝至CPU缓存，甚至拷贝至CPU内部的寄存器，然后可以在CPU缓存或者寄存器操作数据。当CPU需要写回数据至主内存中时，它首先会将寄存器中的结果值提交至CPU缓存中，然后再将CPU缓存的值提交至主内存中。</li><li>当CPU需要将CPU缓存的数据提交至主内存中时，CPU缓存的数据将会被写回主内存中。</li></ol><h5 id="2-1-桥接Java内存模型和计算机硬件内存结构"><a href="#2-1-桥接Java内存模型和计算机硬件内存结构" class="headerlink" title="2.1 桥接Java内存模型和计算机硬件内存结构"></a>2.1 桥接Java内存模型和计算机硬件内存结构</h5><p>如您所知，Java内存模型与现代计算机硬件内存结构不同，硬件内存结构没有区分线程栈内存和堆内存。也就是说：线程栈内存和堆内存可以都存在于硬件的主内存、CPU高速缓存、寄存器中。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt></div></p><p>当Java对象和变量可以保存在不同的计算机内存区域中，这就可能会导致一些问题的发生。主要的两个问题是：</p><ol><li>当线程更新共享数据时，共享数据在多个线程中的可见性。</li><li>当多个线程读、写、检查共享数据时，产生竞争条件。</li></ol><p>下面我们来解释这2个问题</p><h5 id="2-2-共享数据的可见性"><a href="#2-2-共享数据的可见性" class="headerlink" title="2.2. 共享数据的可见性"></a>2.2. 共享数据的可见性</h5><p>如果多个线程共享一个对象，并且代码中没有使用 volatile 关键字和 synchronized 同步代码块。当一个线程更新这个共享对象后，修改后的对象的值可能对其他线程不可见。</p><p>想象一下，当一个共享对象保存在主内存中时，一个CPU正在执行某个线程时把主内存中共享对象缓存至CPU高速缓存上，另外一个CPU也把共享对象缓存到CPU高速缓存中，其中一个CPU在CPU高速缓存中更新了共享数据并把共享数据写回到主内存中，此时另外一个CPU的CPU高速缓存还是旧的共享资源数据。</p><p>下图中解释了上面这种场景。下图左边的正在执行某个线程的CPU将 obj.count 加载到CPU高速缓存中，同时将 obj.count 的值改为 2。左边这个线程对 obj.count 的值进行修改后，对执行其他线程的CPU并不可见。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 volatile 关键字。这个关键字用于修饰某个成员变量，当线程要读取这个变量的值时，会从读取主内存中读取变量的值，并且每次修改变量的值时都会重新写回到主内存中。（后面会有文章详细介绍 volatile 关键字）</p><h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>如果多个线程共享一个对象，并且有多个线程修改共享变量，可能产生竞争条件。</p><p>想象一下，如果一个线程A从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，同时线程B也从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，线程A和线程B同时对 obj.count 做自增操作，也就是说 obj.count 同时被自增2次，在每个CPU里面自增一次。如果变量 obj.count 的同步执行递增2次，那么这个变量写回主内存时值应该是 obj.count + 2，然而这2次递增没有同步执行，实际上是在线程A和线程B并行执行，最终线程A和线程B把 obj.count 的值写回数据到主内存后，实际值变成了 obj.count + 1。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt></div></p><p>解决这个问题我们可以使用 Java 提供的 synchronized 锁。synchronized 可以分别用于 代码块、普通方法、静态方法。后面有文章介绍 synchronized，这里不做过多描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。&lt;/p&gt;
&lt;p&gt;如果你想要设计出正确的并发程序，那么理解JMM是非常重
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 9. 线程安全和不变性</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</id>
    <published>2020-08-12T07:50:16.000Z</published>
    <updated>2020-08-12T08:35:38.811Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。</p><p>下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ImmutableValue&#123;</span><br><span class="line"></span><br><span class="line">  private int value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue(int value)&#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 ImmutableValue 提供了一个传入指定 value 的构造函数，一旦对象被创建，该对象没有提供任何修改value值的方法，所以value的值无法被修改。</p><h3 id="特别注意：对象引用不是线程安全的"><a href="#特别注意：对象引用不是线程安全的" class="headerlink" title="特别注意：对象引用不是线程安全的"></a>特别注意：对象引用不是线程安全的</h3><p>需要注意的是，当一个对象不可变时对象本身是线程安全的，但是对象的引用可能不是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  private ImmutableValue currentValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue getImmutableValue()&#123;</span><br><span class="line">    return currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setImmutableValue(ImmutableValue newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void add(int newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; new ImmutableValue(currentValue.getValue() + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Calculator 类引用了一个 ImmutableValue 对象，请注意它可以通过 setImmutableValue() 方法和 add() 方法改变了 ImmutableValue 对象的引用。换句话说，即使 ImmutableValue 对象是不可变的，但它也是非线程安全的。ImmutableValue 类是线程安全的，但对象的引用是非线程安全的。<strong>所以特别注意：对象的引用可能是非线程安全的。</strong> 可以通过给 setImmutableValue() 方法和 add() 方法加锁（使用 synchronized 关键字等）保证线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。&lt;/p&gt;
&lt;p&gt;下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 8. 线程安全和共享资源</title>
    <link href="http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</id>
    <published>2020-08-12T06:56:11.000Z</published>
    <updated>2020-08-12T07:48:59.244Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。</p><h3 id="1-Local-variables-本地变量-局部变量"><a href="#1-Local-variables-本地变量-局部变量" class="headerlink" title="1. Local variables (本地变量/局部变量)"></a>1. Local variables (本地变量/局部变量)</h3><p>局部变量保存在每个线程独有的线程栈中，因此局部变量在线程之间是不共享的。也就是说所有的局部变量都是线程安全的。举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void someMethod()&#123;</span><br><span class="line">    long threadSafeInt &#x3D; 0;</span><br><span class="line">    threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-Local-Object-References-本地对象引用-局部对象引用"><a href="#2-Local-Object-References-本地对象引用-局部对象引用" class="headerlink" title="2. Local Object References (本地对象引用/局部对象引用)"></a>2. Local Object References (本地对象引用/局部对象引用)</h3><p>本地对象引用有所不同，引用本身是不共享的，同样也是保存在线程独有的线程栈中，线程之间不共享引用。但是引用的对象不是保存在线程栈中，而是保存在主内存堆中，理论上讲所有的线程都能够访问内存堆中存储的对象（但是要有对象的引用）。</p><p>如果一个对象创建之后没有离开创建它的方法，那么是线程安全的。事实上传递这个对象的引用给其他的方法，只要这个对象的引用没有传递给其他的线程，那么这个对象都不会成为共享对象，始终是线程安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void methodOne()&#123;</span><br><span class="line">  LocalObject localObject &#x3D; new LocalObject();</span><br><span class="line">  methodTwo(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo(LocalObject localObject)&#123;</span><br><span class="line">  localObject.setValue(&quot;value&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中：对象 localObject 在 methodOne() 方法中被创建，然后传递给 methodTwo()，localObject 没有传递给其他线程; 每个线程执行 methodOne() 时会都创建一个新的 LocalObject 对象，且 LocalObject 对象的引用都保存在各自的线程栈中，因此是 methodOne() 线程安全的，尽管 LocalObject 存在多个实例对象，但使用它们是线程安全的。</p><p><strong>但有一种场景例外：</strong> 当某个方法将 localObject 对象的引用作为参数传递给了其他线程，那么可能会造成线程不安全。</p><h3 id="3-Object-Member-Variables-对象成员变量"><a href="#3-Object-Member-Variables-对象成员变量" class="headerlink" title="3. Object Member Variables (对象成员变量)"></a>3. Object Member Variables (对象成员变量)</h3><p>对象成员变量随对象保存在堆内存中。因此当两个线程调用了某个方法，这个方法引用了同一个对象并修改了这个对象的成员变量时，那么这个方法时线程不安全的。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public add(String text)&#123;</span><br><span class="line">        this.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程同时调用同一个 NotThreadSafe 对象的 add() 方法时，会导致竞争条件发生。 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotThreadSafe sharedInstance &#x3D; new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"></span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance &#x3D; instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    this.instance.add(&quot;some text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意有 2 个 MyRunnable 对象共享了 sharedInstance 对象，因此当他们同时调用 sharedInstance.add() 方法时，会发生竞争条件。</p><p>然而，当 2 个线程同时调用不对对象的 add() 方法时，不会产生竞争条件。示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br></pre></td></tr></table></figure><h3 id="4-线程安全规则"><a href="#4-线程安全规则" class="headerlink" title="4. 线程安全规则"></a>4. 线程安全规则</h3><p>当你想确认你的代码访问某些资源的时候是否是线程安全的，你可以使用下面这个规则：</p><blockquote><p><strong>如果资源的创建、使用和销毁都没有离开某个方法，并且没有分享给其他线程，那么使用这个资源是线程安全的。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。&lt;/p&gt;
&lt;h3 id=&quot;1-Local-variables-本地变量-局部变
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 7. 竞争条件和临界区</title>
    <link href="http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</id>
    <published>2020-08-12T06:41:07.000Z</published>
    <updated>2020-08-12T06:54:42.914Z</updated>
    
    <content type="html"><![CDATA[<p>竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 6. 创建和开始Java线程</title>
    <link href="http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-12T02:32:54.000Z</published>
    <updated>2020-08-12T06:40:36.596Z</updated>
    
    <content type="html"><![CDATA[<p>一个Java线程就像一个可以执行你的Java代码的虚拟CPU。</p><p>当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。</p><p>Java 线程都是对象，就像其他的Java对象一样，线程对象都是 java.lang.Tread 的实例或者其子类的实例。</p><h3 id="1-创建和开始线程"><a href="#1-创建和开始线程" class="headerlink" title="1 创建和开始线程"></a>1 创建和开始线程</h3><p>你可以像这样创建一个线程对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread myThread &#x3D; new Thread();</span><br></pre></td></tr></table></figure><p>你可以像这样开始一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><p>创建线程的几种方式：</p><blockquote><ul><li>继承 java.lang.Thread 类并重写 run() 方法。</li><li>实现 java.lang.Runnable 接口并重写 run() 方法。</li><li>实现 java.util.concurrent.Callable 接口并重写 call() 方法。（备注：这种实现方式后面有 JUC 专题）</li></ul></blockquote><hr><h3 id="2-Thread-子类"><a href="#2-Thread-子类" class="headerlink" title="2 Thread 子类"></a>2 Thread 子类</h3><p>继承 java.lang.Thread 类并重写 run() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyThread myThread &#x3D; new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start() 方法不会等线程执行完 run()方法，run() 方法将会由其他不同的CPU执行。</p><hr><h3 id="3-实现-Runnable-接口"><a href="#3-实现-Runnable-接口" class="headerlink" title="3 实现 Runnable 接口"></a>3 实现 Runnable 接口</h3><p>第二种创建线程的方式是实现 java.lang.Runnable 接口并重写该接口的 run() 方法。一个 Java 对象实现 Runnable 接口 可以被Java Thread 类执行。</p><p>Runnable 接口由 JDK 提供，仅有一个 run 方法，是一个函数式接口。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 的方式有3种：</p><blockquote><ol><li>创建一个 Java 类实现 Runnable 接口</li><li>创建一个 Java 匿名类实现 Runnable 接口</li><li>使用 Java 8 Lambda 表达式实现 Runnable 接口</li></ol></blockquote><h5 id="3-1-创建一个-Java-类实现-Runnable-接口"><a href="#3-1-创建一个-Java-类实现-Runnable-接口" class="headerlink" title="3.1 创建一个 Java 类实现 Runnable 接口"></a>3.1 创建一个 Java 类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-创建一个-Java-匿名类实现-Runnable-接口"><a href="#3-2-创建一个-Java-匿名类实现-Runnable-接口" class="headerlink" title="3.2 创建一个 Java 匿名类实现 Runnable 接口"></a>3.2 创建一个 Java 匿名类实现 Runnable 接口</h5><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable &#x3D; new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口"><a href="#3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口" class="headerlink" title="3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口"></a>3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable &#x3D; () -&gt; &#123; System.out.println(&quot;Lambda Runnable running&quot;); &#125;;</span><br></pre></td></tr></table></figure><h5 id="3-4-开启一个实现了-Runnable-接口的线程"><a href="#3-4-开启一个实现了-Runnable-接口的线程" class="headerlink" title="3.4 开启一个实现了 Runnable 接口的线程"></a>3.4 开启一个实现了 Runnable 接口的线程</h5><p>java.lang.Thread的包含传入一个Runnable接口的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;or an anonymous class, or lambda...</span><br><span class="line">    Runnable runnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;executed by a thread</span><br><span class="line">    Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-使用哪种方式创建线程更好"><a href="#4-使用哪种方式创建线程更好" class="headerlink" title="4. 使用哪种方式创建线程更好 ?"></a>4. 使用哪种方式创建线程更好 ?</h3><p>关于继承Thread和实现Runnable接口，没有明确的规定用哪种方式创建线程更好，两种方式都可以让线程运行。我更倾向于使用实现Runnable接口的方式，后面我还们会了解到另外一种创建线程的方式，通过线程池创建线程的方式更加合理。</p><h3 id="5-常见陷阱：调用-run-代替-start"><a href="#5-常见陷阱：调用-run-代替-start" class="headerlink" title="5. 常见陷阱：调用 run() 代替 start()"></a>5. 常见陷阱：调用 run() 代替 start()</h3><p>通过调用start()，程序会告诉 CPU 线程已准备就绪，等待CPU执行 run() 方法。若直接调用 run() 方法则不会开启一个新的线程去执行 run() 方法，而是在原来的线程中去执行 run() 方法，所以当我们需要一个新的线程去执行 run() 方法中的代码时，应该调用 start() 方法启动一个线程，而不是直接调用 run() 方法。</p><h3 id="6-线程名（Thread-Names）"><a href="#6-线程名（Thread-Names）" class="headerlink" title="6. 线程名（Thread Names）"></a>6. 线程名（Thread Names）</h3><p>创建线程的时候可以指定线程名称，详见 java.lang.Thread API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable myRunnable &#x3D; () -&gt; System.out.println(&quot;Thread name is &quot; + Thread.currantThread().getName());</span><br><span class="line">    </span><br><span class="line">    new Thread(myRunnable, &quot;Thread One&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console out: Thread name is Thread One</span><br></pre></td></tr></table></figure><h3 id="7-Thread-currentThread"><a href="#7-Thread-currentThread" class="headerlink" title="7. Thread.currentThread()"></a>7. Thread.currentThread()</h3><p>通过 Thread.currentThread() 获取当前正在执行的线程对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread currentThread &#x3D; Thread.currentThread();</span><br></pre></td></tr></table></figure><h3 id="8-暂停线程"><a href="#8-暂停线程" class="headerlink" title="8. 暂停线程"></a>8. 暂停线程</h3><p>可以通过 Thread.sheep() 让线程睡眠指定毫秒数。这里不建议使用 thread.suspend() 方法，该方法和 Thread 类的 resume()、stop()、destroy() 都是 JDK 标注废弃方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： Thread.sheep() 方法不会释放CPU资源，如果设置锁的话也不会释放锁资源，只是让线程睡眠指定毫秒数。与 Object 类的 wait() 方法不同， wait() 方法主要用于线程通信，且 wait() 方法会释放锁资源。</p><h3 id="9-停止一个线程"><a href="#9-停止一个线程" class="headerlink" title="9. 停止一个线程"></a>9. 停止一个线程</h3><p>不建议使用 Thread 类提供的 stop() 方法去停止一个线程，stop() 方法会暴力停止一个线程，对程序不友好，可以通过更友好的方式停止一个线程。</p><p>请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private boolean doStop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.doStop &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized boolean keepRunning() &#123;</span><br><span class="line">        return this.doStop &#x3D;&#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(keepRunning()) &#123;</span><br><span class="line">            &#x2F;&#x2F; keep doing what this thread should do.</span><br><span class="line">            System.out.println(&quot;Running&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3L * 1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 doStop() 方法和 keepRunning() 方法使用了 synchronized 关键字，后面会详细讲解 synchronized 关键字的作用，这里不做过多描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnableMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10L * 1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例通过设置一个标识，主线程里面启动子线程，然后主线程睡眠10秒钟后调用 doStop() 方法，实现在主线程中停止子线程的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个Java线程就像一个可以执行你的Java代码的虚拟CPU。&lt;/p&gt;
&lt;p&gt;当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。&lt;/p&gt;
&lt;p&gt;Java 线程都是对象，就像其他的Java对
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 5. 并发和并行</title>
    <link href="http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</id>
    <published>2020-08-11T02:23:36.000Z</published>
    <updated>2020-08-12T02:38:32.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Concurrency-并发"><a href="#1-Concurrency-并发" class="headerlink" title="1. Concurrency 并发"></a>1. Concurrency 并发</h3><p>应用程序中（Application）同时进行一个以上的任务（Task）。对于单CPU的电脑而言，不可能同时进行一个以上的任务，CPU通过交换的执行任务直到任务都被执行完成。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" alt></div></p><hr><h3 id="2-Parallelism-并行"><a href="#2-Parallelism-并行" class="headerlink" title="2. Parallelism 并行"></a>2. Parallelism 并行</h3><p>应用程序中的任务（Task）被切割成多个子任务（SubTask）同时执行。实现并行你的应用程序必须有多个线程在同时执行，并且至少有一个任务在执行（Task）。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" alt></div></p><hr><h3 id="3-Concurrency-vs-Parallelism"><a href="#3-Concurrency-vs-Parallelism" class="headerlink" title="3. Concurrency vs. Parallelism"></a>3. Concurrency vs. Parallelism</h3><ul><li>并发是一个应用程序同时执行多个任务。</li><li>并行是一个应用程序处理单个任务，将单个任务切割成多个子任务并行执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Concurrency-并发&quot;&gt;&lt;a href=&quot;#1-Concurrency-并发&quot; class=&quot;headerlink&quot; title=&quot;1. Concurrency 并发&quot;&gt;&lt;/a&gt;1. Concurrency 并发&lt;/h3&gt;&lt;p&gt;应用程序中（Applic
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 4. 相同线程</title>
    <link href="http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-11T01:02:36.000Z</published>
    <updated>2020-08-12T02:37:19.803Z</updated>
    
    <content type="html"><![CDATA[<p>相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。</p><p>一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。</p><h3 id="1-为什么用单线程系统？"><a href="#1-为什么用单线程系统？" class="headerlink" title="1. 为什么用单线程系统？"></a>1. 为什么用单线程系统？</h3><p>你可能会想为什么每个人都能设计出单线程系统。单线程系统受欢迎的原因是因为单线程系统的并发模型比多线程系统的并发模型更加简单。单线程系统线程之间不共享任何状态（对象/数据），单线程系统可以不使用任何并发数据结构，并且更好地利用CPU和CPU缓存。</p><p>遗憾的是，单线程系统不能很好的利用现代CPU，现代CPU通常情况下拥有多个CPU内核，每个CPU内核的功能就像一个独立的单核CPU，一个单线程系统只能利用CPU中的一个内核，模型如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" alt></div></p><hr><h3 id="2-相同线程（单线程系统的扩展）"><a href="#2-相同线程（单线程系统的扩展）" class="headerlink" title="2. 相同线程（单线程系统的扩展）"></a>2. 相同线程（单线程系统的扩展）</h3><p>为了充分的利用CPU的内核，一个单线程系统可以扩展到利用整个计算机。</p><h5 id="一个CPU内核执行一个线程"><a href="#一个CPU内核执行一个线程" class="headerlink" title="一个CPU内核执行一个线程"></a>一个CPU内核执行一个线程</h5><p>相同线程系统通常让计算机中每个CPU内核执行一个线程，如果一个计算机有4个CPU，每个CPU拥有4个CPU内核，让每个CPU内核执行一个线程的示例如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" alt></div></p><hr><h3 id="3-不共享状态（数据）"><a href="#3-不共享状态（数据）" class="headerlink" title="3. 不共享状态（数据）"></a>3. 不共享状态（数据）</h3><p>一个相同线程系统与传统的多线程系统相似，因为一个相同线程系统有多个线程同时执行，但是两者有一些区别。</p><p>相同线程系统与多线程系统不同的是相同线程系统不共享状态（或不共享数据），当产生并发访问时不共享数据，没有并发数据结构等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" alt></div></p><p>不共享数据让相同线程系统看上去像单线程系统。因为相同线程系统可以包含多个单线程，因此取名相同线程系统更加合理。</p><p>相同线程系统基本含义是进程同时包含处理多个相同的线程，在相同线程系统中并发时没有线程共享数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。&lt;/p&gt;
&lt;p&gt;一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 3. 并发模型</title>
    <link href="http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-09T09:10:45.000Z</published>
    <updated>2020-08-12T02:36:31.157Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。</p><h3 id="1-并发模型与分布式系统相似"><a href="#1-并发模型与分布式系统相似" class="headerlink" title="1. 并发模型与分布式系统相似"></a>1. 并发模型与分布式系统相似</h3><blockquote><ul><li>在一个并发系统中，不同的线程之间相互通信。</li><li>在一个分布式系统中，不同的进程之间相互通信。</li><li>进程和线程在本质上非常的相似。</li></ul></blockquote><p>分布式系统比并发系统面临更多的挑战，比如可能面临网络异常、远程主机或进程停止；并发系统理论上也存在相似的问题，比如CPU异常，内存或硬盘损坏等情况，这种异常的概率相对较小，但实际上是存在的。</p><hr><h3 id="2-共享状态-vs-隔离状态"><a href="#2-共享状态-vs-隔离状态" class="headerlink" title="2. 共享状态 vs 隔离状态"></a>2. 共享状态 vs 隔离状态</h3><h5 id="2-1-共享状态"><a href="#2-1-共享状态" class="headerlink" title="2.1 共享状态"></a>2.1 共享状态</h5><p>共享状态意味着同一系统的多个线程之间共享一些状态（一般指数据，共享一个或多个对象的数据）。当线程共享状态时，容易引发一些并发问题，比如死锁，竞争条件等等，这取决于线程怎样地使用和访问共享数据等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" alt></div></p><h5 id="2-2-隔离状态"><a href="#2-2-隔离状态" class="headerlink" title="2.2 隔离状态"></a>2.2 隔离状态</h5><p>隔离状态意味着同一系统的多个线程之间不共享状态。如果不同的线程之间需要进行通信，可以通过交换不可变对象、或者使用复制的对象进行通信。当多个线程之间不存在共享状态（或共享数据），就可以避免最常见的并发问题。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" alt></div></p><p><strong>备注</strong><br>隔离状态通常情况下可以让代码实现更加简单，并且可以不用担心发生并发访问的问题，避免一些常见的并发问题。在一些特殊情况下，使用分离状态并发设计可能存在更大的挑战。</p><hr><h3 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3. 并发模型"></a>3. 并发模型</h3><h5 id="3-1-Parallel-Workers-并行工作者并发模式"><a href="#3-1-Parallel-Workers-并行工作者并发模式" class="headerlink" title="3.1 Parallel Workers (并行工作者并发模式)"></a>3.1 Parallel Workers (并行工作者并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt></div></p><p><strong>并行工作者模式：</strong><br>传入的工作被分配到不同的工作者去执行，每个工作者执行完整的工作流程。工作者在不同的线程中执行。并行工作者并发模型在 Java 应用程序中很常见，JUC包中很多并发工具类的设计都采用了这种并发模型。 </p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><blockquote><ul><li>非常容易理解：如果要提高并行效率只需要增加更多的工作者</li></ul></blockquote><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><blockquote><ul><li>存在共享状态时实现更加复杂</li><li>工作顺序不固定</li></ul></blockquote><p><strong>缺点1：存在共享状态时实现更加复杂</strong><br>并行工作者模式不同线程存在共享数据时，实现变得更加复杂。共享线程通常需要访问共享对象，不论共享对象存在于内存中还是数据库中。如下图所示<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt></div></p><p>某些共享状态是工作队列中的通信机制，也有些共享状态是业务数据、数据缓存、数据库连接池等等。</p><p>并行工作者并发模式的线程之间存在共享数据时会更加复杂，当一个线程修改了共享数据变量时，需要确保其他线程读取的共享数据变量是最新的（线程修改了共享数据变量应该把数据保存至主内存中，而不是保存至线程独有的CPU高速缓存栈中）。线程需要避免死锁、竞争条件、或者其他共享状态的并发问题。</p><p>当某个线程正在访问共享数据结构时，其他线程会等待正在访问共享数据结构的线程执行完毕，造成阻塞。这可能导致这些线程在竞争共享数据资源，高的竞争条件会导致许多线程访问共享数据时串行执行。</p><p>现代非阻塞并发算法可能降低竞争并且提高性能，但是非阻塞并发算法很难实现。</p><p>持久性数据结构是另一种选择，当持久性数据结构被修改时，他总是保持修改前版本。当多个线程引用了某个持久性数据结构，其中某个线程对持久性数据结构做了修改时，这个修改了持久性数据结构的线程获得了最新的引用数据，而其他的线程保持原来的引用的数据。在共享数据被修改时，持久性数据结构的方式是一个很好的解决方案。</p><blockquote><p>关于持久性数据结构的举例：</p><ul><li>当某个线程给ArrayList添加一个元素时，新添加的元素对其他线程并不可见</li><li>也存在某些缺陷，比如LinkedList， 由于LinkedList是链表的数据结构，链表的每个元素都是一个单独的对象，这种数据结构分布在内存块中的各个地方。然而现代CPU在访问顺序的数据结构时要快的多，比如ArrayList，所以CPU在访问ArrayList时能够表现出更加卓越的性能。CPU能够一次加载一个较大的数组类型的数据结构至高速缓存中，但是无法将一个元素分布至内存各个地方的链表（ListedList）加载到CPU的高速缓存中。</li></ul></blockquote><p><strong>无状态工作者</strong><br>共享数据可以被系统中某个线程修改，其他线程在每次访问共享数据时必须重新读取最新的内存中的数据，以保证线程在执行中时拿到的是最新的内存副本，一个线程不始终保持自己线程独有的CPU高速缓存数据的状态称为无状态。</p><p><strong>缺点2：工作顺序不固定</strong><br>工作A可能被分配给线程A执行，也可能被分配给线程B执行，因此并行工作者模式的执行顺序不是固定的。</p><h5 id="3-2-Assembly-Line-流水线并发模式"><a href="#3-2-Assembly-Line-流水线并发模式" class="headerlink" title="3.2 Assembly Line (流水线并发模式)"></a>3.2 Assembly Line (流水线并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt></div></p><p>这种模式就像工厂中流水线的工人一样，每个工作者只负责整个生产车间的一部分工作，每个工作者负责的这部分工作完成之后会传递给下一个工作者。</p><p>每个工作者在自己的线程内执行，不存在共享状态，流水线并发模式也被称为无共享并发模式。</p><p>流水线并发模式经常在非阻塞IO (NIO) 被设计使用。当一个工作者开始IO操作，其他工作者不需要等待IO操作结束。IO操作很慢，所以等待IO操作完成会浪费大量CPU时间，当IO操作完成时，IO操作的结果会被传递给其他工作者。</p><p>关于NIO， 在IO操作确定工人之间的界限。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt></div></p><p>实际上，工作模式可能不只一条流水线，大多数系统可以设计多条流水线。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt></div></p><p>工作可能并定向到一个工作者进行并行处理。比如一个工作可能同时被分配到工作执行器和日志执行器中执行。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt></div></p><p>流水线并发模式也被称为反应系统或者事件响应系统。</p><p><strong>优点：</strong></p><blockquote><ul><li>不共享状态</li><li>可以顺序执行工作</li></ul></blockquote><p><strong>缺点</strong></p><blockquote><ul><li>作业的执行分散在各个工人</li><li>调试更加复杂</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。&lt;/p&gt;
&lt;h3 id=&quot;1-并发模型与分布式系统相似&quot;&gt;&lt;a href=&quot;#1-并发模型与分布式系统相似&quot; 
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 2. 使用多线程的成本</title>
    <link href="http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/</id>
    <published>2020-08-09T08:31:10.000Z</published>
    <updated>2020-08-12T02:35:21.809Z</updated>
    
    <content type="html"><![CDATA[<p>从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不是靠猜想。</p><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><blockquote><ul><li>更复杂的程序设计</li><li>上下文切换的开销</li></ul></blockquote><p><strong>更复杂的程序设计</strong> </p><blockquote><ul><li>在某些情况下，一个多线程应用程序比单线程应用程序更加简单，但是在某些特殊情况下要更加复杂。</li><li>在多个线程引用了同一个共享变量的情况下，多线程应用程序比单线程应用程序使用起来更加复杂，因为需要考虑线程安全问题，不正确的线程同步问题出现的问题往往防不胜防。</li></ul></blockquote><p><strong>上下文切换的开销</strong> </p><blockquote><ul><li>当一个CPU从当前线程切换的执行另外一个线程时，CPU需要保存当前线程的本地数据以及程序指针等等，再有另外一个线程切换到当前线程时，需要重新读取本地数据和程序指针等，这个交换的执行过程叫做上下文切换。</li><li>上下文切换的成本并不便宜。</li></ul></blockquote><p><strong>减少上下文切换</strong></p><blockquote><ul><li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁。</li><li>CAS算法：Java的atomic包使用CAS算法来更新数据，而不需要加锁。</li><li>使用最少线程：避免创建不需要的线程。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发编程] 1. 并发和多线程</title>
    <link href="http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/"/>
    <id>http://yoursite.com/2020/08/09/Java-Concurrency-and-Multithreading/</id>
    <published>2020-08-09T06:19:56.000Z</published>
    <updated>2020-08-12T02:34:28.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-并发和多线程"><a href="#1-并发和多线程" class="headerlink" title="1. 并发和多线程"></a>1. 并发和多线程</h3><p><strong>并发编程</strong><br>并发编程涵盖了多线程技术在内，指并发执行任务时可能出现的问题，使用的多线程技术，以及解决方案。</p><p><strong>多线程：</strong><br>同一个应用程序中，多个线程同时执行。</p><p><strong>多线程应用程序:</strong><br>多线程应用程序是一个多 CPU 同时执行不同的线程的应用程序。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" alt></div></p><p>一个线程不等于一个CPU，通常情况下一个CPU在不同时间段交换执行不同的线程，不同的CPU同时执行不同的线程。如图：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" alt></div></p><hr><h3 id="2-为什么使用多线程"><a href="#2-为什么使用多线程" class="headerlink" title="2. 为什么使用多线程"></a>2. 为什么使用多线程</h3><blockquote><ul><li>更好的利用单 CPU 资源</li><li>更好的利用多 CPU 或 CPU 内核</li><li>更快速的响应-提高用户体验</li><li>更公平的响应-提高用户体验</li></ul></blockquote><p><strong>更好的利用单 CPU 资源</strong><br>单个CPU通过分配CPU时间片达到交换地执行不同线程的目的，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒。</p><p><strong>更好的利用多 CPU 或 CPU 内核</strong><br>创建多个线程，充分地利用多个CPU同时执行不同的线程，加快程序执行速度，充分利用多CPU资源。</p><p><strong>更快速的响应-提高用户体验</strong><br>充分的利用单CPU资源和多CPU资源都能够加快程序的执行速度，以提高用户体验</p><p><strong>更公平的响应-提高用户体验</strong><br>不同的线程在单CPU中分配CPU时间片交换执行，在某些特定情况下以一种更加公平的方式执行不同的线程。比如某个线程需要调用网络资源或者其他的操作需要长时间占用CPU，导致许多线程需要等待CPU去执行，造成阻塞。</p><hr><h3 id="3-使用多线程不一定更快"><a href="#3-使用多线程不一定更快" class="headerlink" title="3. 使用多线程不一定更快"></a>3. 使用多线程不一定更快</h3><p>由于线程的创建和上下文的切换的开销，多线程的执行效率不一定比单线程的执行效率更好。</p><p><strong>线程创建的方式</strong></p><blockquote><ul><li>继承Thread类，重写 run() 方法</li><li>实现Runnable接口，重写 run() 方法</li><li>实现Callable接口，重写 call() 方法</li></ul></blockquote><p><strong>上下文切换</strong><br>单核处理器也支持多线程执行代码，CPU 通过给每个线程分配CPU时间片来实现这个机制。当前任务执行一个时间片后会切换到下一个任务。但是切换前会保存上一个任务的状态，以便于下次切换到该任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><hr><h3 id="4-多线程-vs-多任务"><a href="#4-多线程-vs-多任务" class="headerlink" title="4. 多线程 vs. 多任务"></a>4. 多线程 vs. 多任务</h3><p><strong>多任务</strong><br>不同CPU同时执行不同的应用程序的不同线程。</p><p><strong>多线程</strong><br>不同CPU同时执行相同的应用程序的不同线程。</p><p><strong>多线程技术更难实现</strong><br>多线程技术可以以一种很好的方式提高某些类型的应用程序的性能。但是多线程技术比多任务技术要面临更多的技术挑战。不同的线程在同一个应用程序中同时执行，它们可能存在一个线程在读取共享内存的数据，另外一个线程在写入数据至共享内存，造成线程不安全的问题发生，以至于产生了单线程技术通常情况下不会发生的错误。</p><p>现代计算机通常拥有多个CPU或者多个CPU内核，这意味着不同的线程可以被不同的CPU同时执行。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" alt></div></p><hr><h3 id="5-Java-中的并发和多线程"><a href="#5-Java-中的并发和多线程" class="headerlink" title="5. Java 中的并发和多线程"></a>5. Java 中的并发和多线程</h3><p><strong>并发模型</strong></p><blockquote><ul><li>共享状态并发模型（shared state concurrency model）</li><li>隔离状态并发模型（separate state concurrency model）</li></ul></blockquote><p><strong>共享状态并发模型</strong><br>同一个应用程序中的不同的线程使用了同一个共享对象（或变量）。在共享状态并发模型中存在很多问题，这些问题难以完美地解决。</p><p><strong>隔离状态并发模型</strong><br>同一个应用程序中的不同的线程不共享任何对象（或变量）。</p><hr><h3 id="Java-并发学习指南"><a href="#Java-并发学习指南" class="headerlink" title="Java 并发学习指南"></a>Java 并发学习指南</h3><p><strong>并发和多线程理论知识</strong></p><blockquote><ul><li>多线程的好处</li><li>多线程的成本</li><li>并发模型</li><li>同一线程</li><li>并发 vs. 并行</li></ul></blockquote><p><strong>Java并发的基础理论知识</strong></p><blockquote><ul><li>创建和开始一个线程</li><li>线程安全和共享资源</li><li>线程安全和不变性</li><li>JMM (Java memory model)</li><li>synchronize 关键字</li><li>volatile 关键字</li><li>ThreadLocal </li></ul></blockquote><p><strong>Java 并发常见问题</strong></p><blockquote><ul><li>死锁</li><li>预防死锁</li></ul></blockquote><p><strong>Java 提供的一些解决常见问题的工具</strong></p><blockquote><ul><li>Lock （锁）</li><li>Read / Write Lock （读写锁）</li><li>ReentrantLock （可重入锁）</li><li>Semaphores （信号）</li><li>Blocking Queues （阻塞队列）</li><li>Thread Pools （线程池）</li><li>Compare and Swap （CAS）</li></ul></blockquote><p><strong>Java 并发工具包 （JUC: java.util.concurrent）</strong></p><blockquote><ul><li>Java Concurrency Utilities - java.util.concurrent</li></ul></blockquote><hr><p><strong>推荐</strong></p><blockquote><p>&lt;Java 并发编程的艺术&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-并发和多线程&quot;&gt;&lt;a href=&quot;#1-并发和多线程&quot; class=&quot;headerlink&quot; title=&quot;1. 并发和多线程&quot;&gt;&lt;/a&gt;1. 并发和多线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;并发编程&lt;/strong&gt;&lt;br&gt;并发编程涵盖了多线程技术在内，指并发执
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并行流</title>
    <link href="http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    <id>http://yoursite.com/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/</id>
    <published>2020-07-09T11:21:09.000Z</published>
    <updated>2020-07-09T11:21:09.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数式数据处理</title>
    <link href="http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-07-01T11:22:34.000Z</published>
    <updated>2020-07-08T06:04:24.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h2><p>概念：</p><blockquote><ul><li>Stream：支持数据处理操作的源（集合、数组、输入/输出资源）生成的元素序列 。</li><li>备注： 流是Java 8 API的新成员，它允许你以声明性方式处理数据集合。</li><li><a href="https://miracle-sungm.github.io/2020/06/13/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">Lambda表达式博客链接</a>   </li></ul></blockquote><p>定义：</p><blockquote><ol><li>源： 流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li>元素序列： 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。</li><li>数据处理操作: 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ol></blockquote><p>特点：</p><blockquote><ol><li>流水线： 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li><li>内部迭代： 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ol></blockquote><p>流的特性：</p><blockquote><ol><li>只能遍历一次。和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</li></ol></blockquote><p>Stream API 带来的好处：</p><blockquote><ul><li>声明性 ： 更简洁易读</li><li>可复合 ： 更灵活</li><li>可并行 ： 性能更好</li></ul></blockquote><p>流与集合</p><blockquote><p>粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，集合中的每个元素都得先计算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</p></blockquote><p>流与集合的差异：</p><blockquote><ol><li>遍历数据的方式不同。使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</li><li>//TODO 待补充</li></ol></blockquote><h2 id="2-使用-Stream"><a href="#2-使用-Stream" class="headerlink" title="2. 使用 Stream"></a>2. 使用 Stream</h2><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><div class="table-responsive"><table class="table table-bordered table-striped"><thead><tr><th align="left">操作</th><th align="left">类型</th><th align="left">返回类型</th><th align="left">函数式接口</th><th align="left">函数描述符</th></tr></thead><tbody><tr><td align="left">filter</td><td align="left">中间</td><td align="left">Stream<T></T></td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">distinct</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">skip</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">limit</td><td align="left">中间(有状态 &amp; 有界)</td><td align="left">Stream<T> long</T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">map</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, R&gt;</td><td align="left">T -&gt; R</td></tr><tr><td align="left">flatMap</td><td align="left">中间</td><td align="left">Stream<R></R></td><td align="left">Function&lt;T, Stream<R>&gt;</R></td><td align="left">T -&gt; Stream<R></R></td></tr><tr><td align="left">sorted</td><td align="left">中间(有状态 &amp; 无界)</td><td align="left">Stream<T></T></td><td align="left">Comparator<T></T></td><td align="left">(T, T) -&gt; int</td></tr><tr><td align="left">anyMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">noneMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">allMatch</td><td align="left">终端</td><td align="left">boolean</td><td align="left">Predicate<T></T></td><td align="left">T -&gt; boolean</td></tr><tr><td align="left">findAny</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">findFirst</td><td align="left">终端</td><td align="left">Optional<T></T></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">forEach</td><td align="left">终端</td><td align="left">void</td><td align="left">Consumer<T></T></td><td align="left">T -&gt; void</td></tr><tr><td align="left">collect</td><td align="left">终端</td><td align="left">R</td><td align="left">Collector&lt;T, A, R&gt;</td><td align="left"></td></tr><tr><td align="left">reduce</td><td align="left">终端(有状态 &amp; 有界)</td><td align="left">Optional<T></T></td><td align="left">BinaryOperator<T></T></td><td align="left">(T, T) -&gt; T</td></tr><tr><td align="left">count</td><td align="left">终端</td><td align="left">long</td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>过滤流元素：该操作会接受一个 Predicate 函数式接口对象（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;过滤出元素小于5的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().filter(number -&gt; number &lt; 5).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h4 id="2-2-distinct"><a href="#2-2-distinct" class="headerlink" title="2.2 distinct"></a>2.2 distinct</h4><p>对流元素去重：根据流元素的hashCode和equals方法判断元素是否重复。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 1, 1, 2, 2, 2, 3, 3);</span><br><span class="line">    &#x2F;&#x2F;去重数据</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="2-3-limit"><a href="#2-3-limit" class="headerlink" title="2.3 limit"></a>2.3 limit</h4><p>截断流：该操作会接受一个 int 类型的入参，返回一个不超过给定长度的流。（如果流是有序的，则最多返回前 n 个元素）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;截断前2个元素</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().limit(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><h4 id="2-4-skip"><a href="#2-4-skip" class="headerlink" title="2.4 skip"></a>2.4 skip</h4><p>跳过元素：该操作会接受一个 int 类型的入参，返回扔掉前 n 个元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;跳过前2个元素，返回剩余元素的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().skip(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>映射元素： 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;将int元素映射成String元素</span><br><span class="line">    List&lt;String&gt; result &#x3D; numbers.stream().map(Object::toString).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h4 id="2-6-flatMap"><a href="#2-6-flatMap" class="headerlink" title="2.6 flatMap"></a>2.6 flatMap</h4><p>扁平化流： 当流的元素可以转换成另外一个流时，扁平化流会得到一个流元素的流。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; a &#x3D; Arrays.asList(&quot;a&quot;, &quot;a1&quot;);</span><br><span class="line">    List&lt;String&gt; b &#x3D; Arrays.asList(&quot;b&quot;, &quot;b1&quot;);</span><br><span class="line">    List&lt;String&gt; c &#x3D; Arrays.asList(&quot;c&quot;, &quot;c1&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listList &#x3D; Arrays.asList(a, b, c);</span><br><span class="line">    &#x2F;&#x2F;扁平化流：将 Stream&lt;List&lt;String&gt;&gt; 流转换成一个新的 Stream&lt;String&gt; 流。</span><br><span class="line">    List&lt;String&gt; list &#x3D; listList.stream().flatMap(List::stream).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">[a, a1, b, b1, c, c1]</span><br></pre></td></tr></table></figure><h4 id="2-7-anyMatch"><a href="#2-7-anyMatch" class="headerlink" title="2.7 anyMatch"></a>2.7 anyMatch</h4><p>判断流中是否存在元素与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否存在与谓词匹配。（注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回true）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    if (numbers.stream().anyMatch(number -&gt; number &#x3D;&#x3D; 2)) &#123;</span><br><span class="line">        System.out.println(&quot;成功匹配到数字2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">成功匹配到数字2</span><br></pre></td></tr></table></figure><h4 id="2-8-allMatch"><a href="#2-8-allMatch" class="headerlink" title="2.8 allMatch"></a>2.8 allMatch</h4><p>判断流中所有元素是否都与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都与谓词匹配。 （注意：该方法执行时，若找到一个不匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39;,&#39;结尾</span><br><span class="line">    if (list.stream().allMatch(s -&gt; s.endsWith(&quot;,&quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素均以&#39;,&#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素均以&#39;,&#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-9-nonMatch"><a href="#2-9-nonMatch" class="headerlink" title="2.9 nonMatch"></a>2.9 nonMatch</h4><p>与allMatch相反，nonMatch是判断流中所有元素是否都不与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都不与谓词匹配。 （注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回false）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39; &#39;结尾</span><br><span class="line">    if (list.stream().noneMatch(s -&gt; s.endsWith(&quot; &quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素都不以&#39; &#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素都不以&#39; &#39;结尾</span><br></pre></td></tr></table></figure><h4 id="2-10-findFirst"><a href="#2-10-findFirst" class="headerlink" title="2.10 findFirst"></a>2.10 findFirst</h4><p>找到流中第一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中第一个元素。（注意：该方法执行时，找到第一个元素之后，则终止操作，并返回包含第一个元素的Optional对象）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到第一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findFirst();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="2-11-findAny"><a href="#2-11-findAny" class="headerlink" title="2.11 findAny"></a>2.11 findAny</h4><p>找到流中任何一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中任何一个元素。（注意：该方法执行时，找到任何一个元素之后，则终止操作，并返回包含匹配的元素的Optional对象。该方法在并行情况下效率更佳）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到任何一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findAny();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>何时使用 findFirst 和 findAny</strong></p><blockquote><p>你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p></blockquote><h4 id="2-12-reduce"><a href="#2-12-reduce" class="headerlink" title="2.12 reduce"></a>2.12 reduce</h4><p>规约：包含2个方法</p><p><strong>第一个方法</strong></p><p>该方法接受一个与流元素类型相同的泛型对象 T 和一个 BinaryOperator(该类继承了BiFunction)对象；返回一个与流元素类型相同的规约后的对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure></p><p><strong>第二个方法</strong></p><p>该方法接受一个 BinaryOperator<T> 对象；返回 Optional<T> 对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></T></T></p><p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer::sum);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce((a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最大值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:max);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最小值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:min);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p><strong>2个方法的区别</strong></p><blockquote><p>第一个方法接受了一个对象，执行规约方法时会将入参与流中的元素规约到一起。<br>第二个方法只对流中的元素进行规约，因为源可能是空的，所以返回一个Optional对象。</p></blockquote><h4 id="2-13-count"><a href="#2-13-count" class="headerlink" title="2.13 count"></a>2.13 count</h4><p>对流中元素进行计数，返回一个long类型的对象。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().count();</span><br><span class="line">    System.out.println(count));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="2-14-注意："><a href="#2-14-注意：" class="headerlink" title="2.14 注意："></a>2.14 注意：</h4><blockquote><ul><li>filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你用不着为了让某些数据处理任务并行而去操心线程和锁了，Stream API都替你做好了！</li><li>对于流而言，某些操作（例如allMatch、anyMatch、noneMatch、findFirst和findAny）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流</li></ul></blockquote><hr><h2 id="3-数值流"><a href="#3-数值流" class="headerlink" title="3. 数值流"></a>3. 数值流</h2><p>我们在计算流中元素总和时，通常情况下会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码问题是它暗藏拆箱成本。每个Integer都必须拆成一个原始类型再进行求和。</p><h4 id="3-1-原始类型特化"><a href="#3-1-原始类型特化" class="headerlink" title="3.1 原始类型特化"></a>3.1 原始类型特化</h4><p>说明：</p><blockquote><p>Java 8 引入了三个原始类型特化流接口来解决上面这个暗藏拆箱成本的问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。要记住的是，这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和Integer之间的效率差异。</p></blockquote><p><strong>映射到数值流</strong></p><blockquote><ul><li>mapToInt：    映射成IntStream</li><li>mapToLong：   映射成LongStream</li><li>mapToDouble： 映射成DoubleStream</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;映射到数值流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).sum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换回对象流</strong></p><p>通过boxed()方法，转换回对象流，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过boxed()方法，转换回对象流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).boxed().reduce(0, Integer::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).boxed().reduce(0L, Long::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).boxed().reduce(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值</strong></p><p>对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。</p><p><strong>数值范围</strong></p><p>通过使用range() 和 rangeClosed() 方法生成数值范围。</p><blockquote><ul><li>range(int startInclusive, int endExclusive) 方法： 生成 [startInclusive, endExclusive) 范围内数值流（左闭右开）。</li><li>rangeClosed(int startInclusive, int endInclusive) 方法： 生成 [startInclusive, endInclusive] 范围内数值流（左闭右闭）。</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(IntStream.range(1, 100).count());</span><br><span class="line">    System.out.println(IntStream.rangeClosed(1, 100).count());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td></tr></table></figure><hr><h2 id="4-构建流"><a href="#4-构建流" class="headerlink" title="4. 构建流"></a>4. 构建流</h2><p>这里主要介绍由集合、数值、数组、文件来创建流；最后介绍下由生成函数来创建无限流。</p><h4 id="4-1-由集合生成流"><a href="#4-1-由集合生成流" class="headerlink" title="4.1 由集合生成流"></a>4.1 由集合生成流</h4><p>Java 8 的 Collection 新增了 stream() 的 Api，集合对象通过调用 stream() 方法生成流。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;sungm&quot;, &quot;other&quot;);</span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure><h4 id="4-2-由数值生成流"><a href="#4-2-由数值生成流" class="headerlink" title="4.2 由数值生成流"></a>4.2 由数值生成流</h4><p>通过 Stream.of() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;sungm&quot;, &quot;other&quot;);</span><br></pre></td></tr></table></figure><h4 id="4-3-由数组生成流"><a href="#4-3-由数组生成流" class="headerlink" title="4.3 由数组生成流"></a>4.3 由数组生成流</h4><p>通过 Arrays.stream() 方法生成流</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(numbers);</span><br></pre></td></tr></table></figure><h4 id="4-4-由文件生成流"><a href="#4-4-由文件生成流" class="headerlink" title="4.4 由文件生成流"></a>4.4 由文件生成流</h4><p>java nio</p><blockquote><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。例如：Files.lines()方法</p></blockquote><h4 id="4-5-函数生成流：创建无限流"><a href="#4-5-函数生成流：创建无限流" class="headerlink" title="4.5 函数生成流：创建无限流"></a>4.5 函数生成流：创建无限流</h4><p>Stream.iterate()方法和Stream.generate()方法：</p><blockquote><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;我们通过使用limit()方法来截断流</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>无限流是没有固定大小的流</p></blockquote><hr><h2 id="5-用流收集数据"><a href="#5-用流收集数据" class="headerlink" title="5. 用流收集数据"></a>5. 用流收集数据</h2><h4 id="5-1-Collectors-收集器"><a href="#5-1-Collectors-收集器" class="headerlink" title="5.1 Collectors (收集器)"></a>5.1 Collectors (收集器)</h4><p><strong>简介</strong></p><blockquote><ul><li>Stream类的collect方法是一个终端操作，类似于Stream类的reduce方法，可以接受做法作为参数，将流中的元素累积成一个汇总结果，而collect方法接受的就是一个 Collector 对象。</li><li>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）；再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。</li><li>Collectors 非常有用，因为它可以简洁和灵活的定义collect用来生成结果集合的标准。更具体地说，对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）</li><li>Collectors 是 Collector 的工厂类。</li></ul></blockquote><p><strong>预定义收集器</strong></p><p>Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p><blockquote><p>将流元素归约和汇总为一个值<br>元素分组<br>元素分区</p></blockquote><h4 id="5-2-归约和汇总"><a href="#5-2-归约和汇总" class="headerlink" title="5.2 归约和汇总"></a>5.2 归约和汇总</h4><h5 id="5-2-1-counting-计数"><a href="#5-2-1-counting-计数" class="headerlink" title="5.2.1 counting (计数)"></a>5.2.1 counting (计数)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().collect(Collectors.counting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>使用 number.stream().count() 进行计数更直接，但是counting收集器在和其他收集器联合使用的时候特别有用。</p></blockquote><h5 id="5-2-2-maxBy-最大值"><a href="#5-2-2-maxBy-最大值" class="headerlink" title="5.2.2 maxBy (最大值)"></a>5.2.2 maxBy (最大值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; maxNumber &#x3D; numbers.stream().collect(Collectors.maxBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().max(Comparator.comparingInt(a -&gt; a)) 获取最大值</p></blockquote><h5 id="5-2-3-minBy-最小值"><a href="#5-2-3-minBy-最小值" class="headerlink" title="5.2.3 minBy (最小值)"></a>5.2.3 minBy (最小值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; minNumber &#x3D; numbers.stream().collect(Collectors.minBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以使用 numbers.stream().min(Comparator.comparingInt(a -&gt; a)) 获取最小值</p></blockquote><h5 id="5-2-4-summingInt、summarizingLong、summarizingDouble-求和"><a href="#5-2-4-summingInt、summarizingLong、summarizingDouble-求和" class="headerlink" title="5.2.4 summingInt、summarizingLong、summarizingDouble (求和)"></a>5.2.4 summingInt、summarizingLong、summarizingDouble (求和)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求和</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>也可以将流转换成数值流之后再对数值流进行求和，例如： numbers.stream().maoToInt(a -&gt; a).sum()。</p></blockquote><h5 id="5-2-5-averagingInt、averagingLong、averagingDouble-求平均值"><a href="#5-2-5-averagingInt、averagingLong、averagingDouble-求平均值" class="headerlink" title="5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)"></a>5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求平均值</span><br><span class="line">    double averagingInt &#x3D; numbers.stream().collect(Collectors.averagingInt(a -&gt; a));</span><br><span class="line">    double averagingLong &#x3D; numbers.stream().collect(Collectors.averagingLong(a -&gt; (long) a));</span><br><span class="line">    double averagingDouble &#x3D; numbers.stream().collect(Collectors.averagingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结"><a href="#5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结" class="headerlink" title="5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)"></a>5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;对数值进行总结，获取流元素的数值和、最大值、最小值、平均值、计数。</span><br><span class="line">    IntSummaryStatistics intSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    LongSummaryStatistics longSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    DoubleSummaryStatistics doubleSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line"></span><br><span class="line">    System.out.println(intSummaryStatistics.toString());</span><br><span class="line">    System.out.println(longSummaryStatistics.toString());</span><br><span class="line">    System.out.println(doubleSummaryStatistics.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">IntSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">LongSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">DoubleSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36.000000, min&#x3D;1.000000, average&#x3D;4.500000, max&#x3D;8.000000&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>通过一次 summarizing 操作你可以就计算出元素的个数，并得到元素总和、平均值、最大值和最小值。</p></blockquote><h5 id="5-2-7-join-连接字符串"><a href="#5-2-7-join-连接字符串" class="headerlink" title="5.2.7 join 连接字符串"></a>5.2.7 join 连接字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;);</span><br><span class="line">    &#x2F;&#x2F;直接连接字符串</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining()));</span><br><span class="line">    &#x2F;&#x2F;字符串之间用指定的delimiter(定界符)连接字符</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining(&quot;, &quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">OneTwoThreeFourFiveSix</span><br><span class="line">One, Two, Three, Four, Five, Six</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>某些情况下，可以使用String.join()方法更直接。 例如：String.join(“, “, list);</p></blockquote><h4 id="5-2-8-reducing-规约-5-2章节的重点"><a href="#5-2-8-reducing-规约-5-2章节的重点" class="headerlink" title="5.2.8 reducing 规约(5.2章节的重点)"></a>5.2.8 reducing 规约(5.2章节的重点)</h4><p><strong>Collectors类中存在3个reducing()方法，下面我们逐个介绍</strong></p><blockquote><ul><li>reducing(Object, Function, BinaryOperator)</li><li>reducing(Object, BinaryOperator)</li><li>reducing(BinaryOperator)</li></ul></blockquote><p><strong>说明：</strong></p><blockquote><p>我们上面讨论的7种方法（5.2.1 - 5.2.7）都是一个可以用 reducing 工厂方法定义的归约过程的特殊情况而已。Collectors.reducing 工厂方法是所有这些特殊情况的一般化。<br>Collectors类中存在3个reducing()方法功能类似。</p></blockquote><p><strong>方法一：reducing(Object, Function, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? super T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口Function对象，该Function对象将流元素对象转换成你所需要进行规约操作的对象</li><li>该方法第三个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 成绩</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-07-05 14:32</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Grade &#123;</span><br><span class="line"></span><br><span class="line">    private String studentName;</span><br><span class="line">    private String course;</span><br><span class="line">    private Double score;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter、setter、toString、以及无参构造方法和全参构造方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().collect(Collectors.reducing(0D, Grade::getScore, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：reducing(Object, BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, T&gt;</span><br><span class="line">reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0],</span><br><span class="line">            CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li><li>该方法第二个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：reducing(BinaryOperator) 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    class OptionalBox implements Consumer&lt;T&gt; &#123;</span><br><span class="line">        T value &#x3D; null;</span><br><span class="line">        boolean present &#x3D; false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void accept(T t) &#123;</span><br><span class="line">            if (present) &#123;</span><br><span class="line">                value &#x3D; op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                value &#x3D; t;</span><br><span class="line">                present &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::new, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; if (b.present) a.accept(b.value); return a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>该方法入参是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li><li>该方法返回一个Optional<T>类的对象。</T></li></ul></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学视所有课程的总成绩</span><br><span class="line">    Optional&lt;Double&gt; score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别"><a href="#5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别" class="headerlink" title="5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别"></a>5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别</h4><p> 示例：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 8)</span><br><span class="line">        .boxed()</span><br><span class="line">        .reduce(new ArrayList&lt;&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; &#123;</span><br><span class="line">            l.add(e);</span><br><span class="line">            return l;</span><br><span class="line">        &#125;, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; &#123;</span><br><span class="line">            l1.addAll(l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>区别:</p><blockquote><p>Stream类的reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反，collect方法的设计就是要改变容器，从而累积要输出的结果。这意味着，上面的示例的代码片段是在滥用reduce方法，因为它在原地改变了作为累加器的List。<br>以错误的语义使用Stream类的reduce方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏List本身。在这种情况下，如果你想要线程安全，就需要每次分配一个新的List，而对象分配又会影响性能。这就是collect方法特别适合表达可变容器上的归约的原因，更关键的是它适合并行操作</p></blockquote><p>使用收集器的的好处：</p><blockquote><ul><li>灵活性更强：可以以不同的方法执行同样的操作。</li><li>根据情况选择最佳解决方案：收集器在某种程度上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</li></ul></blockquote><p><strong>建议：</strong></p><blockquote><p>就实际应用而言，建议使用Collectors类的reduce方法，无轮从可读性还是性能上讲，Collectors类的reduce方法都更好。</p></blockquote><h2 id="5-3-分组"><a href="#5-3-分组" class="headerlink" title="5.3 分组"></a>5.3 分组</h2><h4 id="5-3-1-groupingBy-分组"><a href="#5-3-1-groupingBy-分组" class="headerlink" title="5.3.1 groupingBy 分组"></a>5.3.1 groupingBy 分组</h4><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(1L, &quot;miracle&quot;, 25, &quot;Boy&quot;)</span><br><span class="line">            , new Student(2L, &quot;bob&quot;, 24, &quot;Boy&quot;)</span><br><span class="line">            , new Student(3L, &quot;lucky&quot;, 22, &quot;Girl&quot;)</span><br><span class="line">            , new Student(3L, &quot;lusa&quot;, 24, &quot;Girl&quot;));</span><br><span class="line">    &#x2F;&#x2F;按照性别分组</span><br><span class="line">    Map&lt;String, List&lt;Student&gt;&gt; map &#x3D; students.stream().collect(Collectors.groupingBy(Student::getSex));</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#123;</span><br><span class="line">    Girl&#x3D;[Student&#123;id&#x3D;3, name&#x3D;&#39;lucky&#39;, age&#x3D;22, sex&#x3D;&#39;Girl&#39;&#125;, Student&#123;id&#x3D;3, name&#x3D;&#39;lusa&#39;, age&#x3D;24, sex&#x3D;&#39;Girl&#39;&#125;], </span><br><span class="line">    Boy&#x3D;[Student&#123;id&#x3D;1, name&#x3D;&#39;miracle&#39;, age&#x3D;25, sex&#x3D;&#39;Boy&#39;&#125;, Student&#123;id&#x3D;2, name&#x3D;&#39;bob&#39;, age&#x3D;24, sex&#x3D;&#39;Boy&#39;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>示例中给groupingBy传入一个Function，我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p></blockquote><p>groupingBy源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    return groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Stream&quot;&gt;&lt;a href=&quot;#1-Stream&quot; class=&quot;headerlink&quot; title=&quot;1. Stream&quot;&gt;&lt;/a&gt;1. Stream&lt;/h2&gt;&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Stream：支持数据处理操
      
    
    </summary>
    
    
    
      <category term="Java 8 新特性" scheme="http://yoursite.com/tags/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="http://yoursite.com/2020/06/28/Effective-Java-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/28/Effective-Java-%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-28T12:00:48.000Z</published>
    <updated>2020-06-30T03:29:46.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-考虑使用静态工厂方法代替构造方法"><a href="#1-考虑使用静态工厂方法代替构造方法" class="headerlink" title="1. 考虑使用静态工厂方法代替构造方法"></a>1. 考虑使用静态工厂方法代替构造方法</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-静态工厂方法代替构造方法的优缺点"><a href="#1-1-静态工厂方法代替构造方法的优缺点" class="headerlink" title="1.1 静态工厂方法代替构造方法的优缺点"></a>1.1 静态工厂方法代替构造方法的优缺点</h4><blockquote><p>优点：</p><ul><li>静态工厂方法不需要每次都创建一个对象，而构造方法每次都会创建一个对象。</li><li>静态工厂方法返回值可以是任何对象，而构造方法返回指定的对象。</li><li>静态工厂方法返回值可以根据入参的不同而不同。</li><li>静态工厂方法有自定义的方法名，构造方法方法名与类名相同。</li></ul></blockquote><blockquote><p>缺点:</p><ul><li>限制：没有公共或受保护的构造方法不能被子类化。（假如定义一个Person类，且该类没有公共或受保护的构造函数，如果我们想定义一个类来继承Person类，将发生编译错误）</li><li>静态方法不如构造方法易发现，不仔细阅读源码我们很难找到他们。</li></ul></blockquote><h4 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h4><blockquote><ul><li>定义静态工厂方法代替构造方法时，建议将构造方法设置成私有的（private）或受保护的（protected）。</li><li>如果定义一个静态工厂方法用来代替构造方法，且静态构造方法每次被调用都返回一个新对象，那么使用静态工厂方法代替构造方法将意义不大。</li><li>根据需要，重载静态工厂方法。</li></ul></blockquote><hr><h2 id="2-当构造方法参数过多时，使用Builder模式"><a href="#2-当构造方法参数过多时，使用Builder模式" class="headerlink" title="2 当构造方法参数过多时，使用Builder模式"></a>2 当构造方法参数过多时，使用Builder模式</h2><p>说明：</p><blockquote><p>使用Builder模式可以使用简化代码，提高代码可读性。（这里对Builder模式不做过多的解释，若您想了解Builder模式，请百度。）</p></blockquote><h4 id="2-1-方式一：使用Lombok插件"><a href="#2-1-方式一：使用Lombok插件" class="headerlink" title="2.1 方式一：使用Lombok插件"></a>2.1 方式一：使用Lombok插件</h4><blockquote><p> 安装Lombok插件，引入Lombok依赖之后使用Lombok的@Builder注解。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义响应值</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-23 17:28</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">public class ResponseDTO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;序列化</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    private String resultCode;</span><br><span class="line">    private String resultMessage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主函数</span><br><span class="line"> * </span><br><span class="line"> * @param args      入参</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ResponseDTO response &#x3D; ResponseDTO.builder()</span><br><span class="line">        .resultCode(ResultEnum.ONE.getResultCode())</span><br><span class="line">        .resultMessage(ResultEnum.ONE.getResultMessage())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>使用Lombok插件还是蛮香的，我们可以通过使用Lombok定义的注解，来减少了我们编写的代码量、提高了代码可读性，但是Lombok插件会增加我们程序编译的时间，且通常情况下我们也可以通过使用IDEA的快捷键来自动生成代码。</p></blockquote><h4 id="2-2-方式二：使用通用Builder工具类"><a href="#2-2-方式二：使用通用Builder工具类" class="headerlink" title="2.2 方式二：使用通用Builder工具类"></a>2.2 方式二：使用通用Builder工具类</h4><p>Builder工具类博客地址：</p><blockquote><p><a href="https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/" target="_blank" rel="noopener">https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/</a></p></blockquote><h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><blockquote><ul><li>对于方式一和方式二的选择，仁者见仁智者见智，你更喜欢哪种方式呢？或者你还有其他更好的方式？</li></ul></blockquote><hr><h2 id="3-使用私有构造方法或枚举实现单例模式"><a href="#3-使用私有构造方法或枚举实现单例模式" class="headerlink" title="3. 使用私有构造方法或枚举实现单例模式"></a>3. 使用私有构造方法或枚举实现单例模式</h2><p>说明：</p><blockquote><p>单例是一个仅实例化一次的类，通常情况下表示无状态对象。</p></blockquote><h4 id="3-1-使用私有构造方法实现单例模式"><a href="#3-1-使用私有构造方法实现单例模式" class="headerlink" title="3.1 使用私有构造方法实现单例模式"></a>3.1 使用私有构造方法实现单例模式</h4><p><em>两种常见的单例模式实现方式</em></p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明公共属性的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonOne &#123;</span><br><span class="line"></span><br><span class="line">    public static final SingletonOne INSTANCE &#x3D; new SingletonOne();</span><br><span class="line"></span><br><span class="line">    private SingletonOne() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明静态工厂方法的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonTwo &#123;</span><br><span class="line"></span><br><span class="line">    private static final SingletonTwo INSTANCE &#x3D; new SingletonTwo();</span><br><span class="line"></span><br><span class="line">    private SingletonTwo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonTwo getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><ul><li>方式一和方式二的构造函数都是私有构造函数，且定义了一个 static final 类型的INSTANCE变量，并使其实例化，确保了该类只能被实例化一次，保证了全局的唯一性。</li><li>不论是方式一还是方式二，特殊情况下可以通过使用反射的方式调用构造方法创建对象，如果需要防止此操作的产生，需修改构造方法，使其请求创建第二个对象时抛出异常。</li></ul></blockquote><p>建议：</p><blockquote><p>建议通过静态工厂方法（方式二）来创建单例。原因是通过静态工厂的方式更加灵活，并且可以根据需要设计泛型单例工厂，并且还能使用函数式接口Supplier，例如Singleton::getInstance。</p></blockquote><h4 id="3-2-通过使用枚举设计单例模式"><a href="#3-2-通过使用枚举设计单例模式" class="headerlink" title="3.2 通过使用枚举设计单例模式"></a>3.2 通过使用枚举设计单例模式</h4><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是单一元素枚举类通常是实现单例的最佳方式。</p></blockquote><p>注意：</p><blockquote><p>如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p></blockquote><hr><h2 id="4-使用私有构造方法执行非实例化"><a href="#4-使用私有构造方法执行非实例化" class="headerlink" title="4. 使用私有构造方法执行非实例化"></a>4. 使用私有构造方法执行非实例化</h2><p>场景说明：</p><blockquote><p>当我们希望设计一个类只包含静态方法和静态属性时，为了避免这样的类被实例化，可以通过声明私有的构造方法达到类不被实例化的目的。</p></blockquote><p>副作用：</p><blockquote><p>当我们想设计一个子类来继承私有化构造函数的父类时，将报编译异常。因为所有构造方法都必须显示或者隐式的调用父类的构造方法，若父类的构造函数被私有化，则子类没有访问父类构造函数的权限，因此报错。</p></blockquote><hr><h2 id="5-比起硬资源连接，优先使用依赖注入"><a href="#5-比起硬资源连接，优先使用依赖注入" class="headerlink" title="5. 比起硬资源连接，优先使用依赖注入"></a>5. 比起硬资源连接，优先使用依赖注入</h2><p>硬资源连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Dictionary &#123;</span><br><span class="line">    &#x2F;&#x2F;定义字典</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;硬资源连接：想当然的认为一本字典就够了，无法承载多字典的场景</span><br><span class="line">    private static final Dictionary DICTIONARY &#x3D; new ChineseDictionary();</span><br><span class="line"></span><br><span class="line">    private SpellChecker() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义字典接口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义中文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ChineseDictionary implements Dictionary&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义英文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EnglishDictionary implements Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 拼写检查器</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    private final Dictionary DICTIONARY;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用依赖注入的方式，创建对象时将字典注入到对象属性中</span><br><span class="line">    public SpellChecker(Dictionary dictionary) &#123;</span><br><span class="line">        this.DICTIONARY &#x3D; dictionary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>当一个类依赖于一个或多个底层资源时，该类的实现方式不要使用单例或静态的实用类，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p></blockquote><hr><h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>说明：</p><blockquote><p>通常情况下，重用对象比创建一个相同功能的对象的做法更恰当，重用可以使程序更快的执行且耗用更少的内存。如果一个对象是不可变的，他总是可以被重用。</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请不要这样写代码</span><br><span class="line">String name &#x3D; new String(&quot;sungm&quot;);</span><br></pre></td></tr></table></figure><p>这样写代码产生的结果：</p><blockquote><p>该语句每次执行时都会创建一个新的String实例，并且这些对象都不是必须的。String的构造方法String(String original)的入参original本身就是一个String实例，它与构造方法创建的对象的功能相同。</p></blockquote><p>优化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; &quot;sungm&quot;;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过使用静态工厂方法，可以避免创建不必要的对象。<blockquote><p>例如：使用静态工厂方法 Boolean.parseBoolean(String) 比构造方法 Boolean(String) 好的多，构造方法每次调用都会创建一个新的对象，而工厂方法永远不需要这样做，在实践中也不需要。</p></blockquote></li><li>一些对象的创建比其他对象的创建的代价要昂贵的多，如果要使用这样一个昂贵的对象，建议将其缓存起来以便重复使用。<blockquote><p>例如创建创建正则表达式的 Pattern 对象，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p></blockquote></li><li>当一些对象是不可变（final定义的对象）的时侯，很明显它可以被重用，但是在其他情况下，没有很明显的可以被重用，这种情况下需谨慎考虑是否重用对象。</li><li>自动装箱的情况下是不需要创建不必要的对象的，自动装箱允许程序员混用基本数据类型和装箱类型，根据需要自动装箱和拆箱。<blockquote><p>建议：优先使用基本数据类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p></blockquote></li></ul><hr><h2 id="7-消除过期对象的引用"><a href="#7-消除过期对象的引用" class="headerlink" title="7. 消除过期对象的引用"></a>7. 消除过期对象的引用</h2><p>举例：</p><blockquote><p>《Effective Java》原书中该章节举了一个栈（Stock）弹出元素（pop）没有及时清空弹出的元素引用，当Stock扩容后收缩，容易发生内存溢出异常。</p></blockquote><p>好处：</p><blockquote><ul><li>及时消除过期对象的引用，减少内存消耗，增加程序执行速度，同时可以避免因内存溢出导致程序异常。</li><li>消除过期对象的引用有一个好处是程序错误的引用过期的对象之后能及时抛出NPE(空指针异常)，而不是让程序在引用过期的对象之后继续悄悄地做错误的事请。</li></ul></blockquote><p>不建议：</p><blockquote><ul><li>不建议程序结束后立即清空所有对象的引用，因为这是Java垃圾回收器的工作。清空对象引用应该是例外而不是规范，程序结束后立即清空所有对象的引用是不必要的，也是不可取的。</li></ul></blockquote><p>常见的内存溢出：</p><blockquote><ul><li>当一个类自己管理内存时，应警惕内存泄漏的问题</li><li>缓存：防止业务数据缓存之后没有及时清空</li><li>监听器和回调，防止程序执行时间过长导致内存溢出。</li></ul></blockquote><p>总结：</p><blockquote><ul><li>内存溢出问题通常情况下不会变现出明显的故障，但一些没必要的内存消耗可能一直存在于系统中，建议多留意代码细节和实现方式，减少不必要的内存消耗。</li></ul></blockquote><hr><h2 id="8-避免使用-Finalizer-和-Cleaner-机制"><a href="#8-避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="8. 避免使用 Finalizer 和 Cleaner 机制"></a>8. 避免使用 Finalizer 和 Cleaner 机制</h2><p>//TODO 待完成</p><hr><h2 id="9-使用-try-with-resource-语句代替-try-finally-语句"><a href="#9-使用-try-with-resource-语句代替-try-finally-语句" class="headerlink" title="9. 使用 try-with-resource 语句代替 try-finally 语句"></a>9. 使用 try-with-resource 语句代替 try-finally 语句</h2><p>说明：</p><blockquote><ul><li>Java 类库中有很多必须通过调用 close 方法手动关闭的资源。比如 InputStream、OutputStream 等等。年轻的程序员可能经常忽略关闭这些资源，未及时关闭资源会影响系统性能，甚至终止程序。尽管这些资源中有很多使用 finalizer 机制作为安全网，但 finalizer 机制却不能很好地工作。</li><li>在我们 JDK 7 发布之前，我们使用 try-finally 语句保证资源的正确关闭是最佳的方式，JDK 7 发布之后，我们可以通过使用 try-with-resource 更好的关闭资源，但是使用 try-with-resource 关闭资源必须满足一些条件，详见下文。</li></ul></blockquote><p>使用 try-with-resource 语句需满足的条件：</p><blockquote><ul><li>资源需实现 AutoCloseable 接口， Java 类库中和第三方类库中许多类都实现或继承了该接口，如果我们程序设计的类需要关闭资源，那么这个类也应该实现 AutoCloseable 接口。</li></ul></blockquote><p>使用 try-with-resource 语句的优点：</p><blockquote><p>比 try-finally 语句更加精简，具有更好的可读性，并且生成的异常更有用。<br>比 try-finally 语句关闭资源更容易，也不会出错。</p></blockquote><p>使用 try-with-resource 语句关闭资源时的特征：</p><blockquote><p>先声明的资源先关闭，后声明的资源后关闭。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先关闭 fin 资源, 接着关闭 fout 资源, 最后关闭 out 资源</span><br><span class="line">try (</span><br><span class="line">        FileInputStream fin &#x3D; new FileInputStream(input);</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(output);</span><br><span class="line">        GZIPOutputStream out &#x3D; new GZIPOutputStream(fout)</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F;do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><blockquote><p>这里不详细说明 try-with-resource 语句的用法，想要了解的同学可以网上搜索相关资料。</p></blockquote><hr><h2 id="10-重写-equals-方法时遵守通用约定"><a href="#10-重写-equals-方法时遵守通用约定" class="headerlink" title="10. 重写 equals 方法时遵守通用约定"></a>10. 重写 equals 方法时遵守通用约定</h2><p>//TODO 待完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-考虑使用静态工厂方法代替构造方法&quot;&gt;&lt;a href=&quot;#1-考虑使用静态工厂方法代替构造方法&quot; class=&quot;headerlink&quot; title=&quot;1. 考虑使用静态工厂方法代替构造方法&quot;&gt;&lt;/a&gt;1. 考虑使用静态工厂方法代替构造方法&lt;/h2&gt;&lt;p&gt;例如：&lt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>验证XML</title>
    <link href="http://yoursite.com/2020/06/18/%E9%AA%8C%E8%AF%81XML/"/>
    <id>http://yoursite.com/2020/06/18/%E9%AA%8C%E8%AF%81XML/</id>
    <published>2020-06-18T06:53:53.000Z</published>
    <updated>2020-06-18T09:16:09.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><ul><li>如果我们解析XML之后，获取到XML的内容，再校验XML内容或格式是否符合设计规范，这个工作是很繁琐的。</li><li>幸好，XML解析器的一个很大的好处就是它能够自动校验某个文档是否具有正确的结构，这样解析工作就变的简单的多。</li><li>通过定义一个 <a href="https://www.w3school.com.cn/dtd/dtd_intro.asp" target="_blank" rel="noopener">DTD</a> 或者 <a href="https://www.w3school.com.cn/schema/schema_intro.asp" target="_blank" rel="noopener">XML Schema</a>， DTD 或者 Schema 包含了用于解释文档如何构成的规则，这些规则指定了每个元素的合法子元素和属性。</li></ul></blockquote><hr><h2 id="2-定义DTD校验规则"><a href="#2-定义DTD校验规则" class="headerlink" title="2. 定义DTD校验规则"></a>2. 定义DTD校验规则</h2><p><strong>XML文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!-- 定义DTD校验规则 --&gt;</span><br><span class="line">&lt;!DOCTYPE class [</span><br><span class="line">    &lt;!-- 定义class至少包含一个student --&gt;</span><br><span class="line">    &lt;!ELEMENT class (student+)&gt;</span><br><span class="line">    &lt;!-- 定义student只包含name,age,sex,className属性 --&gt;</span><br><span class="line">    &lt;!ELEMENT student (name, age, sex, className)&gt;</span><br><span class="line">        &lt;!-- 定义id属性, 属性默认值为0 --&gt;</span><br><span class="line">        &lt;!ATTLIST student id CDATA &quot;0&quot;&gt;</span><br><span class="line">    &lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT className (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果我们解析XML之后，获取到XML的内容，再校验XML内容或格式是否符合设计规范
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>解析XML</title>
    <link href="http://yoursite.com/2020/06/16/%E8%A7%A3%E6%9E%90XML/"/>
    <id>http://yoursite.com/2020/06/16/%E8%A7%A3%E6%9E%90XML/</id>
    <published>2020-06-16T08:36:40.000Z</published>
    <updated>2020-06-18T04:42:51.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>Java 8 官方API : <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8 API</a></li><li>github代码地址: <a href="https://github.com/miracle-sungm/learn_xml" target="_blank" rel="noopener">Github</a></li></ul></blockquote><hr><h2 id="1-DOM解析XML"><a href="#1-DOM解析XML" class="headerlink" title="1. DOM解析XML"></a>1. DOM解析XML</h2><p><strong>xml文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.w3c.dom.*;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-16 16:59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者工厂实例（设计模式：工厂模式）</span><br><span class="line">        DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者实例（设计模式：Builder模式）</span><br><span class="line">        DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">        &#x2F;&#x2F;使用xml解析器builder解析文档，获取解析后的Document对象</span><br><span class="line">        Document document &#x3D; builder.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取根元素</span><br><span class="line">        Element rootElement &#x3D; document.getDocumentElement();</span><br><span class="line">        &#x2F;&#x2F;获取文档中student元素列表（也可以直接通过document.getElementsByTagName(&quot;student&quot;)获取所有的student元素）</span><br><span class="line">        NodeList studentNodes &#x3D; rootElement.getElementsByTagName(&quot;student&quot;);</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; studentNodes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            Element element &#x3D; (Element) studentNodes.item(index);</span><br><span class="line">            &#x2F;&#x2F;元素（备注：通过getElementsByTagName()方法获取指定的元素）</span><br><span class="line">            Element nameElement &#x3D; (Element) element.getElementsByTagName(&quot;name&quot;).item(0);</span><br><span class="line">            Element ageElement &#x3D; (Element) element.getElementsByTagName(&quot;age&quot;).item(0);</span><br><span class="line">            Element sexElement &#x3D; (Element) element.getElementsByTagName(&quot;sex&quot;).item(0);</span><br><span class="line">            Element classElement &#x3D; (Element) element.getElementsByTagName(&quot;className&quot;).item(0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;文本（备注：通过getNodeName()方法获取元素名称，通过getTextContent()方法获取文本内容）</span><br><span class="line">            System.out.println(nameElement.getNodeName()  + &quot; : &quot; + nameElement.getTextContent());</span><br><span class="line">            System.out.println(ageElement.getNodeName()   + &quot; : &quot; + ageElement.getTextContent());</span><br><span class="line">            System.out.println(sexElement.getNodeName()   + &quot; : &quot; + sexElement.getTextContent());</span><br><span class="line">            System.out.println(classElement.getNodeName() + &quot; : &quot; + classElement.getTextContent());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;属性（备注：通过getAttributeNode(name)方法属性节点，通过getAttribute(name)方法获取属性内容）</span><br><span class="line">            Attr nameAttr &#x3D; nameElement.getAttributeNode(&quot;nameAttr&quot;);</span><br><span class="line">            Attr ageAttr &#x3D; ageElement.getAttributeNode(&quot;ageAttr&quot;);</span><br><span class="line">            Attr sexAttr &#x3D; sexElement.getAttributeNode(&quot;sexAttr&quot;);</span><br><span class="line">            Attr classAttr &#x3D; classElement.getAttributeNode(&quot;classAttr&quot;);</span><br><span class="line">            System.out.println(nameAttr.getName()  + &quot; : &quot; + nameAttr.getValue());</span><br><span class="line">            System.out.println(ageAttr.getName()   + &quot; : &quot; + ageAttr.getValue());</span><br><span class="line">            System.out.println(sexAttr.getName()   + &quot; : &quot; + sexAttr.getValue());</span><br><span class="line">            System.out.println(classAttr.getName()   + &quot; : &quot; + classAttr.getValue());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">name : sungm</span><br><span class="line">age : 25</span><br><span class="line">sex : Man</span><br><span class="line">className : Class One</span><br><span class="line">nameAttr : sungm</span><br><span class="line">ageAttr : 25</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassOne</span><br><span class="line"></span><br><span class="line">name : sunhw</span><br><span class="line">age : 1</span><br><span class="line">sex : Man</span><br><span class="line">className : Class Two</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">ageAttr : 1</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>树结构，方便理解与使用</li><li>解析过程中树结构保存在内存中，方便修改</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>当文件过大时耗用内存，需谨慎使用</li></ul></blockquote><hr><h2 id="2-SAX解析XML"><a href="#2-SAX解析XML" class="headerlink" title="2. SAX解析XML"></a>2. SAX解析XML</h2><p><strong>xml文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>自定义Handler处理器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import org.xml.sax.Attributes;</span><br><span class="line">import org.xml.sax.SAXException;</span><br><span class="line">import org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:42</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StudentParserHandler extends DefaultHandler &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String ROOT_ELEMENT &#x3D; &quot;class&quot;;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法执行顺序：startDocument -&gt; startElement -&gt; characters -&gt; endElement -&gt; characters -&gt; endDocument</span><br><span class="line">    &#x2F;&#x2F;执行次数        只执行一次      元素循环执行    元素循环执行   元素循环执行   元素循环执行    只执行一次</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startDocument() throws SAXException &#123;</span><br><span class="line">        super.startDocument();</span><br><span class="line">        System.out.println(&quot;开始解析XML文档&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endDocument() throws SAXException &#123;</span><br><span class="line">        super.endDocument();</span><br><span class="line">        System.out.println(&quot;解析XML文档结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">        super.startElement(uri, localName, qName, attributes);</span><br><span class="line">        System.out.println(Constants.ROOT_ELEMENT.equals(qName) ? &quot;开始解析根节点&quot; : &quot;节点名称 ： &quot; + qName);</span><br><span class="line">        &#x2F;&#x2F;获取元素的属性</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; attributes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            String attrName &#x3D; attributes.getLocalName(index);</span><br><span class="line">            String attrValue &#x3D; attributes.getValue(index);</span><br><span class="line">            System.out.println(&quot;attrName &#x3D; &quot; + attrName + &quot;, attrValue &#x3D; &quot; + attrValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endElement(String uri, String localName, String qName) throws SAXException &#123;</span><br><span class="line">        super.endElement(uri, localName, qName);</span><br><span class="line">        if (Constants.ROOT_ELEMENT.equals(qName)) &#123;</span><br><span class="line">            System.out.println(&quot;解析根节点结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void characters(char[] ch, int start, int length) throws SAXException &#123;</span><br><span class="line">        super.characters(ch, start, length);</span><br><span class="line">        String value &#x3D; new String(ch, start, length).trim();</span><br><span class="line">        if (!Constants.EMPTY.equals(value)) &#123;</span><br><span class="line">            System.out.println(&quot;节点值：&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line">import javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:33</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析工厂实例</span><br><span class="line">        SAXParserFactory saxParserFactory &#x3D; SAXParserFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析器实例</span><br><span class="line">        SAXParser saxParser &#x3D; saxParserFactory.newSAXParser();</span><br><span class="line">        &#x2F;&#x2F;创建一个Handel实例</span><br><span class="line">        StudentParserHandler handler &#x3D; new StudentParserHandler();</span><br><span class="line">        &#x2F;&#x2F;解析文件</span><br><span class="line">        saxParser.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">开始解析XML文档</span><br><span class="line">开始解析根节点</span><br><span class="line">节点名称 ： class</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sungm</span><br><span class="line">节点值：sungm</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 25</span><br><span class="line">节点值：25</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassOne</span><br><span class="line">节点值：Class One</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sunhw</span><br><span class="line">节点值：sunhw</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 1</span><br><span class="line">节点值：1</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassTwo</span><br><span class="line">节点值：Class Two</span><br><span class="line">解析根节点结束</span><br><span class="line">解析XML文档结束</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>采用事件驱动的方式，耗用内存更少</li><li>适用于只需要处理xml文件的数据时使用</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>需编写自定义的handler类，不易编写</li><li>很难同时访问同一个xml中的不同数据</li></ul></blockquote><hr><h2 id="3-JDOM解析XML"><a href="#3-JDOM解析XML" class="headerlink" title="3. JDOM解析XML"></a>3. JDOM解析XML</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jdom&#x2F;jdom --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>XML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import org.jdom2.Attribute;</span><br><span class="line">import org.jdom2.Document;</span><br><span class="line">import org.jdom2.Element;</span><br><span class="line">import org.jdom2.input.SAXBuilder;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 10:46</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        SAXBuilder saxBuilder &#x3D; new SAXBuilder();</span><br><span class="line">        Document document &#x3D; saxBuilder.build(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element rootElement &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：&quot; + rootElement.getName());</span><br><span class="line">        parseElement(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        &#x2F;&#x2F;元素内容</span><br><span class="line">        if (element.getText() !&#x3D; null &amp;&amp; !Constants.EMPTY.equals(element.getTextTrim())) &#123;</span><br><span class="line">            System.out.println(element.getName() + &quot;:&quot; + element.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;元素属性</span><br><span class="line">        if (element.hasAttributes()) &#123;</span><br><span class="line">            element.getAttributes().forEach(Main::parseAttribute);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;解析子元素</span><br><span class="line">        List&lt;Element&gt; childrenElement &#x3D; element.getChildren();</span><br><span class="line">        if (childrenElement !&#x3D; null &amp;&amp; childrenElement.size() &gt; 0) &#123;</span><br><span class="line">            childrenElement.forEach(Main::parseElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Attribute attribute) &#123;</span><br><span class="line">        System.out.println(attribute.getName() + &quot; : &quot; + attribute.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">根节点：class</span><br><span class="line">name:sungm</span><br><span class="line">nameAttr : sungm</span><br><span class="line">age:25</span><br><span class="line">ageAttr : 25</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class One</span><br><span class="line">classAttr : ClassOne</span><br><span class="line">name:sunhw</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">age:1</span><br><span class="line">ageAttr : 1</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class Two</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>API简单易用，推荐使用</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>用了很多具体类，没使用接口</li></ul></blockquote><hr><h2 id="4-DOM4J解析XML"><a href="#4-DOM4J解析XML" class="headerlink" title="4. DOM4J解析XML"></a>4. DOM4J解析XML</h2><p><strong>引入依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;dom4j&#x2F;dom4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>XML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure><p><strong>程序入口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.dom4j.Attribute;</span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 11:27</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SAXReader reader &#x3D; new SAXReader();</span><br><span class="line">        Document document &#x3D; reader.read(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element element &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：名称 &#x3D; &quot; + element.getName());</span><br><span class="line">        &#x2F;&#x2F;递归解析</span><br><span class="line">        parseElement(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        System.out.println(&quot;节点：名称 &#x3D; &quot; + element.getName() + &quot;, value &#x3D; &quot; + element.getTextTrim());</span><br><span class="line">        Iterator iterator &#x3D; element.elementIterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Element childElement &#x3D; (Element) iterator.next();</span><br><span class="line">            &#x2F;&#x2F;解析属性</span><br><span class="line">            if (childElement.attributeCount() &gt; 0) &#123;</span><br><span class="line">                childElement.attributes().forEach(Main::parseAttribute);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;解析元素</span><br><span class="line">            parseElement(childElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Object attribute) &#123;</span><br><span class="line">        System.out.println(&quot;属性：&quot; + ((Attribute) attribute).getName() + &quot; : &quot; + ((Attribute) attribute).getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">根节点：名称 &#x3D; class</span><br><span class="line">节点：名称 &#x3D; class, value &#x3D; </span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sungm</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sungm</span><br><span class="line">属性：ageAttr : 25</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 25</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassOne</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class One</span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sunhw</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sunhw</span><br><span class="line">属性：ageAttr : 1</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 1</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassTwo</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class Two</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><blockquote><ul><li>使用了接口和抽象方案，是个优秀的API</li><li>灵活性好、性能优异、易用性好。推荐使用</li></ul></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Java 8 官方API : &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 8 API&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>XML基础</title>
    <link href="http://yoursite.com/2020/06/16/XML%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/06/16/XML%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-16T08:34:20.000Z</published>
    <updated>2020-06-18T08:35:56.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-XML概述"><a href="#1-XML概述" class="headerlink" title="1. XML概述"></a>1. XML概述</h2><p>XML : 可拓展标记语言（Extensible Markup Language, XML）。 是一个非常有用的、用来描述结构化信息的技术。</p><h3 id="1-1-XML文档头"><a href="#1-1-XML文档头" class="headerlink" title="1.1 XML文档头"></a>1.1 XML文档头</h3><p>XML 文档应当以一个文档头开始，严格来说，文档头是可选的，但是强烈建议使用文档头。文档类型定义的是确保文档正确的一个重要机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-XML元素"><a href="#1-2-XML元素" class="headerlink" title="1.2 XML元素"></a>1.2 XML元素</h3><p>XML 文档的正文包含根元素，根元素包含其他元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;title&gt;miracle&#39;s blog&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;content&gt;XML基础与解析&lt;&#x2F;content&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>元素可以有子元素、文本或两者兼有。在设计XML文档时，对元素的设计的最好的方式是：要么全部使用元素，要么全部使用文本，这样做的目的是方便解析。</p></blockquote><p>我们应该避免下面这种设计:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!-- 不推荐：元素config既包含文本、又包含元素 --&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    miracle&#39;s blog</span><br><span class="line">    &lt;content&gt;XML基础与解析&lt;&#x2F;content&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-XML属性"><a href="#1-3-XML属性" class="headerlink" title="1.3 XML属性"></a>1.3 XML属性</h3><p>XML 元素可以包含属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config version&#x3D;&quot;1.0&quot;&gt;&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure><p>问题：什么时候使用属性，什么时候使用元素？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文档一：</span><br><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config version&#x3D;&quot;1.0&quot;&gt;&lt;&#x2F;config&gt;</span><br><span class="line"></span><br><span class="line">文档二：</span><br><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure><blockquote><p>从上面示例来看，文档一似乎比文档二要更简单一些。然而，属性的灵活性要比元素差很多，通常情况下属性只应该用来作为值的解释，而不是用来作为值。</p></blockquote><p>结论：</p><blockquote><p>优先使用元素，通常情况下属性只应该用来作为值的解释，而不是用来作为值。</p></blockquote><p>注意：</p><blockquote><p>在HTML中，所有的属性都不会展示在HTML中。</p></blockquote><hr><h2 id="2-XML与属性文件（property-file）的区别"><a href="#2-XML与属性文件（property-file）的区别" class="headerlink" title="2. XML与属性文件（property file）的区别"></a>2. XML与属性文件（property file）的区别</h2><p>属性文件包含了各种键值对，例如：</p><blockquote><p>name=sungm</p></blockquote><p>区别：</p><blockquote><ol><li>属性文件结构更加简洁，在要描述的信息更加复杂的场景下，属性文件不能更好的处理它，XML文件可以处理更加复杂的结构化信息。</li><li>属性文件采用的是单一的平面结构，XML文件采用的是层次结构，也可以说是树型结构，更加清晰。</li><li>属性文件中key是不能重复的，XML文件可以存在重复的元素。</li></ol></blockquote><p>结论：</p><blockquote><p>在处理不复杂的结构化信息时优先考虑使用属性文件，在处理复杂的结构化信息时考虑使用XML文件</p></blockquote><hr><h2 id="3-XML与HTML的区别"><a href="#3-XML与HTML的区别" class="headerlink" title="3. XML与HTML的区别"></a>3. XML与HTML的区别</h2><p>HTML : 超文本标记语言（Hyper Text Markup Language）</p><p>区别：</p><blockquote><ol><li>HTML对大小写不敏感；XML对大小写敏感</li><li>在HTML中，如果从上下文中可以分清哪里是段落或者列表项的结尾，那么结束标签可以省略；XML不可省略结束标签</li><li>在XML中，只有单个标签而没有对应的结束标签的元素必须以 / 结尾。</li><li>在XML中，属性值必须用引号括起来；在HTML中，引号可有可无</li><li>在HTML中，属性可以没有值；在XML中，属性必须都有属性值</li></ol></blockquote><h2 id="4-良好的XML文档格式"><a href="#4-良好的XML文档格式" class="headerlink" title="4. 良好的XML文档格式"></a>4. 良好的XML文档格式</h2><blockquote><ul><li>XML文档必须有根元素，且只能有1个根元素</li><li>XML文档必须有关闭标签</li><li>XML文档对大小写敏感</li><li>XML对大小写敏感</li><li>XML元素必须被正确的嵌套</li><li>XML属性必须加引号</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-XML概述&quot;&gt;&lt;a href=&quot;#1-XML概述&quot; class=&quot;headerlink&quot; title=&quot;1. XML概述&quot;&gt;&lt;/a&gt;1. XML概述&lt;/h2&gt;&lt;p&gt;XML : 可拓展标记语言（Extensible Markup Language, XML）。 
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Check工具类</title>
    <link href="http://yoursite.com/2020/06/15/Check%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/06/15/Check%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-06-15T10:22:53.000Z</published>
    <updated>2020-06-17T07:46:20.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>直接上代码</p></blockquote><blockquote><p>定义Check注解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since  : 2020-06-15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Check &#123;</span><br><span class="line"></span><br><span class="line">    boolean notNull() default false;</span><br><span class="line"></span><br><span class="line">    boolean notEmpty() default false;</span><br><span class="line"></span><br><span class="line">    boolean notBlank() default false;</span><br><span class="line"></span><br><span class="line">    String regex() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>校验工具类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import demo.annotations.Check;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 16:01</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CheckUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static final String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; void check(T t) throws Exception &#123;</span><br><span class="line">        Class clazz &#x3D; t.getClass();</span><br><span class="line">        Field[] fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">        if (fields.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            check(field.get(t), field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void check(Object value, Field field) throws Exception &#123;</span><br><span class="line">        Check check &#x3D; field.getAnnotation(Check.class);</span><br><span class="line">        if (Objects.isNull(check)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (check.notNull() &amp;&amp; Objects.isNull(value)) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (check.notEmpty() &amp;&amp; (Objects.isNull(value) || EMPTY.equals(value.toString()))) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (check.notBlank() &amp;&amp; (Objects.isNull(value) || EMPTY.equals(value.toString().trim()))) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be blank.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkRegex(field, value, check.regex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void checkRegex(Field field, Object value, String regex) throws Exception &#123;</span><br><span class="line">        if (EMPTY.equals(regex) || Objects.isNull(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!Pattern.matches(regex, value.toString())) &#123;</span><br><span class="line">            throw new Exception(&quot;Wrong data format : Field (&quot; + field.getName() + &quot;), value  is : &quot; + &quot; value&quot; + &quot;, regex is : &quot; + regex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DTO 数据传输层</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PersonDto &#123;</span><br><span class="line"></span><br><span class="line">    @Check(notBlank &#x3D; true)</span><br><span class="line">    private String name;</span><br><span class="line">    @Check(notNull &#x3D; true, regex &#x3D; &quot;\\d\\d&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line">    @Check(notBlank &#x3D; true, regex &#x3D; &quot;男|女&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    private String idCard;</span><br><span class="line">    private String accessNumber;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略了getter、setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序入口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 17:50</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; new PersonDto();</span><br><span class="line">        personDto.setIdCard(&quot;0001&quot;);</span><br><span class="line">        personDto.setName(&quot;孙广明&quot;);</span><br><span class="line">        personDto.setSex(&quot;男&quot;);</span><br><span class="line">        personDto.setAge(25);</span><br><span class="line">        CheckUtils.check(personDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;定义Check注解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="工具类" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>通用Builder</title>
    <link href="http://yoursite.com/2020/06/15/%E9%80%9A%E7%94%A8Builder/"/>
    <id>http://yoursite.com/2020/06/15/%E9%80%9A%E7%94%A8Builder/</id>
    <published>2020-06-15T02:58:44.000Z</published>
    <updated>2020-06-17T07:49:30.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>直接上代码</p></blockquote><blockquote><p>Builder类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Builder&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Supplier&lt;T&gt; supplier;</span><br><span class="line">    private List&lt;Consumer&lt;T&gt;&gt; consumers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private Builder(Supplier&lt;T&gt; supplier) &#123;</span><br><span class="line">        this.supplier &#x3D; supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Builder&lt;T&gt; of(Supplier&lt;T&gt; supplier) &#123;</span><br><span class="line">        return new Builder&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; Builder&lt;T&gt; with(BiConsumer&lt;T, U&gt; biConsumer, U u) &#123;</span><br><span class="line">        consumers.add(supplier -&gt; biConsumer.accept(supplier, u));</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T build() &#123;</span><br><span class="line">        T value &#x3D; supplier.get();</span><br><span class="line">        consumers.forEach(consumer -&gt; consumer.accept(value));</span><br><span class="line">        consumers.clear();</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>POJO</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:15</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Main方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:15</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person sungm &#x3D; Builder.of(Person::new)</span><br><span class="line">                .with(Person::setName, &quot;孙广明&quot;)</span><br><span class="line">                .with(Person::setAge, 25)</span><br><span class="line">                .with(Person::setSex, &quot;男&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(sungm.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果集 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name&#x3D;&#39;孙广明&#39;, age&#x3D;25, sex&#x3D;&#39;男&#39;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Builder类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="工具类" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 概述</title>
    <link href="http://yoursite.com/2020/06/13/Java-NIO-%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/06/13/Java-NIO-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-13T07:30:39.000Z</published>
    <updated>2020-06-17T07:45:57.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是NIO？"><a href="#1-什么是NIO？" class="headerlink" title="1.  什么是NIO？"></a>1.  什么是NIO？</h2><blockquote><p>java.nio 全称 java non-blocking IO，是指 JDK1.4 及以上版本里提供的新 API（New IO） ，为所有的原始类型（ boolean 类型除外）提供<a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98/100710" target="_blank" rel="noopener">缓存</a>支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。【百度百科】 </p></blockquote><a id="more"></a><hr><p>优点：NIO 比 AIO（异步I/O） 更加强大，处理数据更快。它可以大大的提高IO吞吐量，常用在高性能服务器上面。</p><h2 id="2-NIO原理"><a href="#2-NIO原理" class="headerlink" title="2. NIO原理"></a>2. NIO原理</h2><blockquote><p>使用较少的线程执行更多的任务。</p></blockquote><blockquote><p>如下图所示，使用较少的线程，通过 Selector 选择器来执行不同 Channel 通道中的任务，执行任务再结合 AIO（异步I/O）就能发挥服务器的最大性能，更大程度上提升服务器的运行效率。</p></blockquote><p><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-0a82f84999ea3e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-0a82f84999ea3e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理图"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">原理图</span></div></div></p><hr><h2 id="3-与常规-I-O-的区别"><a href="#3-与常规-I-O-的区别" class="headerlink" title="3. 与常规 I/O 的区别"></a>3. 与常规 I/O 的区别</h2><blockquote><p>常规 I/O （如 InputStream 和 OutputStream）存在很大的缺点，就是他们是阻塞的，而 NIO 解决的就是常规 I/O 执行效率低的问题，即采用非阻塞高性能运行的方式来避免以前以前“笨拙” I/O 带来的低效率问题。NIO在大文件操作上相比常规 I/O 更加优秀，对常规 I/O 使用的 byte[] 和 char[] 进行封装，采用 ByteBuffer 类来操作数据，再结合针对 File 或者 Socket 技术的 Channel，采用同步非阻塞技术实现高性能处理。</p></blockquote><hr><h2 id="4-缓冲区介绍"><a href="#4-缓冲区介绍" class="headerlink" title="4. 缓冲区介绍"></a>4. 缓冲区介绍</h2><blockquote><p>在使用传统的I/O流API时，如 InputStream 和 OutputStream ，以及Reader和Writer联合使用时，常常把字节流中的数据放入byte[]字节数组中，或把字符流中的数据放入char[]字符数组中，也可以从 byte[] 或 char[] 数组中获取数据来实现功能上的需求，但由于在 Java 语言中对 array 数组自身进行操作的 API 非常少，常用的操作仅仅是 length 属性和下标[x]了，在 JDK 中也没有提供更加方便操作数组中数据的 API，如果对数组中的数据进行高级处理，需要程序员自己写代码进行实现，处理的方式是比较原始的，这个问题可以使用 NIO 技术中的缓冲区Buffer类来解决，它提供了很多工具方法，大大提高了程序开发的效率。</p></blockquote><hr><p>推荐书籍：</p><ul><li>[高洪岩]《Java多线程编程核心技术》</li><li>[高洪岩]《Java并发编程：核心方法与框架》</li><li>[高洪岩]《NIO与Socket编程技术指南》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是NIO？&quot;&gt;&lt;a href=&quot;#1-什么是NIO？&quot; class=&quot;headerlink&quot; title=&quot;1.  什么是NIO？&quot;&gt;&lt;/a&gt;1.  什么是NIO？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;java.nio 全称 java non-blocking IO，是指 JDK1.4 及以上版本里提供的新 API（New IO） ，为所有的原始类型（ boolean 类型除外）提供&lt;a href=&quot;https://baike.baidu.com/item/%E7%BC%93%E5%AD%98/100710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缓存&lt;/a&gt;支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。【百度百科】 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java NIO" scheme="http://yoursite.com/tags/Java-NIO/"/>
    
  </entry>
  
</feed>
