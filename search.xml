<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Check工具类</title>
    <url>/2020/06/15/Check%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>直接上代码</p>
</blockquote>
<blockquote>
<p>定义Check注解</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since  : 2020-06-15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Check &#123;</span><br><span class="line"></span><br><span class="line">    boolean notNull() default false;</span><br><span class="line"></span><br><span class="line">    boolean notEmpty() default false;</span><br><span class="line"></span><br><span class="line">    boolean notBlank() default false;</span><br><span class="line"></span><br><span class="line">    String regex() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>校验工具类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import demo.annotations.Check;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 16:01</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CheckUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static final String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; void check(T t) throws Exception &#123;</span><br><span class="line">        Class clazz &#x3D; t.getClass();</span><br><span class="line">        Field[] fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">        if (fields.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            check(field.get(t), field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void check(Object value, Field field) throws Exception &#123;</span><br><span class="line">        Check check &#x3D; field.getAnnotation(Check.class);</span><br><span class="line">        if (Objects.isNull(check)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (check.notNull() &amp;&amp; Objects.isNull(value)) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (check.notEmpty() &amp;&amp; (Objects.isNull(value) || EMPTY.equals(value.toString()))) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (check.notBlank() &amp;&amp; (Objects.isNull(value) || EMPTY.equals(value.toString().trim()))) &#123;</span><br><span class="line">            throw new Exception(&quot;Field (&quot; + field.getName() + &quot;) cannot be blank.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkRegex(field, value, check.regex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void checkRegex(Field field, Object value, String regex) throws Exception &#123;</span><br><span class="line">        if (EMPTY.equals(regex) || Objects.isNull(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!Pattern.matches(regex, value.toString())) &#123;</span><br><span class="line">            throw new Exception(&quot;Wrong data format : Field (&quot; + field.getName() + &quot;), value  is : &quot; + &quot; value&quot; + &quot;, regex is : &quot; + regex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>DTO 数据传输层</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PersonDto &#123;</span><br><span class="line"></span><br><span class="line">    @Check(notBlank &#x3D; true)</span><br><span class="line">    private String name;</span><br><span class="line">    @Check(notNull &#x3D; true, regex &#x3D; &quot;\\d\\d&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line">    @Check(notBlank &#x3D; true, regex &#x3D; &quot;男|女&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    private String idCard;</span><br><span class="line">    private String accessNumber;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略了getter、setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序入口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 17:50</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PersonDto personDto &#x3D; new PersonDto();</span><br><span class="line">        personDto.setIdCard(&quot;0001&quot;);</span><br><span class="line">        personDto.setName(&quot;孙广明&quot;);</span><br><span class="line">        personDto.setSex(&quot;男&quot;);</span><br><span class="line">        personDto.setAge(25);</span><br><span class="line">        CheckUtils.check(personDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java</title>
    <url>/2020/06/28/Effective-Java-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-考虑使用静态工厂方法代替构造方法"><a href="#1-考虑使用静态工厂方法代替构造方法" class="headerlink" title="1. 考虑使用静态工厂方法代替构造方法"></a>1. 考虑使用静态工厂方法代替构造方法</h2><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-静态工厂方法代替构造方法的优缺点"><a href="#1-1-静态工厂方法代替构造方法的优缺点" class="headerlink" title="1.1 静态工厂方法代替构造方法的优缺点"></a>1.1 静态工厂方法代替构造方法的优缺点</h4><blockquote>
<p>优点：</p>
<ul>
<li>静态工厂方法不需要每次都创建一个对象，而构造方法每次都会创建一个对象。</li>
<li>静态工厂方法返回值可以是任何对象，而构造方法返回指定的对象。</li>
<li>静态工厂方法返回值可以根据入参的不同而不同。</li>
<li>静态工厂方法有自定义的方法名，构造方法方法名与类名相同。</li>
</ul>
</blockquote>
<blockquote>
<p>缺点:</p>
<ul>
<li>限制：没有公共或受保护的构造方法不能被子类化。（假如定义一个Person类，且该类没有公共或受保护的构造函数，如果我们想定义一个类来继承Person类，将发生编译错误）</li>
<li>静态方法不如构造方法易发现，不仔细阅读源码我们很难找到他们。</li>
</ul>
</blockquote>
<h4 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h4><blockquote>
<ul>
<li>定义静态工厂方法代替构造方法时，建议将构造方法设置成私有的（private）或受保护的（protected）。</li>
<li>如果定义一个静态工厂方法用来代替构造方法，且静态构造方法每次被调用都返回一个新对象，那么使用静态工厂方法代替构造方法将意义不大。</li>
<li>根据需要，重载静态工厂方法。</li>
</ul>
</blockquote>
<hr>
<h2 id="2-当构造方法参数过多时，使用Builder模式"><a href="#2-当构造方法参数过多时，使用Builder模式" class="headerlink" title="2 当构造方法参数过多时，使用Builder模式"></a>2 当构造方法参数过多时，使用Builder模式</h2><p>说明：</p>
<blockquote>
<p>使用Builder模式可以使用简化代码，提高代码可读性。（这里对Builder模式不做过多的解释，若您想了解Builder模式，请百度。）</p>
</blockquote>
<h4 id="2-1-方式一：使用Lombok插件"><a href="#2-1-方式一：使用Lombok插件" class="headerlink" title="2.1 方式一：使用Lombok插件"></a>2.1 方式一：使用Lombok插件</h4><blockquote>
<p> 安装Lombok插件，引入Lombok依赖之后使用Lombok的@Builder注解。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义响应值</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-23 17:28</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">public class ResponseDTO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;序列化</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    private String resultCode;</span><br><span class="line">    private String resultMessage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主函数</span><br><span class="line"> * </span><br><span class="line"> * @param args      入参</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ResponseDTO response &#x3D; ResponseDTO.builder()</span><br><span class="line">        .resultCode(ResultEnum.ONE.getResultCode())</span><br><span class="line">        .resultMessage(ResultEnum.ONE.getResultMessage())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>备注：</p>
<blockquote>
<p>使用Lombok插件还是蛮香的，我们可以通过使用Lombok定义的注解，来减少了我们编写的代码量、提高了代码可读性，但是Lombok插件会增加我们程序编译的时间，且通常情况下我们也可以通过使用IDEA的快捷键来自动生成代码。</p>
</blockquote>
<h4 id="2-2-方式二：使用通用Builder工具类"><a href="#2-2-方式二：使用通用Builder工具类" class="headerlink" title="2.2 方式二：使用通用Builder工具类"></a>2.2 方式二：使用通用Builder工具类</h4><p>Builder工具类博客地址：</p>
<blockquote>
<p><a href="https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/" target="_blank" rel="noopener">https://miracle-sungm.github.io/2020/06/15/%E9%80%9A%E7%94%A8Builder/</a></p>
</blockquote>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><blockquote>
<ul>
<li>对于方式一和方式二的选择，仁者见仁智者见智，你更喜欢哪种方式呢？或者你还有其他更好的方式？</li>
</ul>
</blockquote>
<hr>
<h2 id="3-使用私有构造方法或枚举实现单例模式"><a href="#3-使用私有构造方法或枚举实现单例模式" class="headerlink" title="3. 使用私有构造方法或枚举实现单例模式"></a>3. 使用私有构造方法或枚举实现单例模式</h2><p>说明：</p>
<blockquote>
<p>单例是一个仅实例化一次的类，通常情况下表示无状态对象。</p>
</blockquote>
<h4 id="3-1-使用私有构造方法实现单例模式"><a href="#3-1-使用私有构造方法实现单例模式" class="headerlink" title="3.1 使用私有构造方法实现单例模式"></a>3.1 使用私有构造方法实现单例模式</h4><p><em>两种常见的单例模式实现方式</em></p>
<p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明公共属性的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonOne &#123;</span><br><span class="line"></span><br><span class="line">    public static final SingletonOne INSTANCE &#x3D; new SingletonOne();</span><br><span class="line"></span><br><span class="line">    private SingletonOne() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式：声明静态工厂方法的方式</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 11:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonTwo &#123;</span><br><span class="line"></span><br><span class="line">    private static final SingletonTwo INSTANCE &#x3D; new SingletonTwo();</span><br><span class="line"></span><br><span class="line">    private SingletonTwo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonTwo getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<ul>
<li>方式一和方式二的构造函数都是私有构造函数，且定义了一个 static final 类型的INSTANCE变量，并使其实例化，确保了该类只能被实例化一次，保证了全局的唯一性。</li>
<li>不论是方式一还是方式二，特殊情况下可以通过使用反射的方式调用构造方法创建对象，如果需要防止此操作的产生，需修改构造方法，使其请求创建第二个对象时抛出异常。</li>
</ul>
</blockquote>
<p>建议：</p>
<blockquote>
<p>建议通过静态工厂方法（方式二）来创建单例。原因是通过静态工厂的方式更加灵活，并且可以根据需要设计泛型单例工厂，并且还能使用函数式接口Supplier，例如Singleton::getInstance。</p>
</blockquote>
<h4 id="3-2-通过使用枚举设计单例模式"><a href="#3-2-通过使用枚举设计单例模式" class="headerlink" title="3.2 通过使用枚举设计单例模式"></a>3.2 通过使用枚举设计单例模式</h4><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。这种方法可能感觉有点不自然，但是单一元素枚举类通常是实现单例的最佳方式。</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。</p>
</blockquote>
<hr>
<h2 id="4-使用私有构造方法执行非实例化"><a href="#4-使用私有构造方法执行非实例化" class="headerlink" title="4. 使用私有构造方法执行非实例化"></a>4. 使用私有构造方法执行非实例化</h2><p>场景说明：</p>
<blockquote>
<p>当我们希望设计一个类只包含静态方法和静态属性时，为了避免这样的类被实例化，可以通过声明私有的构造方法达到类不被实例化的目的。</p>
</blockquote>
<p>副作用：</p>
<blockquote>
<p>当我们想设计一个子类来继承私有化构造函数的父类时，将报编译异常。因为所有构造方法都必须显示或者隐式的调用父类的构造方法，若父类的构造函数被私有化，则子类没有访问父类构造函数的权限，因此报错。</p>
</blockquote>
<hr>
<h2 id="5-比起硬资源连接，优先使用依赖注入"><a href="#5-比起硬资源连接，优先使用依赖注入" class="headerlink" title="5. 比起硬资源连接，优先使用依赖注入"></a>5. 比起硬资源连接，优先使用依赖注入</h2><p>硬资源连接:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dictionary &#123;</span><br><span class="line">    &#x2F;&#x2F;定义字典</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;硬资源连接：想当然的认为一本字典就够了，无法承载多字典的场景</span><br><span class="line">    private static final Dictionary DICTIONARY &#x3D; new ChineseDictionary();</span><br><span class="line"></span><br><span class="line">    private SpellChecker() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义字典接口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义中文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:53</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ChineseDictionary implements Dictionary&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义英文字典</span><br><span class="line"> * </span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EnglishDictionary implements Dictionary &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 拼写检查器</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-06-29 20:56</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line"></span><br><span class="line">    private final Dictionary DICTIONARY;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用依赖注入的方式，创建对象时将字典注入到对象属性中</span><br><span class="line">    public SpellChecker(Dictionary dictionary) &#123;</span><br><span class="line">        this.DICTIONARY &#x3D; dictionary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(String word) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>当一个类依赖于一个或多个底层资源时，该类的实现方式不要使用单例或静态的实用类，这些资源的行为会影响类的行为，并且不让类直接创建这些资源。相反，将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p>
</blockquote>
<hr>
<h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>说明：</p>
<blockquote>
<p>通常情况下，重用对象比创建一个相同功能的对象的做法更恰当，重用可以使程序更快的执行且耗用更少的内存。如果一个对象是不可变的，他总是可以被重用。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;请不要这样写代码</span><br><span class="line">String name &#x3D; new String(&quot;sungm&quot;);</span><br></pre></td></tr></table></figure>

<p>这样写代码产生的结果：</p>
<blockquote>
<p>该语句每次执行时都会创建一个新的String实例，并且这些对象都不是必须的。String的构造方法String(String original)的入参original本身就是一个String实例，它与构造方法创建的对象的功能相同。</p>
</blockquote>
<p>优化后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; &quot;sungm&quot;;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过使用静态工厂方法，可以避免创建不必要的对象。<blockquote>
<p>例如：使用静态工厂方法 Boolean.parseBoolean(String) 比构造方法 Boolean(String) 好的多，构造方法每次调用都会创建一个新的对象，而工厂方法永远不需要这样做，在实践中也不需要。</p>
</blockquote>
</li>
<li>一些对象的创建比其他对象的创建的代价要昂贵的多，如果要使用这样一个昂贵的对象，建议将其缓存起来以便重复使用。<blockquote>
<p>例如创建创建正则表达式的 Pattern 对象，因为它需要将正则表达式编译成有限状态机（finite state machine）。</p>
</blockquote>
</li>
<li>当一些对象是不可变（final定义的对象）的时侯，很明显它可以被重用，但是在其他情况下，没有很明显的可以被重用，这种情况下需谨慎考虑是否重用对象。</li>
<li>自动装箱的情况下是不需要创建不必要的对象的，自动装箱允许程序员混用基本数据类型和装箱类型，根据需要自动装箱和拆箱。<blockquote>
<p>建议：优先使用基本数据类型而不是装箱的基本类型，也要注意无意识的自动装箱。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="7-消除过期对象的引用"><a href="#7-消除过期对象的引用" class="headerlink" title="7. 消除过期对象的引用"></a>7. 消除过期对象的引用</h2><p>举例：</p>
<blockquote>
<p>《Effective Java》原书中该章节举了一个栈（Stock）弹出元素（pop）没有及时清空弹出的元素引用，当Stock扩容后收缩，容易发生内存溢出异常。</p>
</blockquote>
<p>好处：</p>
<blockquote>
<ul>
<li>及时消除过期对象的引用，减少内存消耗，增加程序执行速度，同时可以避免因内存溢出导致程序异常。</li>
<li>消除过期对象的引用有一个好处是程序错误的引用过期的对象之后能及时抛出NPE(空指针异常)，而不是让程序在引用过期的对象之后继续悄悄地做错误的事请。</li>
</ul>
</blockquote>
<p>不建议：</p>
<blockquote>
<ul>
<li>不建议程序结束后立即清空所有对象的引用，因为这是Java垃圾回收器的工作。清空对象引用应该是例外而不是规范，程序结束后立即清空所有对象的引用是不必要的，也是不可取的。</li>
</ul>
</blockquote>
<p>常见的内存溢出：</p>
<blockquote>
<ul>
<li>当一个类自己管理内存时，应警惕内存泄漏的问题</li>
<li>缓存：防止业务数据缓存之后没有及时清空</li>
<li>监听器和回调，防止程序执行时间过长导致内存溢出。</li>
</ul>
</blockquote>
<p>总结：</p>
<blockquote>
<ul>
<li>内存溢出问题通常情况下不会变现出明显的故障，但一些没必要的内存消耗可能一直存在于系统中，建议多留意代码细节和实现方式，减少不必要的内存消耗。</li>
</ul>
</blockquote>
<hr>
<h2 id="8-避免使用-Finalizer-和-Cleaner-机制"><a href="#8-避免使用-Finalizer-和-Cleaner-机制" class="headerlink" title="8. 避免使用 Finalizer 和 Cleaner 机制"></a>8. 避免使用 Finalizer 和 Cleaner 机制</h2><p>//TODO 待完成</p>
<hr>
<h2 id="9-使用-try-with-resource-语句代替-try-finally-语句"><a href="#9-使用-try-with-resource-语句代替-try-finally-语句" class="headerlink" title="9. 使用 try-with-resource 语句代替 try-finally 语句"></a>9. 使用 try-with-resource 语句代替 try-finally 语句</h2><p>说明：</p>
<blockquote>
<ul>
<li>Java 类库中有很多必须通过调用 close 方法手动关闭的资源。比如 InputStream、OutputStream 等等。年轻的程序员可能经常忽略关闭这些资源，未及时关闭资源会影响系统性能，甚至终止程序。尽管这些资源中有很多使用 finalizer 机制作为安全网，但 finalizer 机制却不能很好地工作。</li>
<li>在我们 JDK 7 发布之前，我们使用 try-finally 语句保证资源的正确关闭是最佳的方式，JDK 7 发布之后，我们可以通过使用 try-with-resource 更好的关闭资源，但是使用 try-with-resource 关闭资源必须满足一些条件，详见下文。</li>
</ul>
</blockquote>
<p>使用 try-with-resource 语句需满足的条件：</p>
<blockquote>
<ul>
<li>资源需实现 AutoCloseable 接口， Java 类库中和第三方类库中许多类都实现或继承了该接口，如果我们程序设计的类需要关闭资源，那么这个类也应该实现 AutoCloseable 接口。</li>
</ul>
</blockquote>
<p>使用 try-with-resource 语句的优点：</p>
<blockquote>
<p>比 try-finally 语句更加精简，具有更好的可读性，并且生成的异常更有用。<br>比 try-finally 语句关闭资源更容易，也不会出错。</p>
</blockquote>
<p>使用 try-with-resource 语句关闭资源时的特征：</p>
<blockquote>
<p>先声明的资源先关闭，后声明的资源后关闭。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先关闭 fin 资源, 接着关闭 fout 资源, 最后关闭 out 资源</span><br><span class="line">try (</span><br><span class="line">        FileInputStream fin &#x3D; new FileInputStream(input);</span><br><span class="line">        FileOutputStream fout &#x3D; new FileOutputStream(output);</span><br><span class="line">        GZIPOutputStream out &#x3D; new GZIPOutputStream(fout)</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F;do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<blockquote>
<p>这里不详细说明 try-with-resource 语句的用法，想要了解的同学可以网上搜索相关资料。</p>
</blockquote>
<hr>
<h2 id="10-重写-equals-方法时遵守通用约定"><a href="#10-重写-equals-方法时遵守通用约定" class="headerlink" title="10. 重写 equals 方法时遵守通用约定"></a>10. 重写 equals 方法时遵守通用约定</h2><p>//TODO 待完成</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 1. 并发和多线程</title>
    <url>/2020/08/09/Java-Concurrency-and-Multithreading/</url>
    <content><![CDATA[<h3 id="1-并发和多线程"><a href="#1-并发和多线程" class="headerlink" title="1. 并发和多线程"></a>1. 并发和多线程</h3><p><strong>并发编程</strong><br>并发编程涵盖了多线程技术在内，指并发执行任务时可能出现的问题，使用的多线程技术，以及解决方案。</p>
<p><strong>多线程：</strong><br>同一个应用程序中，多个线程同时执行。</p>
<p><strong>多线程应用程序:</strong><br>多线程应用程序是一个多 CPU 同时执行不同的线程的应用程序。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-1.png" alt></div></p>
<p>一个线程不等于一个CPU，通常情况下一个CPU在不同时间段交换执行不同的线程，不同的CPU同时执行不同的线程。如图：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/introduction-2.png" alt></div></p>
<hr>
<h3 id="2-为什么使用多线程"><a href="#2-为什么使用多线程" class="headerlink" title="2. 为什么使用多线程"></a>2. 为什么使用多线程</h3><blockquote>
<ul>
<li>更好的利用单 CPU 资源</li>
<li>更好的利用多 CPU 或 CPU 内核</li>
<li>更快速的响应-提高用户体验</li>
<li>更公平的响应-提高用户体验</li>
</ul>
</blockquote>
<p><strong>更好的利用单 CPU 资源</strong><br>单个CPU通过分配CPU时间片达到交换地执行不同线程的目的，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒。</p>
<p><strong>更好的利用多 CPU 或 CPU 内核</strong><br>创建多个线程，充分地利用多个CPU同时执行不同的线程，加快程序执行速度，充分利用多CPU资源。</p>
<p><strong>更快速的响应-提高用户体验</strong><br>充分的利用单CPU资源和多CPU资源都能够加快程序的执行速度，以提高用户体验</p>
<p><strong>更公平的响应-提高用户体验</strong><br>不同的线程在单CPU中分配CPU时间片交换执行，在某些特定情况下以一种更加公平的方式执行不同的线程。比如某个线程需要调用网络资源或者其他的操作需要长时间占用CPU，导致许多线程需要等待CPU去执行，造成阻塞。</p>
<hr>
<h3 id="3-使用多线程不一定更快"><a href="#3-使用多线程不一定更快" class="headerlink" title="3. 使用多线程不一定更快"></a>3. 使用多线程不一定更快</h3><p>由于线程的创建和上下文的切换的开销，多线程的执行效率不一定比单线程的执行效率更好。</p>
<p><strong>线程创建的方式</strong></p>
<blockquote>
<ul>
<li>继承Thread类，重写 run() 方法</li>
<li>实现Runnable接口，重写 run() 方法</li>
<li>实现Callable接口，重写 call() 方法</li>
</ul>
</blockquote>
<p><strong>上下文切换</strong><br>单核处理器也支持多线程执行代码，CPU 通过给每个线程分配CPU时间片来实现这个机制。当前任务执行一个时间片后会切换到下一个任务。但是切换前会保存上一个任务的状态，以便于下次切换到该任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<hr>
<h3 id="4-多线程-vs-多任务"><a href="#4-多线程-vs-多任务" class="headerlink" title="4. 多线程 vs. 多任务"></a>4. 多线程 vs. 多任务</h3><p><strong>多任务</strong><br>不同CPU同时执行不同的应用程序的不同线程。</p>
<p><strong>多线程</strong><br>不同CPU同时执行相同的应用程序的不同线程。</p>
<p><strong>多线程技术更难实现</strong><br>多线程技术可以以一种很好的方式提高某些类型的应用程序的性能。但是多线程技术比多任务技术要面临更多的技术挑战。不同的线程在同一个应用程序中同时执行，它们可能存在一个线程在读取共享内存的数据，另外一个线程在写入数据至共享内存，造成线程不安全的问题发生，以至于产生了单线程技术通常情况下不会发生的错误。</p>
<p>现代计算机通常拥有多个CPU或者多个CPU内核，这意味着不同的线程可以被不同的CPU同时执行。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png" alt></div></p>
<hr>
<h3 id="5-Java-中的并发和多线程"><a href="#5-Java-中的并发和多线程" class="headerlink" title="5. Java 中的并发和多线程"></a>5. Java 中的并发和多线程</h3><p><strong>并发模型</strong></p>
<blockquote>
<ul>
<li>共享状态并发模型（shared state concurrency model）</li>
<li>隔离状态并发模型（separate state concurrency model）</li>
</ul>
</blockquote>
<p><strong>共享状态并发模型</strong><br>同一个应用程序中的不同的线程使用了同一个共享对象（或变量）。在共享状态并发模型中存在很多问题，这些问题难以完美地解决。</p>
<p><strong>隔离状态并发模型</strong><br>同一个应用程序中的不同的线程不共享任何对象（或变量）。</p>
<hr>
<h3 id="Java-并发学习指南"><a href="#Java-并发学习指南" class="headerlink" title="Java 并发学习指南"></a>Java 并发学习指南</h3><p><strong>并发和多线程理论知识</strong></p>
<blockquote>
<ul>
<li>多线程的好处</li>
<li>多线程的成本</li>
<li>并发模型</li>
<li>同一线程</li>
<li>并发 vs. 并行</li>
</ul>
</blockquote>
<p><strong>Java并发的基础理论知识</strong></p>
<blockquote>
<ul>
<li>创建和开始一个线程</li>
<li>线程安全和共享资源</li>
<li>线程安全和不变性</li>
<li>JMM (Java memory model)</li>
<li>synchronize 关键字</li>
<li>volatile 关键字</li>
<li>ThreadLocal </li>
</ul>
</blockquote>
<p><strong>Java 并发常见问题</strong></p>
<blockquote>
<ul>
<li>死锁</li>
<li>预防死锁</li>
</ul>
</blockquote>
<p><strong>Java 提供的一些解决常见问题的工具</strong></p>
<blockquote>
<ul>
<li>Lock （锁）</li>
<li>Read / Write Lock （读写锁）</li>
<li>ReentrantLock （可重入锁）</li>
<li>Semaphores （信号）</li>
<li>Blocking Queues （阻塞队列）</li>
<li>Thread Pools （线程池）</li>
<li>Compare and Swap （CAS）</li>
</ul>
</blockquote>
<p><strong>Java 并发工具包 （JUC: java.util.concurrent）</strong></p>
<blockquote>
<ul>
<li>Java Concurrency Utilities - java.util.concurrent</li>
</ul>
</blockquote>
<hr>
<p><strong>推荐</strong></p>
<blockquote>
<p>&lt;Java 并发编程的艺术&gt;</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/2020/06/13/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><blockquote>
<p>我希望通过这一篇文章、可以让读者全面了解Lambda表达式、也许不够全面、我在尽力完善它、也希望你能留下宝贵意见、在下方留言。文章有点长、请耐心看完。</p>
</blockquote>
<a id="more"></a>

<h2 id="2-描述"><a href="#2-描述" class="headerlink" title="2. 描述"></a>2. 描述</h2><blockquote>
<ul>
<li>可以将 Lambda 表达式理解为简洁的表示可传递匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可抛出的异常列表。</li>
<li>Lambda 表达式是实现行为参数化的一种方式，这种方式比起使用匿名内部类的方式更加的简洁、易读。</li>
</ul>
</blockquote>
<hr>
<h2 id="3-组成"><a href="#3-组成" class="headerlink" title="3. 组成"></a>3. 组成</h2><blockquote>
<ul>
<li>参数</li>
<li>箭头</li>
<li>主体</li>
</ul>
</blockquote>
<p><strong>例如</strong><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-Lambda-语法"><a href="#4-Lambda-语法" class="headerlink" title="4. Lambda 语法"></a>4. Lambda 语法</h2><blockquote>
<ul>
<li>(parameters) -&gt; expression  </li>
<li>(parameters) -&gt; { statements; }  </li>
</ul>
</blockquote>
<hr>
<h2 id="5-有效的-Lambda-表达式"><a href="#5-有效的-Lambda-表达式" class="headerlink" title="5.有效的 Lambda 表达式"></a>5.有效的 Lambda 表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 表示有一个 String 类型的入参，且返回一个 int 类型的结果。  *&#x2F;</span><br><span class="line">(String s) -&gt; s.length()</span><br><span class="line"></span><br><span class="line">&#x2F;* 表示有一个 Apple 类型的入参，且返回一个 boolean 类型的结果。 *&#x2F;</span><br><span class="line">(Apple a) -&gt; a.getWeight() &gt; 150</span><br><span class="line"></span><br><span class="line">&#x2F;* 表示有两个 int 类型的入参，且没有返回值（返回 void ）。 *&#x2F;</span><br><span class="line">(int x, int y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;Result:&quot;);</span><br><span class="line">    System.out.println(x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 表示没有入参，且返回一个 int 类型的结果。 *&#x2F;</span><br><span class="line">() -&gt; 1</span><br><span class="line"></span><br><span class="line">&#x2F;* 表示有两个 Apple 类型的入参，且返回一个 int 类型的结果，比较两个苹果的重量。 *&#x2F;</span><br><span class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-使用-Lambda-表达式"><a href="#6-使用-Lambda-表达式" class="headerlink" title="6. 使用 Lambda 表达式"></a>6. 使用 Lambda 表达式</h2><h3 id="6-1-函数式接口"><a href="#6-1-函数式接口" class="headerlink" title="6.1 函数式接口"></a>6.1 函数式接口</h3><blockquote>
<ul>
<li><strong>定义：</strong>只定义了一个抽象方法的接口称为函数式接口。接口中可以包含多个 default 方法，只要接口只定义了一个抽象方法、那么该接口就是函数式接口，比如java.lang.Runnable 类和 java.util.Comparator 类。</li>
<li><strong>作用：</strong>Lambda 表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，且将整个表达式作为函数式接口的实例（具体来说、Lambda表达式是函数式接口的一个实例）。</li>
<li><strong>备注：</strong>可以使用 @FunctionalInterface 注解注明接口是函数式接口，提高代码的可读性。若接口包含多个抽象方法（非函数式接口），使用该注解将会编译报错。</li>
</ul>
</blockquote>
<p><em>示例</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Runnable r1 &#x3D; () -&gt; System.out.println(&quot; 使用 Lambda 表达式。  &quot;);</span><br><span class="line"></span><br><span class="line">    Runnable r2 &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot; 使用匿名类。  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    process(r1);</span><br><span class="line">    process(r2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void process(Runnable r1) &#123;</span><br><span class="line">    if (Objects.nonNull(r1)) &#123;</span><br><span class="line">        r1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论：</strong> 函数式接口通过使用 Lambda 表达式的方式创建接口的一个实例，比通过匿名类的方式，代码更加的简洁大方。</p>
</blockquote>
<h3 id="6-2-常用函数式接口"><a href="#6-2-常用函数式接口" class="headerlink" title="6.2 常用函数式接口"></a>6.2 常用函数式接口</h3><blockquote>
<p>Java API中已经有几个函数式接口，如Comparable、Runnable、Callable</p>
</blockquote>
<h5 id="6-2-1-Predicate"><a href="#6-2-1-Predicate" class="headerlink" title="6.2.1 Predicate"></a>6.2.1 Predicate</h5><p>   java.util.function.Predicate<T> 接口是一个函数式接口，只包含一个test()抽象方法，接受泛型 T 对象，返回一个 boolean 值。</T></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义学生类</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2019&#x2F;8&#x2F;7</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Double weight;</span><br><span class="line">    private Long height;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略了 get&#x2F;set方法, 默认构造函数, 全构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主类</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2019-08-23 16:24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;* 通过Lambda表达式创建一个Predicate实例（test方法表达式为年龄大于10岁） *&#x2F;</span><br><span class="line">        Predicate&lt;Student&gt; agePredicate &#x3D; (Student student) -&gt; student.getAge() &gt; 10;</span><br><span class="line">        &#x2F;* 通过Lambda表达式创建一个Predicate实例（test方法表达式为身高高于165cm） *&#x2F;</span><br><span class="line">        Predicate&lt;Student&gt; heightPredicate &#x3D; (Student student) -&gt; student.getHeight() &gt; 165L;</span><br><span class="line"></span><br><span class="line">        &#x2F;* 创建一些数据 *&#x2F;</span><br><span class="line">        Student sungm &#x3D; new Student(&quot;1&quot;, &quot;sungm&quot;, &quot;1&quot;, 25, 69.1D, 178L);</span><br><span class="line">        Student sunzm &#x3D; new Student(&quot;2&quot;, &quot;sunzm&quot;, &quot;1&quot;, 22, 60.0D, 176L);</span><br><span class="line">        Student sunhw &#x3D; new Student(&quot;3&quot;, &quot;sunhw&quot;, &quot;1&quot;, 1 , 4.1D , 53L);</span><br><span class="line">        Student sunll &#x3D; new Student(&quot;4&quot;, &quot;sunll&quot;, &quot;2&quot;, 24, 55.2D, 168L);</span><br><span class="line">        List&lt;Student&gt; students &#x3D; Arrays.asList(sungm, sunzm, sunhw, sunll);</span><br><span class="line"></span><br><span class="line">        &#x2F;* 筛选出年龄大于10岁的学生 *&#x2F;</span><br><span class="line">        List&lt;Student&gt; ageFilterStudents &#x3D; students.stream().filter(agePredicate).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;* 筛选出年龄小于或等于10岁的学生 *&#x2F;</span><br><span class="line">        List&lt;Student&gt; ageNegateFilterStudents &#x3D; students.stream().filter(agePredicate.negate()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;* 筛选出身高高于165cm的学生 *&#x2F;</span><br><span class="line">        List&lt;Student&gt; heightFilterStudents &#x3D; students.stream().filter(heightPredicate).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;* 筛选出 年龄大于10岁 且 身高高于165cm 的学生 *&#x2F;</span><br><span class="line">        List&lt;Student&gt; ageAndHeightFilterStudents &#x3D; students.stream().filter(agePredicate.and(heightPredicate))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        &#x2F;* 筛选出 年龄大于10岁 或 身高高于165cm 的学生 *&#x2F;</span><br><span class="line">        List&lt;Student&gt; ageOrHeightFilterStudents &#x3D; students.stream().filter(agePredicate.or(heightPredicate))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> Stream.filter()方法接收一个Predicate<T>入参，可用于Java 8 的 Stream 中，其源码如下</T></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a stream consisting of the elements of this stream that match</span><br><span class="line">     * the given predicate.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is an &lt;a href&#x3D;&quot;package-summary.html#StreamOps&quot;&gt;intermediate</span><br><span class="line">     * operation&lt;&#x2F;a&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @param predicate a &lt;a href&#x3D;&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;&#x2F;a&gt;,</span><br><span class="line">     *                  &lt;a href&#x3D;&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;&#x2F;a&gt;</span><br><span class="line">     *                  predicate to apply to each element to determine if it</span><br><span class="line">     *                  should be included</span><br><span class="line">     * @return the new stream</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;其他方法省略</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-Consumer"><a href="#6-2-2-Consumer" class="headerlink" title="6.2.2 Consumer"></a>6.2.2 Consumer</h5><p> java.util.function.Consumer<T> 接口是一个函数式接口，只包含一个accept()抽象方法，接受泛型 T 对象，没有返回值（void）。</T></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;造一批假数据、用于测试</span><br><span class="line">    List&lt;Student&gt; students &#x3D; createStudents();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个Consumer</span><br><span class="line">    Consumer&lt;Student&gt; studentConsumer &#x3D; (Student student) -&gt; student.setOverWeight(student.getWeight() &gt; 50);</span><br><span class="line">    for (Student student : students) &#123;</span><br><span class="line">        &#x2F;&#x2F;消费student</span><br><span class="line">        studentConsumer.accept(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-2-3-Function"><a href="#6-2-3-Function" class="headerlink" title="6.2.3 Function"></a>6.2.3 Function</h5><p>  java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个<br>泛型T的对象，并返回一个泛型R的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;造一批假数据、用于测试</span><br><span class="line">    List&lt;Student&gt; students &#x3D; Test1.createStudents();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个function, 其接收一个student对象，返回student的名称</span><br><span class="line">    Function&lt;Student, String&gt; function &#x3D; Student::getName;</span><br><span class="line">    List&lt;String&gt; studentNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Student student : students) &#123;</span><br><span class="line">        studentNames.add(function.apply(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(studentNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要 Lambda 表达式来抛出异常，有两种办法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda 包在一个try/catch块中。</p>
</blockquote>
<hr>
<h2 id="7-类型检查、类型推断及限制"><a href="#7-类型检查、类型推断及限制" class="headerlink" title="7. 类型检查、类型推断及限制"></a>7. 类型检查、类型推断及限制</h2><h3 id="7-1-类型检查"><a href="#7-1-类型检查" class="headerlink" title="7.1 类型检查"></a>7.1 类型检查</h3><blockquote>
<p>Lambda 类型是从使用 Lambda 的上下文推断出来的，上下文中 Lambda 表达式需要的类型成为目标类型。</p>
</blockquote>
<p><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-fdfe543b21cdabb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-fdfe543b21cdabb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类型检查示例图"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">类型检查示例图</span></div></div></p>
<h3 id="7-2-同样的-Lambda-不同的函数式接口"><a href="#7-2-同样的-Lambda-不同的函数式接口" class="headerlink" title="7.2 同样的 Lambda , 不同的函数式接口"></a>7.2 同样的 Lambda , 不同的函数式接口</h3><blockquote>
<p>有了目标类型的概念，同一个 Lambda 表达式就可以与不同的函数式接口联系起来，只要他们的抽象方法能够兼容。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c &#x3D; () -&gt; 42;</span><br><span class="line">PrivilegedAction&lt;Integer&gt; p &#x3D; () -&gt; 42;</span><br></pre></td></tr></table></figure>
<p><strong>特殊的void兼容规则</strong></p>
<blockquote>
<p>如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当<br>然需要参数列表也兼容）</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Predicate返回了一个boolean</span><br><span class="line">Predicate&lt;String&gt; p &#x3D; s -&gt; list.add(s);</span><br><span class="line">&#x2F;&#x2F; Consumer返回了一个void</span><br><span class="line">Consumer&lt;String&gt; b &#x3D; s -&gt; list.add(s);</span><br></pre></td></tr></table></figure>

<h3 id="7-3-类型推断"><a href="#7-3-类型推断" class="headerlink" title="7.3 类型推断"></a>7.3 类型推断</h3><blockquote>
<p>你还可以进一步简化你的代码。Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式，这意味着它也可以推断出适合 Lambda 的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解 Lambda 表达式的参数类型，这样就可以在 Lambda 语法中省去标注参数类型。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有推断类型</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D; (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">&#x2F;&#x2F; 有推断类型</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D; (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<blockquote>
<p>有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更好；对于如何让代码更易读，你必须做出自己的选择。</p>
</blockquote>
<h3 id="7-4-使用局部变量"><a href="#7-4-使用局部变量" class="headerlink" title="7.4 使用局部变量"></a>7.4 使用局部变量</h3><blockquote>
<p>我们迄今为止所介绍的所有Lambda表达式都只用到了其主体里面的参数。但Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; Lambda 表达式使用了自由变量 x</span><br><span class="line">IntFunction&lt;Integer&gt; function &#x3D; y -&gt; x + y;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<blockquote>
<p>Lambda 可以无限制的获取实例变量和静态变量，但局部变量必须显示声明为 final 类型、或者事实上是 final 类型。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量this。）</p>
</blockquote>
<p><strong>为什么局部变量有这些限制</strong></p>
<blockquote>
<ol>
<li>实例变量保存在堆中，局部变量保存在栈中。如果 Lambda 可以直接访问局部变量，则使用 Lambda的线程，它可能会在分配该局部变量的线程收回该局部变量之后访问该局部变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>
<li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式</li>
</ol>
</blockquote>
<h3 id="7-5-方法引用"><a href="#7-5-方法引用" class="headerlink" title="7.5 方法引用"></a>7.5 方法引用</h3><blockquote>
<p>方法引用可以让你重复的使用现有的方法定义，并像 Lambda 一样传递他们。在一些情况下，比起使用Lambda表达式，它们似乎更易读，感觉也更自然。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用 Lambda 表达式</span><br><span class="line">inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line">&#x2F;&#x2F;使用方法引用</span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>

<h4 id="7-5-1-普通方法引用"><a href="#7-5-1-普通方法引用" class="headerlink" title="7.5.1 普通方法引用"></a>7.5.1 普通方法引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span><br><span class="line">public class Apple &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;省略其他属性...</span><br><span class="line">    private String weight;</span><br><span class="line"></span><br><span class="line">    public String getWeight() &#123;</span><br><span class="line">        return this.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;普通方法引用</span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>

<h4 id="7-5-1-构造方法引用"><a href="#7-5-1-构造方法引用" class="headerlink" title="7.5.1 构造方法引用"></a>7.5.1 构造方法引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span><br><span class="line">public class Apple &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;省略其他属性...</span><br><span class="line">    &#x2F;&#x2F;定义默认构造函数</span><br><span class="line">    public Apple() &#123;</span><br><span class="line">        return this.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造方法引用(下例引用的是默认构造函数)</span><br><span class="line">Supplier&lt;Apple&gt; supplier &#x3D; Apple::new;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-1-静态方法引用"><a href="#7-5-1-静态方法引用" class="headerlink" title="7.5.1 静态方法引用"></a>7.5.1 静态方法引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span><br><span class="line">public class Apple &#123;</span><br><span class="line"></span><br><span class="line">    private static final Apple INSTANCE &#x3D; new Apple(); </span><br><span class="line">    </span><br><span class="line">    private Apple() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Apple getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态方法引用</span><br><span class="line">Apple::getInstance;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java 8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 概述</title>
    <url>/2020/06/13/Java-NIO-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1-什么是NIO？"><a href="#1-什么是NIO？" class="headerlink" title="1.  什么是NIO？"></a>1.  什么是NIO？</h2><blockquote>
<p>java.nio 全称 java non-blocking IO，是指 JDK1.4 及以上版本里提供的新 API（New IO） ，为所有的原始类型（ boolean 类型除外）提供<a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98/100710" target="_blank" rel="noopener">缓存</a>支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。【百度百科】 </p>
</blockquote>
<a id="more"></a>

<hr>
<p>优点：NIO 比 AIO（异步I/O） 更加强大，处理数据更快。它可以大大的提高IO吞吐量，常用在高性能服务器上面。</p>
<h2 id="2-NIO原理"><a href="#2-NIO原理" class="headerlink" title="2. NIO原理"></a>2. NIO原理</h2><blockquote>
<p>使用较少的线程执行更多的任务。</p>
</blockquote>
<blockquote>
<p>如下图所示，使用较少的线程，通过 Selector 选择器来执行不同 Channel 通道中的任务，执行任务再结合 AIO（异步I/O）就能发挥服务器的最大性能，更大程度上提升服务器的运行效率。</p>
</blockquote>
<p><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-0a82f84999ea3e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-0a82f84999ea3e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理图"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">原理图</span></div></div></p>
<hr>
<h2 id="3-与常规-I-O-的区别"><a href="#3-与常规-I-O-的区别" class="headerlink" title="3. 与常规 I/O 的区别"></a>3. 与常规 I/O 的区别</h2><blockquote>
<p>常规 I/O （如 InputStream 和 OutputStream）存在很大的缺点，就是他们是阻塞的，而 NIO 解决的就是常规 I/O 执行效率低的问题，即采用非阻塞高性能运行的方式来避免以前以前“笨拙” I/O 带来的低效率问题。NIO在大文件操作上相比常规 I/O 更加优秀，对常规 I/O 使用的 byte[] 和 char[] 进行封装，采用 ByteBuffer 类来操作数据，再结合针对 File 或者 Socket 技术的 Channel，采用同步非阻塞技术实现高性能处理。</p>
</blockquote>
<hr>
<h2 id="4-缓冲区介绍"><a href="#4-缓冲区介绍" class="headerlink" title="4. 缓冲区介绍"></a>4. 缓冲区介绍</h2><blockquote>
<p>在使用传统的I/O流API时，如 InputStream 和 OutputStream ，以及Reader和Writer联合使用时，常常把字节流中的数据放入byte[]字节数组中，或把字符流中的数据放入char[]字符数组中，也可以从 byte[] 或 char[] 数组中获取数据来实现功能上的需求，但由于在 Java 语言中对 array 数组自身进行操作的 API 非常少，常用的操作仅仅是 length 属性和下标[x]了，在 JDK 中也没有提供更加方便操作数组中数据的 API，如果对数组中的数据进行高级处理，需要程序员自己写代码进行实现，处理的方式是比较原始的，这个问题可以使用 NIO 技术中的缓冲区Buffer类来解决，它提供了很多工具方法，大大提高了程序开发的效率。</p>
</blockquote>
<hr>
<p>推荐书籍：</p>
<ul>
<li>[高洪岩]《Java多线程编程核心技术》</li>
<li>[高洪岩]《Java并发编程：核心方法与框架》</li>
<li>[高洪岩]《NIO与Socket编程技术指南》</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 18. Lock</title>
    <url>/2020/09/02/Lock-In-Java/</url>
    <content><![CDATA[<p>Lock 是除synchronized代码块的另外一种线程同步机制，Lock可以具有比synchronized代码块更复杂的作用。Lock可以使用synchronized关键字，所以它并不能让我们摆脱synchronized关键字。</p>
<p>自JDK 5开始，java.util.concurrent.locks包提供了一些Lock的实现类，比如ReentrantLock、ReadWriteLock、Condition，因此你可能不需要自己自定义Lock，但是你可能需要知道如何使用它们并了解其中的原理。这里我们不详细讲解，更多的细节，后面我将总结JUC工具包的相关知识点。</p>
<h3 id="1-简单的Lock"><a href="#1-简单的Lock" class="headerlink" title="1. 简单的Lock"></a>1. 简单的Lock</h3><p>先看看synchronized的同步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line"></span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public int inc() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            return ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意inc()方法里面的synchronized(this)代码块，这个代码块确保了同一时间只有一个线程能够执行 ++count 指令。下面我们看看使用自定义的Lock代替上面这段代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Counter&#123;</span><br><span class="line">    </span><br><span class="line">    private Lock lock  &#x3D; new Lock();</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public int inc() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        int newCount &#x3D; ++count;</span><br><span class="line">        lock.unLock();</span><br><span class="line">        return newCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意lock()方法中的while (hasLock)循环，我们称它为“自旋锁”，自旋锁解决了线程通信的虚假唤醒的问题。</p>
<hr>
<h3 id="2-锁重入"><a href="#2-锁重入" class="headerlink" title="2. 锁重入"></a>2. 锁重入</h3><p>当某个线程进入同步代码块时，首先会尝试获取同步代码块的对象锁，一个线程可以拥有多个对象锁，由于不同同步代码块可能具有相同的对象锁，当线程拥有某个对象锁时，进入这个对象锁的同步代码块不需要再次获取锁，我们称它为可重入锁。</p>
<p>synchronized 具有重入锁的机制。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Reentrant &#123;</span><br><span class="line">    </span><br><span class="line">    public synchronized void methodA() &#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void methodB() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意普通方法A和普通方法B都使用了synchronized关键字声明，它的监视器对象是Reentrant的一个实例对象，methodA()中调用了methodB()，当某个线程进入进入methodA()，获取到对应的锁，进入methodB()不需要再次获取锁，可以直接进入methodB()。</p>
<p>JUC中还提供了一些重入锁，比如ReentrantLock、ReentrantReadWriteLock等等，这里我们不细讲，后面请看JUC博客专题。</p>
<p>现在我们自定义一个可重入锁。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义可重入锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-03 10:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CustomReentrantLock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line">    private Thread lockedBy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        while (hasLocked &amp;&amp; lockedBy !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">        lockedBy &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        lockedBy &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，while 循环中不仅要判断hasLocked是否被锁住还要判断当前线程是否是锁被拥有的线程，这就是可重入的锁。</p>
<hr>
<h3 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="3. 公平锁"></a>3. 公平锁</h3><p>在上一章<a href="https://miracle-sungm.github.io/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/" target="_blank" rel="noopener">饥饿与公平</a> 中我们讲了不公平锁和公平锁，synchronized是一种不公平的锁。</p>
<hr>
<h3 id="4-在finally代码块中调用unLock-方法"><a href="#4-在finally代码块中调用unLock-方法" class="headerlink" title="4. 在finally代码块中调用unLock()方法"></a>4. 在finally代码块中调用unLock()方法</h3><p>当关键代码（介于lock和unLuck之间的代码）可能抛出异常，请在finally代码块中调用unLock()方法。</p>
<hr>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 11. Java Happen Before Guarantee</title>
    <url>/2020/08/14/Guarantee/</url>
    <content><![CDATA[<p>Java Happen Before Guarantee 是JVM(Java虚拟机)与CPU为了提高性能允许指令重排的一组管理规则。Happen Before Guarantee 主要包含访问 volatile 变量或访问 synchronized 代码块中的变量。</p>
<h3 id="1-指令重排"><a href="#1-指令重排" class="headerlink" title="1. 指令重排"></a>1. 指令重排</h3><p>现代计算机有能力并行执行指令，当一个指令不依赖其他指令时，可能发生指令重排。如下所示：两个指令不相互依赖，计算机可以并行执行这两个指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; e + f;</span><br></pre></td></tr></table></figure>
<p>下面这2个指令不会发生指令重排，因为第二个指令依赖第一个指令产生的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a + e;</span><br></pre></td></tr></table></figure>
<p>指令重排的结果可以让指令在CPU中并行执行，以提高性能。指令重排在JVM和CPU中是被允许的，前提是程序中的语句没有发生改变。指令重排后程序执行的结果必须与没有指令重排时程序执行的结果保持一致。</p>
<hr>
<h3 id="2-指令重排在多CPU计算机中的问题"><a href="#2-指令重排在多CPU计算机中的问题" class="headerlink" title="2. 指令重排在多CPU计算机中的问题"></a>2. 指令重排在多CPU计算机中的问题</h3><p>指令重排在多线程、多CPU系统中存在一些挑战。请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int a &#x3D; 0;</span><br><span class="line">private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;有点意思&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>在第一个线程中，a = 1 与 b = 1 两个指令不相互影响，CPU为了提高执行性能，可能并行执行这两个指令，这种情况下， b = 1 指令可能在 a = 1 前面执行，若执行 b = 1 后（假定 a = 1 指令还未执行，此时 a 的值为初始值 0），此时第二个线程正在执行判断条件 a == 0 &amp;&amp; b == 1，那么将会打印数据 ‘有点意思’。为了验证这个问题，我们来循环执行这段代码。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-08-13 15:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static int a &#x3D; 0;</span><br><span class="line">    private static int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    System.out.println(&quot;有点意思&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            a &#x3D; 0;</span><br><span class="line">            b &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你觉得这段代码有意思，不妨自己试一试。多等待一会，你会发现控制台输出了“有点意思”。</p>
<hr>
<h3 id="3-volatile-可见性保证"><a href="#3-volatile-可见性保证" class="headerlink" title="3. volatile 可见性保证"></a>3. volatile 可见性保证</h3><p>Java volatile 关键字提供了读写的可见性保证，当线程读volatile变量时会从主内存中读取数据，当线程修改volatile变量时会将变量的值写回到主内存中。这种同步到主内存的机制保证了变量的值对其他线程可见，这就是volatile可见性保证。</p>
<h5 id="3-1-volatile-修改数据可见性保证"><a href="#3-1-volatile-修改数据可见性保证" class="headerlink" title="3.1 volatile 修改数据可见性保证"></a>3.1 volatile 修改数据可见性保证</h5><p>当线程修改volatile变量的值时，修改后的值会被同步到主内存中。另外，<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。（请注意这句话，线程所有的变量都会随volatile变量写回到主内存中，不只是volatile变量写回到主内存中）</strong></p>
<p>请看示例：<br>(1) 首先我们用简单的代码证明使用 volatile 定义的变量的值被某个线程修改后对其他线程可见。：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意这里没有使用volatile关键字</span><br><span class="line">    private boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public boolean isKeepRunning() &#123;</span><br><span class="line">        return keepRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;子线程把keepRunning的值改为true</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程中循环尝试获取子线程修改后的keepRunning的值，如果获取到，输出有点意思</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (myRunnable.isKeepRunning()) &#123;</span><br><span class="line">            System.out.println(&quot;有点意思&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你亲手运行了这段代码，你会发现这个程序永远不会输出“有点意思”。现在我们使用volatile定义keepRunning属性，其他代码不变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用volatile定义</span><br><span class="line">private volatile boolean keepRunning &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>使用volatile关键字后，程序循环输出“有点意思”。</p>
<p><strong>因此我们可以得出结论：volatile 定义的变量的值被某个线程修改后对其他线程可见。</strong></p>
<p>(2) 现在我们来证明下我们前面说的：<strong>线程里包含的所有变量都会随 volatile 变量写回到主内存中。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用了 volatile 关键字的属性</span><br><span class="line">    private volatile boolean keepRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;未使用 volatile 关键字的属性</span><br><span class="line">    private String strA &#x3D; &quot;A&quot;;</span><br><span class="line">    private String strB &#x3D; &quot;B&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        keepRunning &#x3D; true;</span><br><span class="line">        strA &#x3D; &quot;a&quot;;</span><br><span class="line">        strB &#x3D; &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyRunnable&#123;&quot; +</span><br><span class="line">                &quot;keepRunning&#x3D;&quot; + keepRunning +</span><br><span class="line">                &quot;, strA&#x3D;&#39;&quot; + strA + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, strB&#x3D;&#39;&quot; + strB + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动子线程</span><br><span class="line">    new Thread(myRunnable).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(200L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(myRunnable.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序最终输出：MyRunnable{keepRunning=true, strA=’a’, strB=’b’}</p>
<p>这个结果我们不难看出：子线程修改了keepRunning、strA和strB的值（strA和strB未使用volatile关键字），主线程不仅读取到了keepRunning更新后的值，还读取到了strA和strB更新后的值。所以请记住：<strong>线程里包含的所有变量都会随volatile变量写回到主内存中。</strong></p>
<h5 id="3-2-volatile-读取数据可见性保证"><a href="#3-2-volatile-读取数据可见性保证" class="headerlink" title="3.2 volatile 读取数据可见性保证"></a>3.2 volatile 读取数据可见性保证</h5><p>当线程读取被 volatile 关键字修饰的变量时，会从主内存中读取。<strong>另外：线程里所有的变量都会随着 volatile 变量读取到CPU缓存或者寄存器中。</strong></p>
<p>比如下面三个变量，当线程读取strA的值时，会重定向到主内存中读取strA的值，如果strB，strC同样在线程中，也会从主内存中读取strB，strC的值。我们本章3.1节的例子同样能证明此特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valatile String strA &#x3D; &quot;A&quot;;</span><br><span class="line">String strB &#x3D; &quot;B&quot;;</span><br><span class="line">String strC &#x3D; &quot;C&quot;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-volatile-happens-before-保证"><a href="#3-3-volatile-happens-before-保证" class="headerlink" title="3.3 volatile happens-before 保证"></a>3.3 volatile happens-before 保证</h5><p>volatile happens-before 保证设置了一些关于volatile变量指令重排的限制（规定）。</p>
<p><strong>volatile write happens-before guarantee</strong></p>
<p>volatile write happens-before guarantee: <strong>所有volatile写之前的指令不允许被重排序到volatile指令后面。</strong></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure>
<p>示例中 nonVolatileVariableA、nonVolatileVariableB两个变量是没有被volatile修饰的变量，volatileVariableC变量被volatile修饰。volatile write happens-before 保证了前面两个指令不能重排序到第三个指令后面，也就是不会发生下面这类重排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br></pre></td></tr></table></figure>
<p>但是示例可能会发生下面这种重排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonVolatileVariableB &#x3D; &quot;b&quot;;</span><br><span class="line">nonVolatileVariableA &#x3D; &quot;a&quot;;</span><br><span class="line">volatileVariableC &#x3D; &quot;c&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>volatile read happens-before guarantee</strong></p>
<p>volatile read happens-before guarantee: <strong>所有volatile读之后的指令不允许被重排序到volatile指令前面。</strong></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br></pre></td></tr></table></figure>
<p>volatile read happens-before 保证了最后两个指令不能重排序到第一个指令前面，也就是不会发生下面这类重排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nonVolatileVariableA;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">volatileVariableC;</span><br></pre></td></tr></table></figure>
<p>示例可能会发生下面这种重排序的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatileVariableC;</span><br><span class="line">nonVolatileVariableB;</span><br><span class="line">nonVolatileVariableA;</span><br></pre></td></tr></table></figure>

<p><strong>总结volatile happens-before guarantee：所有volatile写之前的指令不允许被重排序到volatile指令后面；所有volatile读之后的指令不允许被重排序到volatile指令前面。（简记：volatile写之前读之后）</strong></p>
<hr>
<h3 id="4-synchronized-可见性保证"><a href="#4-synchronized-可见性保证" class="headerlink" title="4. synchronized 可见性保证"></a>4. synchronized 可见性保证</h3><p>synchronized 可见性保证 与 volatile 可见性保证非常相似。</p>
<h5 id="4-1-synchronized-锁进入可见性保证"><a href="#4-1-synchronized-锁进入可见性保证" class="headerlink" title="4.1 synchronized 锁进入可见性保证"></a>4.1 synchronized 锁进入可见性保证</h5><p>当一个进程进入 synchronized同步代码块（或同步方法），线程内所有可见变量都将从主内存中读取数据。</p>
<h5 id="4-2-synchronized-锁退出可见性保证"><a href="#4-2-synchronized-锁退出可见性保证" class="headerlink" title="4.2 synchronized 锁退出可见性保证"></a>4.2 synchronized 锁退出可见性保证</h5><p>当一个进程退出 synchronized同步代码块（或同步方法），线程内所有可见变量数据都将写回到主内存中。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line"></span><br><span class="line">    private int numberA &#x3D; 1;</span><br><span class="line">    private int numberB &#x3D; 2;</span><br><span class="line">    private int numberC &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter方法</span><br><span class="line"></span><br><span class="line">    void copyNumber(Demo demo) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">        &#125;</span><br><span class="line">        this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">        this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：当某个线程进入 copyNumber() 方法的 synchronized 代码块时，线程内所有的可见变量都会从主内存中加载数据，也就是说 this 对象的 numberA, numberB也会从主内存中读取数据；退出synchronized 代码块时，线程内所有的可见变量都会写回到主内存中，this 对象的 numberA, numberB修改后的值也会被写回到主内存中。</p>
<h5 id="4-3-synchronized-happens-before-guarantee"><a href="#4-3-synchronized-happens-before-guarantee" class="headerlink" title="4.3 synchronized happens-before guarantee"></a>4.3 synchronized happens-before guarantee</h5><p>synchronized 提供了两种 happens-before guarantee ：一种与开始进入synchronized 代码块有关；另外一种与退出synchronized 代码块有关。</p>
<p><strong>synchronized beginning happens-before guarantee :</strong></p>
<p>我们已经知道，当线程进入 synchronized 代码块时，线程所有可见变量都将从主内存中读取数据。</p>
<p>请看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程进入 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 都将从主内存中读取数据。</p>
<p>对于上面这个示例，<strong>所有的变量的读取指令都不会重排序到进入 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getNumber(Number n) &#123;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized end happens-before guarantee :</strong></p>
<p>我们已经知道，当线程退出 synchronized 代码块时，线程所有可见变量的数据都将写回到主内存中。</p>
<p>请看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getNumber(Demo demo) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; demo.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.numberA &#x3D; demo.getNumberA();</span><br><span class="line">    this.numberB &#x3D; demo.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程退出 synchronized 代码块时，线程所有可见变量 this.numberA, this.numberB, this.numberC 的数据都将写回到主内存中。</p>
<p>对于上面这个示例，<strong>所有的变量的写的指令都不会重排序到退出 synchronized 代码块指令前面。</strong> 也就是说，不会发生下面这种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void copyNumber(Number n) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        this.numberC &#x3D; n.getNumberC();</span><br><span class="line">    &#125;</span><br><span class="line">    this.numberA &#x3D; n.getNumberA();</span><br><span class="line">    this.numberB &#x3D; n.getNumberB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结 synchronized happens-before时，我总感觉把它总结的太复杂了，你可以简单的理解为 synchronized 不与其他指令发生指令重排，因为 synchronized happens-before 保证了线程在读取数据和写回数据时都会限制指令重排的发生。</strong></p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 10. Java内存模型</title>
    <url>/2020/08/12/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java Memory Model(JMM: Java内存模型)提到 Java Virtual Machine(JVM: Java虚拟机) 如何与计算机内存工作。JVM是整个计算机模型，所以它包含JMM。</p>
<p>如果你想要设计出正确的并发程序，那么理解JMM是非常重要的。Java内存模型会提到一个线程怎样获取被别的线程修改后的共享变量的值；也会提到当有必要的时候，怎样让多个线程顺序的访问共享变量。</p>
<p>注意：原来的Java内存模型进行过修订，从Java 1.5 到 Java 14+，这个版本的内存模型仍然适用。</p>
<h3 id="1-Java-Memory-Model"><a href="#1-Java-Memory-Model" class="headerlink" title="1. Java Memory Model"></a>1. Java Memory Model</h3><p>在JVM中，JMM包含两种内存模型：Thread Stacks(线程栈)、Heap(堆内存)。如图所示</p>
<p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt></div></p>
<p><strong>内存模型</strong></p>
<ol>
<li>每个在JVM中运行的线程都有自己的线程栈。这个线程栈包含线程中调用的方法信息和程序计数器（当前程序所执行的字节码的行号指示器）。</li>
<li>在开始执行某个方法的时候，会在线程栈中存储方法内所有的local variable(局部变量)，局部变量只对创建它的线程可见，其他线程无法访问。即使两个线程同时执行同一个方法，这两个线程都会创建局部变量保存至属于自己的线程栈中，线程只能访问自己线程栈中的数据。</li>
<li>所有基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量都保存在线程栈中，并且对其他线程不可见。一个线程可能拷贝一个基本数据类型变量给其他线程，但不会共享原始的局部变量（这里是值传递）。</li>
<li>堆内存中包含Java应用程序中所有对象的创建，不论哪个线程创建的对象都存储在堆内存中，并且包含基础数据类型的包装类也存储于堆内存中。对象的创建不管是作为局部变量、还是作为对象的成员，都始终保存于堆内存中。</li>
</ol>
<p>如下图所示：</p>
<p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png" alt></div></p>
<ol>
<li>一个本地变量可能是一个基本数据类型，这种情况下本地变量将完全保存在线程栈中。</li>
<li>一个本地变量可能引用一个对象，这种情况下对象的引用保存在线程栈中，对象保存在堆内存中。</li>
<li>一个对象可能包含一些方法，方法包含一些本地变量。本地变量保存在线程栈中，方法保存随对象保存在堆内存中。</li>
<li>一个对象的成员变量随对象保存在堆内存中，不论这个成员变量是基本数据类型还是引用其他对象，成员变量都保存在堆内存中。</li>
<li>静态变量随 class(类) 保存在堆内存中。</li>
</ol>
<p>堆内存的对象可以被任何具有该对象引用的线程访问。</p>
<hr>
<h3 id="2-计算机硬件内存结构"><a href="#2-计算机硬件内存结构" class="headerlink" title="2. 计算机硬件内存结构"></a>2. 计算机硬件内存结构</h3><p>现代硬件内存结构与Java内存模型有些不同，为了更好的理解Java内存模型，了解硬件内存结果是很重要的。</p>
<p>通常的硬件内存结构。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt></div></p>
<p>现代计算机通常拥有2个以上的CPU，有些CPU有多个内核。重点是多CPU计算机可以同时执行多个线程。当你的Java应用程序是多线程应用程序，在你的应用程序中可能同时出现每个CPU都在执行线程的情况。</p>
<ol>
<li>每个CPU有一组（注意是一组，多个）CPU寄存器，CPU操作寄存器的速度比操作主内存更快，这也意味着CPU访问寄存器的速度比访问内存更快。</li>
<li>每个CPU也可能有一个CPU缓存（CPU Cache Memory），事实上，每个CPU可能有一定数量的CPU缓存。CPU访问CPU缓存的速度比访问内存的速度快，通常情况下CPU访问CPU缓存的速度没有访问寄存器的速度快。因此你可以认为CPU访问内存的顺序依次是：寄存器 &gt; CPU缓存 &gt; 主内存。另外，一些CPU可能会有多级CPU缓存（L1,L2,L3等）。</li>
<li>每个计算机都包含一个主内存，主内存的容量比CPU缓存的容量更大。</li>
<li>通常情况下，CPU访问内存会读取主内存中的一些数据拷贝至CPU缓存，甚至拷贝至CPU内部的寄存器，然后可以在CPU缓存或者寄存器操作数据。当CPU需要写回数据至主内存中时，它首先会将寄存器中的结果值提交至CPU缓存中，然后再将CPU缓存的值提交至主内存中。</li>
<li>当CPU需要将CPU缓存的数据提交至主内存中时，CPU缓存的数据将会被写回主内存中。</li>
</ol>
<h5 id="2-1-桥接Java内存模型和计算机硬件内存结构"><a href="#2-1-桥接Java内存模型和计算机硬件内存结构" class="headerlink" title="2.1 桥接Java内存模型和计算机硬件内存结构"></a>2.1 桥接Java内存模型和计算机硬件内存结构</h5><p>如您所知，Java内存模型与现代计算机硬件内存结构不同，硬件内存结构没有区分线程栈内存和堆内存。也就是说：线程栈内存和堆内存可以都存在于硬件的主内存、CPU高速缓存、寄存器中。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png" alt></div></p>
<p>当Java对象和变量可以保存在不同的计算机内存区域中，这就可能会导致一些问题的发生。主要的两个问题是：</p>
<ol>
<li>当线程更新共享数据时，共享数据在多个线程中的可见性。</li>
<li>当多个线程读、写、检查共享数据时，产生竞争条件。</li>
</ol>
<p>下面我们来解释这2个问题</p>
<h5 id="2-2-共享数据的可见性"><a href="#2-2-共享数据的可见性" class="headerlink" title="2.2. 共享数据的可见性"></a>2.2. 共享数据的可见性</h5><p>如果多个线程共享一个对象，并且代码中没有使用 volatile 关键字和 synchronized 同步代码块。当一个线程更新这个共享对象后，修改后的对象的值可能对其他线程不可见。</p>
<p>想象一下，当一个共享对象保存在主内存中时，一个CPU正在执行某个线程时把主内存中共享对象缓存至CPU高速缓存上，另外一个CPU也把共享对象缓存到CPU高速缓存中，其中一个CPU在CPU高速缓存中更新了共享数据并把共享数据写回到主内存中，此时另外一个CPU的CPU高速缓存还是旧的共享资源数据。</p>
<p>下图中解释了上面这种场景。下图左边的正在执行某个线程的CPU将 obj.count 加载到CPU高速缓存中，同时将 obj.count 的值改为 2。左边这个线程对 obj.count 的值进行修改后，对执行其他线程的CPU并不可见。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt></div></p>
<p>解决这个问题我们可以使用 Java 提供的 volatile 关键字。这个关键字用于修饰某个成员变量，当线程要读取这个变量的值时，会从读取主内存中读取变量的值，并且每次修改变量的值时都会重新写回到主内存中。（后面会有文章详细介绍 volatile 关键字）</p>
<h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>如果多个线程共享一个对象，并且有多个线程修改共享变量，可能产生竞争条件。</p>
<p>想象一下，如果一个线程A从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，同时线程B也从主内存中读取共享变量 obj.count 并写入CPU高速缓存中，线程A和线程B同时对 obj.count 做自增操作，也就是说 obj.count 同时被自增2次，在每个CPU里面自增一次。如果变量 obj.count 的同步执行递增2次，那么这个变量写回主内存时值应该是 obj.count + 2，然而这2次递增没有同步执行，实际上是在线程A和线程B并行执行，最终线程A和线程B把 obj.count 的值写回数据到主内存后，实际值变成了 obj.count + 1。如下图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png" alt></div></p>
<p>解决这个问题我们可以使用 Java 提供的 synchronized 锁。synchronized 可以分别用于 代码块、普通方法、静态方法。后面有文章介绍 synchronized，这里不做过多描述。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 14. ThreadLocal</title>
    <url>/2020/08/21/ThreadLocal/</url>
    <content><![CDATA[<p>Java的ThreadLocal类能够让我们创建各个线程独有的线程变量，这个线程变量只有创建它的线程可以对它做读写操作。即使两个线程执行同一段代码，并且这个代码引用了同一个ThreadLocal变量，这两个线程也不能访问彼此的ThreadLocal变量。因此，Java 的 ThreadLocal 类以一种非常简单的方式确保了线程安全。</p>
<p>建议: 看这篇博客的同时，阅读一遍 java.lang.ThreadLocal 的源码，相信您从源码中获取的知识点会更多一些。</p>
<h3 id="1-创建一个线程变量"><a href="#1-创建一个线程变量" class="headerlink" title="1. 创建一个线程变量"></a>1. 创建一个线程变量</h3><p>我们可以通过下面这种方式创建一个ThreadLocal对象，我们还可以给它指定泛型类型，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这个代码只需要执行一次。然后线程就可以对它设置值（set）或者读取值（get），每个线程只能获取到它们自己设置的值。</p>
<hr>
<h3 id="2-设置-ThreadLocal-的值"><a href="#2-设置-ThreadLocal-的值" class="headerlink" title="2. 设置 ThreadLocal 的值"></a>2. 设置 ThreadLocal 的值</h3><p>一旦创建了ThreadLocal对象，就可以设置ThreadLocal的值，我们通过set()方法设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-获取-ThreadLocal-的值"><a href="#2-获取-ThreadLocal-的值" class="headerlink" title="2. 获取 ThreadLocal 的值"></a>2. 获取 ThreadLocal 的值</h3><p>通过get()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-移除-ThreadLocal-的值"><a href="#3-移除-ThreadLocal-的值" class="headerlink" title="3. 移除 ThreadLocal 的值"></a>3. 移除 ThreadLocal 的值</h3><p>通过remove()方法获取ThreadLocal的值，若创建ThreadLocal对象的时候声明了泛型类型，那么获取到的对象不需要做强制转换，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-ThreadLocal-泛型"><a href="#4-ThreadLocal-泛型" class="headerlink" title="4. ThreadLocal 泛型"></a>4. ThreadLocal 泛型</h3><p>我们可以给ThreadLocal指定泛型类型，指定泛型类型之后只能设置泛型类型的值，另外，获取ThreadLocal的值时不需要做类型转换。</p>
<p>正如我们上面提出的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定泛型类型为String</span><br><span class="line">private ThreadLocal&lt;String&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置值</span><br><span class="line">threadLocal.set(&quot;A thread local value&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值</span><br><span class="line">String threadLocalValue &#x3D; threadLocal.get();</span><br></pre></td></tr></table></figure>













































]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>XML基础</title>
    <url>/2020/06/16/XML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-XML概述"><a href="#1-XML概述" class="headerlink" title="1. XML概述"></a>1. XML概述</h2><p>XML : 可拓展标记语言（Extensible Markup Language, XML）。 是一个非常有用的、用来描述结构化信息的技术。</p>
<h3 id="1-1-XML文档头"><a href="#1-1-XML文档头" class="headerlink" title="1.1 XML文档头"></a>1.1 XML文档头</h3><p>XML 文档应当以一个文档头开始，严格来说，文档头是可选的，但是强烈建议使用文档头。文档类型定义的是确保文档正确的一个重要机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-XML元素"><a href="#1-2-XML元素" class="headerlink" title="1.2 XML元素"></a>1.2 XML元素</h3><p>XML 文档的正文包含根元素，根元素包含其他元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;title&gt;miracle&#39;s blog&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;content&gt;XML基础与解析&lt;&#x2F;content&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p>元素可以有子元素、文本或两者兼有。在设计XML文档时，对元素的设计的最好的方式是：要么全部使用元素，要么全部使用文本，这样做的目的是方便解析。</p>
</blockquote>
<p>我们应该避免下面这种设计:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!-- 不推荐：元素config既包含文本、又包含元素 --&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    miracle&#39;s blog</span><br><span class="line">    &lt;content&gt;XML基础与解析&lt;&#x2F;content&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-XML属性"><a href="#1-3-XML属性" class="headerlink" title="1.3 XML属性"></a>1.3 XML属性</h3><p>XML 元素可以包含属性，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config version&#x3D;&quot;1.0&quot;&gt;&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure>

<p>问题：什么时候使用属性，什么时候使用元素？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文档一：</span><br><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config version&#x3D;&quot;1.0&quot;&gt;&lt;&#x2F;config&gt;</span><br><span class="line"></span><br><span class="line">文档二：</span><br><span class="line">&lt;?xml version&#x3D;1.0 encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面示例来看，文档一似乎比文档二要更简单一些。然而，属性的灵活性要比元素差很多，通常情况下属性只应该用来作为值的解释，而不是用来作为值。</p>
</blockquote>
<p>结论：</p>
<blockquote>
<p>优先使用元素，通常情况下属性只应该用来作为值的解释，而不是用来作为值。</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>在HTML中，所有的属性都不会展示在HTML中。</p>
</blockquote>
<hr>
<h2 id="2-XML与属性文件（property-file）的区别"><a href="#2-XML与属性文件（property-file）的区别" class="headerlink" title="2. XML与属性文件（property file）的区别"></a>2. XML与属性文件（property file）的区别</h2><p>属性文件包含了各种键值对，例如：</p>
<blockquote>
<p>name=sungm</p>
</blockquote>
<p>区别：</p>
<blockquote>
<ol>
<li>属性文件结构更加简洁，在要描述的信息更加复杂的场景下，属性文件不能更好的处理它，XML文件可以处理更加复杂的结构化信息。</li>
<li>属性文件采用的是单一的平面结构，XML文件采用的是层次结构，也可以说是树型结构，更加清晰。</li>
<li>属性文件中key是不能重复的，XML文件可以存在重复的元素。</li>
</ol>
</blockquote>
<p>结论：</p>
<blockquote>
<p>在处理不复杂的结构化信息时优先考虑使用属性文件，在处理复杂的结构化信息时考虑使用XML文件</p>
</blockquote>
<hr>
<h2 id="3-XML与HTML的区别"><a href="#3-XML与HTML的区别" class="headerlink" title="3. XML与HTML的区别"></a>3. XML与HTML的区别</h2><p>HTML : 超文本标记语言（Hyper Text Markup Language）</p>
<p>区别：</p>
<blockquote>
<ol>
<li>HTML对大小写不敏感；XML对大小写敏感</li>
<li>在HTML中，如果从上下文中可以分清哪里是段落或者列表项的结尾，那么结束标签可以省略；XML不可省略结束标签</li>
<li>在XML中，只有单个标签而没有对应的结束标签的元素必须以 / 结尾。</li>
<li>在XML中，属性值必须用引号括起来；在HTML中，引号可有可无</li>
<li>在HTML中，属性可以没有值；在XML中，属性必须都有属性值</li>
</ol>
</blockquote>
<h2 id="4-良好的XML文档格式"><a href="#4-良好的XML文档格式" class="headerlink" title="4. 良好的XML文档格式"></a>4. 良好的XML文档格式</h2><blockquote>
<ul>
<li>XML文档必须有根元素，且只能有1个根元素</li>
<li>XML文档必须有关闭标签</li>
<li>XML文档对大小写敏感</li>
<li>XML对大小写敏感</li>
<li>XML元素必须被正确的嵌套</li>
<li>XML属性必须加引号</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.Object 类详解</title>
    <url>/2020/06/12/java-lang-Object-%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote>
<p>Object 方法包括 5 个非 final 类型的方法，分别是：clone、hashCode、equals、toString、finalize 方法；包括 4 个 final 方法，分别是 getClass、wait、notify、notifyAll 方法。其中 clone 方法是 protected 方法，finalize 方法自 Java 9 之后被废弃。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-clone-方法"><a href="#1-clone-方法" class="headerlink" title="1. clone 方法"></a>1. clone 方法</h2><h3 id="1-1-源码"><a href="#1-1-源码" class="headerlink" title="1.1 源码"></a>1.1 源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<p>说明：调用该方法实现一个对象的浅复制，创建并且返回此对象的副本（“副本”的准确含义可能依赖于对象的类）。 Object.clone() 方法是一个 protected 方法，类只有实现 java.lang.Cloneable 接口，并重写 Object.clone() 方法才能使用该 clone 方法，否则抛出 CloneNotSupportedException 。</p>
<h3 id="1-2-clone-与-copy-的区别"><a href="#1-2-clone-与-copy-的区别" class="headerlink" title="1.2 clone 与 copy 的区别"></a>1.2 clone 与 copy 的区别</h3><p>假设我们有一个 Person 对象，并假设 Person 类实现了Cloneable 接口并重写了 clone 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person a &#x3D; new Person();</span><br><span class="line">&#x2F;&#x2F;copy 的做法通常为:</span><br><span class="line">Person b &#x3D; a;</span><br><span class="line">&#x2F;&#x2F;clone 的做法通常为:</span><br><span class="line">Person c &#x3D; a.clone();</span><br></pre></td></tr></table></figure>

<p>说明：<br>（1）copy 是将对象 a 的引用赋值给对象 b，赋值之后对象 a 和对象 b 都指向同一个引用 a。<br>（2）clone 是实现对象的浅拷贝，产生一个新的对象，对象 c 与 对象 a 不指向同一个引用。</p>
<blockquote>
<p>clone 在内存中实际操作是：将对象 a 的内存，拷贝一个副本，并重新分配一块内存区域用于保存副本。</p>
</blockquote>
<h3 id="1-3-浅拷贝和深拷贝"><a href="#1-3-浅拷贝和深拷贝" class="headerlink" title="1.3 浅拷贝和深拷贝"></a>1.3 浅拷贝和深拷贝</h3><blockquote>
<p>前面我们提到，clone 在内存中的实际操作时将一个对象的内存拷贝出一个副本、并重新分配一个内存用于保存副本。由于原对象（被拷贝的对象）属性可能存在两种值传递类型，分别是值传递和引用传递，对副本的操作可能对原对象造成影响（改变副本的引用传递属性的值，由于引用传递导致原对象的响应值同样改变）。</p>
</blockquote>
<blockquote>
<p>如果一个对象包含引用传递类型的属性，直接拷贝对象，不做特殊处理，这种拷贝称为浅拷贝。若一个对象不存在引用传递类型的数据，那也就不区别什么浅拷贝和深拷贝，可以称为浅拷贝也可以称为深拷贝。</p>
</blockquote>
<p>示例：</p>
<p>定义2个类：Person类 包含 Book属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;省略 constructor 、 getter 、 setter 方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, book&#x3D;&quot; + book +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">    private String bookName;</span><br><span class="line">    private String author;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;省略 constructor 、 getter 、 setter 方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    &#x2F;&#x2F;主方法：</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Book effectiveJava &#x3D; new Book(&quot;Effective Java&quot;, &quot;Joshua Bloch&quot;);</span><br><span class="line">        Person sungm &#x3D; new Person(&quot;sungm&quot;, effectiveJava);</span><br><span class="line">        Person sunhw &#x3D; (Person) sungm.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;对象 sungm 的信息：&quot; + sungm);</span><br><span class="line">        System.out.println(&quot;对象 sunhw 的信息：&quot; + sunhw);</span><br><span class="line">        System.out.println(&quot;对象 sungm 与对象 sunhw 是否相等：&quot; + (sungm &#x3D;&#x3D; sunhw));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;改变对象 sunhw 的 book 属性</span><br><span class="line">        sunhw.getBook().setBookName(&quot;Vue.js&quot;);</span><br><span class="line">        sunhw.getBook().setAuthor(&quot;尤雨溪&quot;);</span><br><span class="line">        System.out.println(&quot;对象 sunhw 的信息：&quot; + sunhw);</span><br><span class="line">        System.out.println(&quot;对象 sungm 的信息：&quot; + sungm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 输出结果 *&#x2F;</span><br><span class="line">对象 sungm 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Effective Java&#39;, author&#x3D;&#39;Joshua Bloch&#39;&#125;&#125;</span><br><span class="line">对象 sunhw 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Effective Java&#39;, author&#x3D;&#39;Joshua Bloch&#39;&#125;&#125;</span><br><span class="line">对象 sungm 与对象 sunhw 是否相等：false</span><br><span class="line">-----------------------------------------</span><br><span class="line">对象 sunhw 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Vue.js&#39;, author&#x3D;&#39;尤雨溪&#39;&#125;&#125;</span><br><span class="line">对象 sungm 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Vue.js&#39;, author&#x3D;&#39;尤雨溪&#39;&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从输出结果可以看出：对象 sunhw 改变了的属性 book 的内容， 对对象 sungm 造成了影响。因为两个对象的 book 属性保存的是同一个引用，造成这种差异是由于对象进行了浅拷贝。</p>
</blockquote>
<p>进行深拷贝示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略 constructor 、 getter 、 setter 方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person person &#x3D; (Person) super.clone();</span><br><span class="line">        person.book &#x3D; (Book) book.clone();</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, book&#x3D;&quot; + book +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    private String bookName;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略 constructor 、 getter 、 setter 方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Book effectiveJava &#x3D; new Book(&quot;Effective Java&quot;, &quot;Joshua Bloch&quot;);</span><br><span class="line">        Person sungm &#x3D; new Person(&quot;sungm&quot;, effectiveJava);</span><br><span class="line">        Person sunhw &#x3D; (Person) sungm.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;对象 sungm 的信息：&quot; + sungm);</span><br><span class="line">        System.out.println(&quot;对象 sunhw 的信息：&quot; + sunhw);</span><br><span class="line">        System.out.println(&quot;对象 sungm 与对象 sunhw 是否相等：&quot; + (sungm &#x3D;&#x3D; sunhw));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;改变对象 sunhw 的 book 属性</span><br><span class="line">        sunhw.getBook().setBookName(&quot;Vue.js&quot;);</span><br><span class="line">        sunhw.getBook().setAuthor(&quot;尤雨溪&quot;);</span><br><span class="line">        System.out.println(&quot;对象 sunhw 的信息：&quot; + sunhw);</span><br><span class="line">        System.out.println(&quot;对象 sungm 的信息：&quot; + sungm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*运行结果*&#x2F;</span><br><span class="line">对象 sungm 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Effective Java&#39;, author&#x3D;&#39;Joshua Bloch&#39;&#125;&#125;</span><br><span class="line">对象 sunhw 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Effective Java&#39;, author&#x3D;&#39;Joshua Bloch&#39;&#125;&#125;</span><br><span class="line">对象 sungm 与对象 sunhw 是否相等：false </span><br><span class="line">-----------------------------------------</span><br><span class="line">对象 sunhw 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Vue.js&#39;, author&#x3D;&#39;尤雨溪&#39;&#125;&#125;</span><br><span class="line">对象 sungm 的信息：Person&#123;name&#x3D;&#39;sungm&#39;, book&#x3D;Book&#123;bookName&#x3D;&#39;Effective Java&#39;, author&#x3D;&#39;Joshua Bloch&#39;&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：进行深拷贝一般有2中方式<br>（1）将属性对象实现 java.lang.Cloneable 接口并重写 clone 方法，然后在原始类中修改 clone方法。<br>（2）实现 java.io.Serializable 接口，通过序列化和反序列号拷贝对象。</p>
</blockquote>
<h2 id="2-hashCode-方法"><a href="#2-hashCode-方法" class="headerlink" title="2. hashCode 方法"></a>2. hashCode 方法</h2><blockquote>
<p>返回对象的 Hash 值 （也称散列码）。对象的散列码是为了更好的支持基于哈希机制的 Java 集合类，例如：HashMap、HashSet、HashTable。</p>
</blockquote>
<h3 id="2-1-通用约定"><a href="#2-1-通用约定" class="headerlink" title="2.1 通用约定"></a>2.1 通用约定</h3><blockquote>
<p>（1）在 Java 程序执行期间，多次调用该方法应该返回相同的值，前提是未修改在 equals 方法中使用的信息。<br>（2）如果 2 个对象通过 equals 方法判定为 2 个对象相等、那么他们返回的 Hash 值也应该相等。<br>（3）对于 2 个对象来说，如果使用 equals 方法返回 false，那么这两个对象的 hashCode 值不要求一定不同（可以相同，可以不同），但是如果不同则可以提高应用的性能。<br>（4）对于 Object 类来说，不同 Object 对象的 hash 值是不同的、其 hash 值返回的是内存地址。</p>
</blockquote>
<blockquote>
<p><strong>说明：鉴于第 （2） 条约定，如果重写了 equals 方法，那就要求重写 hashCode 方法。</strong></p>
</blockquote>
<h2 id="3-equals-方法"><a href="#3-equals-方法" class="headerlink" title="3. equals 方法"></a>3. equals 方法</h2><blockquote>
<p>判断两个对象是否相等。仅当两个对象引用的是同一个内存地址，即同一个对象，该方法返回 true。若不满足指向同一个内存地址、即使两个对象的内容相同，也会返回 false。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj); &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>规则：<br>（1）自反性：对于任意非空对象， x.equals(x) 应该返回 true<br>（2）对称性：对于任意非空对象，若 x.equals(y) 返回 true，则 y.equals(x) 也应该返回 true<br>（3）传递性：对于任意非空对象，若 x.equals(y) 返回 true、y.equals(z) 也返回 true ，则 x.equals(z) 也应该返回 true<br>（4）一致性：若 x.equals(y) 返回 true，那第二次、第三次调用也应该返回 true，前提是未修改两个对象。</p>
</blockquote>
<h2 id="4-toString-方法"><a href="#4-toString-方法" class="headerlink" title="4. toString 方法"></a>4. toString 方法</h2><blockquote>
<p>返回对象的字符串表现形式（类全名及无符号十六进制的 Hash 值）。API 建议所有的子类都重写该方法。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-finalize-方法"><a href="#5-finalize-方法" class="headerlink" title="5. finalize 方法"></a>5. finalize 方法</h2><blockquote>
<p>该方法自 Java 9 之后被废弃。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Deprecated(since&#x3D;&quot;9&quot;) protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：该方法并非一两句话能解释清楚，这里引入一篇博客、可供参考学习。<a href="https://www.jianshu.com/p/9d2788fffd5f" target="_blank" rel="noopener">https://www.jianshu.com/p/9d2788fffd5f</a></p>
</blockquote>
<h2 id="6-getClass-方法"><a href="#6-getClass-方法" class="headerlink" title="6. getClass 方法"></a>6. getClass 方法</h2><blockquote>
<p>返回运行时该对象的 class 对象，返回的 class 对象是被表示对象的类的 static synchronized 方法锁定的对象。</p>
</blockquote>
<blockquote>
<p>该方法一般常见于反射技术。</p>
</blockquote>
<h2 id="7-wait-方法"><a href="#7-wait-方法" class="headerlink" title="7. wait 方法"></a>7. wait 方法</h2><blockquote>
<p>导致当前线程等待，可设置等待的毫秒数，知道其他线程调用 notify 方法或者调用该对象的 notifyAll 方法唤醒该线程。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeoutMillis) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<h2 id="8-notify-方法"><a href="#8-notify-方法" class="headerlink" title="8. notify 方法"></a>8. notify 方法</h2><blockquote>
<p>唤醒正在此对象的监听器上等待的单个线程。如果该对象的监听器等待的线程存在多个、则唤醒其中一个线程，该线程的唤醒是随机的。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate public final native void notify();</span><br></pre></td></tr></table></figure>
<h2 id="9-notifyAll-方法"><a href="#9-notifyAll-方法" class="headerlink" title="9. notifyAll 方法"></a>9. notifyAll 方法</h2><blockquote>
<p>唤醒正在此对象的监听器上等待的所有线程。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate public final native void notifyAll();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java.nio.Buffer 类详解</title>
    <url>/2020/06/13/java-nio-Buffer-%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h2><hr>
<a id="more"></a>

<p>#####属性</p>
<ul>
<li>capacity（容量）</li>
<li>limit （限制）</li>
<li>position （位置）</li>
<li>mark （标记）</li>
</ul>
<blockquote>
<p>mark &lt;= position &lt;= limit &lt;= capacity</p>
</blockquote>
<p>#####源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</span><br><span class="line">   private int mark &#x3D; -1;</span><br><span class="line">   private int position &#x3D; 0;</span><br><span class="line">   private int limit;</span><br><span class="line">   private int capacity</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明 :</p>
<ol>
<li>capacity 代表包含元素的数量，即容量</li>
<li>limit 代表缓冲区中的限制第一个不应该读取或者写入元素的index</li>
<li>position 代表下一个要读取或者要写入元素的index</li>
<li>mark 设置标记，标记当前position的位置，配合reset() 方法重置上次标记的position位置。</li>
</ol>
</blockquote>
<hr>
<h2 id="2-非抽象方法"><a href="#2-非抽象方法" class="headerlink" title="2.非抽象方法"></a>2.非抽象方法</h2><hr>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Creates a new buffer with the given mark, position, limit, and capacity,</span><br><span class="line">&#x2F;&#x2F; after checking invariants.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">Buffer(int mark, int pos, int lim, int cap) &#123;       &#x2F;&#x2F; package-private</span><br><span class="line">    if (cap &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Negative capacity: &quot; + cap);</span><br><span class="line">    this.capacity &#x3D; cap;</span><br><span class="line">    limit(lim);</span><br><span class="line">    position(pos);</span><br><span class="line">    if (mark &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (mark &gt; pos)</span><br><span class="line">            throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;</span><br><span class="line">                                               + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);</span><br><span class="line">        this.mark &#x3D; mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>创建出一个带有mark, position, limit, and capacity属性的Buffer，该方法包内可见。</li>
<li>判断capacity 属性是否小于0，若小于 0 则抛出非法参数异常。</li>
</ul>
</blockquote>
<h5 id="获取容量（capacity）"><a href="#获取容量（capacity）" class="headerlink" title="获取容量（capacity）"></a>获取容量（capacity）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns this buffer&#39;s capacity.</span><br><span class="line"> *</span><br><span class="line"> * @return  The capacity of this buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int capacity() &#123;</span><br><span class="line">    return capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>返回 capacity 值。</li>
</ul>
</blockquote>
<h5 id="获取位置（position）"><a href="#获取位置（position）" class="headerlink" title="获取位置（position）"></a>获取位置（position）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns this buffer&#39;s position.</span><br><span class="line"> *</span><br><span class="line"> * @return  The position of this buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int position() &#123;</span><br><span class="line">    return position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>返回 position 值。</li>
</ul>
</blockquote>
<h5 id="设置位置（position）"><a href="#设置位置（position）" class="headerlink" title="设置位置（position）"></a>设置位置（position）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Sets this buffer&#39;s position.  If the mark is defined and larger than the</span><br><span class="line"> * new position then it is discarded.</span><br><span class="line"> *</span><br><span class="line"> * @param  newPosition</span><br><span class="line"> *         The new position value; must be non-negative</span><br><span class="line"> *         and no larger than the current limit</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          If the preconditions on &lt;tt&gt;newPosition&lt;&#x2F;tt&gt; do not hold</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer position(int newPosition) &#123;</span><br><span class="line">    if ((newPosition &gt; limit) || (newPosition &lt; 0))</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    position &#x3D; newPosition;</span><br><span class="line">    if (mark &gt; position) mark &#x3D; -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>设置 position 值。</li>
<li>传入的新 position 值若大于limit（限制） 或小于 0，抛出非法参数异常。</li>
<li>若 mark (标记) 大于赋值后的 position 值，则弃用标志（mark =  -1）。</li>
</ul>
</blockquote>
<h5 id="获取限制（limit）"><a href="#获取限制（limit）" class="headerlink" title="获取限制（limit）"></a>获取限制（limit）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns this buffer&#39;s limit.</span><br><span class="line"> *</span><br><span class="line"> * @return  The limit of this buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int limit() &#123;</span><br><span class="line">    return limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>返回 limit 值。</li>
</ul>
</blockquote>
<h5 id="设置限制（limit）"><a href="#设置限制（limit）" class="headerlink" title="设置限制（limit）"></a>设置限制（limit）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Sets this buffer&#39;s limit.  If the position is larger than the new limit</span><br><span class="line"> * then it is set to the new limit.  If the mark is defined and larger than</span><br><span class="line"> * the new limit then it is discarded.</span><br><span class="line"> *</span><br><span class="line"> * @param  newLimit</span><br><span class="line"> *         The new limit value; must be non-negative</span><br><span class="line"> *         and no larger than this buffer&#39;s capacity</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          If the preconditions on &lt;tt&gt;newLimit&lt;&#x2F;tt&gt; do not hold</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer limit(int newLimit) &#123;</span><br><span class="line">    if ((newLimit &gt; capacity) || (newLimit &lt; 0))</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    limit &#x3D; newLimit;</span><br><span class="line">    if (position &gt; limit) position &#x3D; limit;</span><br><span class="line">    if (mark &gt; limit) mark &#x3D; -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>设置 limit 值。</li>
<li>传入的新 limit 值若大于 capacity 或者 小于 0 ，则抛出非法参数异常</li>
<li>若 position 大于 limit，则 position 值设置为 limit的值</li>
<li>若 mark 大于 limit，则废除 mark</li>
</ul>
</blockquote>
<h5 id="设置标记（mark）"><a href="#设置标记（mark）" class="headerlink" title="设置标记（mark）"></a>设置标记（mark）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Sets this buffer&#39;s mark at its position.</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer mark() &#123;</span><br><span class="line">    mark &#x3D; position;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>设置标记的值为 position，相当于记录position的值，在使用reset() 方法时重置 position值。</li>
</ul>
</blockquote>
<h5 id="reset-重置方法"><a href="#reset-重置方法" class="headerlink" title="reset() 重置方法"></a>reset() 重置方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Resets this buffer&#39;s position to the previously-marked position.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Invoking this method neither changes nor discards the mark&#39;s</span><br><span class="line"> * value. &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  InvalidMarkException</span><br><span class="line"> *          If the mark has not been set</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer reset() &#123;</span><br><span class="line">    int m &#x3D; mark;</span><br><span class="line">    if (m &lt; 0)</span><br><span class="line">        throw new InvalidMarkException();</span><br><span class="line">    position &#x3D; m;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此方法只有在标记有效的情况下才能使用，即 mrak 不小于 0</li>
<li>重置 position 的值，即将 mark 的值赋值给 position</li>
</ul>
</blockquote>
<h5 id="clear-清除方法"><a href="#clear-清除方法" class="headerlink" title="clear() 清除方法"></a>clear() 清除方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Clears this buffer.  The position is set to zero, the limit is set to</span><br><span class="line"> * the capacity, and the mark is discarded.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span><br><span class="line"> * &lt;i&gt;put&lt;&#x2F;i&gt; operations to fill this buffer.  For example:</span><br><span class="line"> *</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * buf.clear();     &#x2F;&#x2F; Prepare buffer for reading</span><br><span class="line"> * in.read(buf);    &#x2F;&#x2F; Read data&lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span><br><span class="line"> * is named as if it did because it will most often be used in situations</span><br><span class="line"> * in which that might as well be the case. &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer clear() &#123;</span><br><span class="line">    position &#x3D; 0;</span><br><span class="line">    limit &#x3D; capacity;</span><br><span class="line">    mark &#x3D; -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>清除Buffer的属性值，即 position = 0，limit = capacity，mark = -1</li>
</ul>
</blockquote>
<h5 id="flip-翻转方法"><a href="#flip-翻转方法" class="headerlink" title="flip() 翻转方法"></a>flip() 翻转方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Flips this buffer.  The limit is set to the current position and then</span><br><span class="line">  * the position is set to zero.  If the mark is defined then it is</span><br><span class="line">  * discarded.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;&#x2F;i&gt; operations, invoke</span><br><span class="line">  * this method to prepare for a sequence of channel-write or relative</span><br><span class="line">  * &lt;i&gt;get&lt;&#x2F;i&gt; operations.  For example:</span><br><span class="line">  *</span><br><span class="line">  * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">  * buf.put(magic);    &#x2F;&#x2F; Prepend header</span><br><span class="line">  * in.read(buf);      &#x2F;&#x2F; Read data into rest of buffer</span><br><span class="line">  * buf.flip();        &#x2F;&#x2F; Flip buffer</span><br><span class="line">  * out.write(buf);    &#x2F;&#x2F; Write header + data to channel&lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt; This method is often used in conjunction with the &#123;@link</span><br><span class="line">  * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span><br><span class="line">  * one place to another.  &lt;&#x2F;p&gt;</span><br><span class="line">  *</span><br><span class="line">  * @return  This buffer</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public final Buffer flip() &#123;</span><br><span class="line">     limit &#x3D; position;</span><br><span class="line">     position &#x3D; 0;</span><br><span class="line">     mark &#x3D; -1;</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>反转Buffer，反向操作Buffer。</li>
<li>将 position 值赋值给 limit，在设置 position 值为 0 ，废除标记。</li>
</ul>
</blockquote>
<h5 id="rewind-回退方法"><a href="#rewind-回退方法" class="headerlink" title="rewind() 回退方法"></a>rewind() 回退方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Rewinds this buffer.  The position is set to zero and the mark is</span><br><span class="line"> * discarded.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;&#x2F;i&gt;</span><br><span class="line"> * operations, assuming that the limit has already been set</span><br><span class="line"> * appropriately.  For example:</span><br><span class="line"> *</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * out.write(buf);    &#x2F;&#x2F; Write remaining data</span><br><span class="line"> * buf.rewind();      &#x2F;&#x2F; Rewind buffer</span><br><span class="line"> * buf.get(array);    &#x2F;&#x2F; Copy data into array&lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  This buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final Buffer rewind() &#123;</span><br><span class="line">    position &#x3D; 0;</span><br><span class="line">    mark &#x3D; -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>回退Buffer，重新操作Buffer。</li>
<li>设置 position 值为 0 ，废除标记。</li>
</ul>
</blockquote>
<h5 id="remaining-剩余"><a href="#remaining-剩余" class="headerlink" title="remaining() 剩余"></a>remaining() 剩余</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the number of elements between the current position and the</span><br><span class="line"> * limit.</span><br><span class="line"> *</span><br><span class="line"> * @return  The number of elements remaining in this buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int remaining() &#123;</span><br><span class="line">    return limit - position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>返回剩余元素个数：limit - position</li>
</ul>
</blockquote>
<h5 id="hasRemaining-是否有剩余元素"><a href="#hasRemaining-是否有剩余元素" class="headerlink" title="hasRemaining() 是否有剩余元素"></a>hasRemaining() 是否有剩余元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tells whether there are any elements between the current position and</span><br><span class="line"> * the limit.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;tt&gt;true&lt;&#x2F;tt&gt; if, and only if, there is at least one element</span><br><span class="line"> *          remaining in this buffer</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final boolean hasRemaining() &#123;</span><br><span class="line">    return position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>判断Buffer是否有剩余元素</li>
</ul>
</blockquote>
<hr>
<h2 id="3-抽象方法"><a href="#3-抽象方法" class="headerlink" title="3.抽象方法"></a>3.抽象方法</h2><hr>
<h5 id="isReadOnly-是否只读"><a href="#isReadOnly-是否只读" class="headerlink" title="isReadOnly() 是否只读"></a>isReadOnly() 是否只读</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tells whether or not this buffer is read-only.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;tt&gt;true&lt;&#x2F;tt&gt; if, and only if, this buffer is read-only</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract boolean isReadOnly();</span><br></pre></td></tr></table></figure>

<h5 id="hasArray-是否包含数组"><a href="#hasArray-是否包含数组" class="headerlink" title="hasArray() 是否包含数组"></a>hasArray() 是否包含数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tells whether or not this buffer is read-only.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;tt&gt;true&lt;&#x2F;tt&gt; if, and only if, this buffer is read-only</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract boolean isReadOnly();</span><br></pre></td></tr></table></figure>

<h5 id="array-获取数组"><a href="#array-获取数组" class="headerlink" title="array() 获取数组"></a>array() 获取数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the array that backs this</span><br><span class="line"> * buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;&#x2F;i&gt;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; This method is intended to allow array-backed buffers to be</span><br><span class="line"> * passed to native code more efficiently. Concrete subclasses</span><br><span class="line"> * provide more strongly-typed return values for this method.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Modifications to this buffer&#39;s content will cause the returned</span><br><span class="line"> * array&#39;s content to be modified, and vice versa.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Invoke the &#123;@link #hasArray hasArray&#125; method before invoking this</span><br><span class="line"> * method in order to ensure that this buffer has an accessible backing</span><br><span class="line"> * array.  &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  The array that backs this buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  ReadOnlyBufferException</span><br><span class="line"> *          If this buffer is backed by an array but is read-only</span><br><span class="line"> *</span><br><span class="line"> * @throws  UnsupportedOperationException</span><br><span class="line"> *          If this buffer is not backed by an accessible array</span><br><span class="line"> *</span><br><span class="line"> * @since 1.6</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract Object array();</span><br></pre></td></tr></table></figure>


<h5 id="arrayOffset-获取数组偏移量"><a href="#arrayOffset-获取数组偏移量" class="headerlink" title="arrayOffset() 获取数组偏移量"></a>arrayOffset() 获取数组偏移量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns the offset within this buffer&#39;s backing array of the first</span><br><span class="line"> * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;&#x2F;i&gt;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; If this buffer is backed by an array then buffer position &lt;i&gt;p&lt;&#x2F;i&gt;</span><br><span class="line"> * corresponds to array index &lt;i&gt;p&lt;&#x2F;i&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;arrayOffset()&lt;&#x2F;tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; Invoke the &#123;@link #hasArray hasArray&#125; method before invoking this</span><br><span class="line"> * method in order to ensure that this buffer has an accessible backing</span><br><span class="line"> * array.  &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  The offset within this buffer&#39;s array</span><br><span class="line"> *          of the first element of the buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  ReadOnlyBufferException</span><br><span class="line"> *          If this buffer is backed by an array but is read-only</span><br><span class="line"> *</span><br><span class="line"> * @throws  UnsupportedOperationException</span><br><span class="line"> *          If this buffer is not backed by an accessible array</span><br><span class="line"> *</span><br><span class="line"> * @since 1.6</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract int arrayOffset();</span><br></pre></td></tr></table></figure>


<h5 id="isDirect-是否直接缓冲区"><a href="#isDirect-是否直接缓冲区" class="headerlink" title="isDirect() 是否直接缓冲区"></a>isDirect() 是否直接缓冲区</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Tells whether or not this buffer is</span><br><span class="line"> * &lt;a href&#x3D;&quot;ByteBuffer.html#direct&quot;&gt;&lt;i&gt;direct&lt;&#x2F;i&gt;&lt;&#x2F;a&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @return  &lt;tt&gt;true&lt;&#x2F;tt&gt; if, and only if, this buffer is direct</span><br><span class="line"> *</span><br><span class="line"> * @since 1.6</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract boolean isDirect();</span><br></pre></td></tr></table></figure>

<hr>
<p>#####推荐书籍：</p>
<ul>
<li>[高洪岩]《Java多线程编程核心技术》</li>
<li>[高洪岩]《Java并发编程：核心方法与框架》</li>
<li>[高洪岩]《NIO与Socket编程技术指南》</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 12. synchronized关键字</title>
    <url>/2020/08/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="1-synchronized-同步机制"><a href="#1-synchronized-同步机制" class="headerlink" title="1. synchronized 同步机制"></a>1. synchronized 同步机制</h3><p>synchronized 同步机制是 Java 第一个多线程同步访问共享对象（数据）的机制。显然刚开始的时候Java 同步机制不是很好，因此在 jdk 1.5 提出了一些并发工具类帮助开发者实现比synchronized同步机制更好的并发控制。随着 jdk 版本的不断更新发布，synchronized 关键的性能已经做了很多的优化，在多数情况下，使用 synchronized 关键字能够满足并发控制。</p>
<hr>
<h3 id="2-synchronized-关键字"><a href="#2-synchronized-关键字" class="headerlink" title="2. synchronized 关键字"></a>2. synchronized 关键字</h3><p>通过 synchronized 关键字标记 synchronized 代码块。Java 中 synchronized 代码块是在某个对象上做同步（这个对象我们称为锁），所有作用在某个对象的同步代码块同时只能被一个执行，其他线程尝试执行同步代码块时必须等待正在执行同步代码块的线程退出之后才能进入同步代码块。</p>
<p>synchronized 关键字三种用法：</p>
<ul>
<li>作用于实例方法（普通方法）</li>
<li>作用于静态方法</li>
<li>作用于代码块</li>
</ul>
<p>建议：在需要使用synchronized 关键字时，首先考虑作用于代码块，其次是普通方法，最后是静态方法（代码块 &gt; 普通方法 &gt; 静态方法）。</p>
<h5 id="2-1-作用于普通方法"><a href="#2-1-作用于普通方法" class="headerlink" title="2.1 作用于普通方法"></a>2.1 作用于普通方法</h5><p>通过使用 synchronized 关键字声明一个同步的普通方法。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyCounter &#123;</span><br><span class="line"></span><br><span class="line">  private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public synchronized void add(int value)&#123;</span><br><span class="line">      this.count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中通过使用  声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p>
<p><strong>synchronized 同步实例方法：给当前实例对象加锁，当某个线程进入执行synchronized实例方法时需要获取当前实例对象的锁。因此当synchronized作用于普通方法时，每个实例的同步方法只作用于自己的实例对象。</strong></p>
<p><strong>只有一个线程可以执行实例同步方法。如果存在多个线程，那么只有一个线程能够同时执行实例同步方法，其他线程必须等待正在执行同步方法的线程执行完毕同步方法，获取到实例锁之后才能执行同步方法。</strong></p>
<h5 id="2-2-作用于静态方法"><a href="#2-2-作用于静态方法" class="headerlink" title="2.2 作用于静态方法"></a>2.2 作用于静态方法</h5><p>通过使用 synchronized 关键字声明一个同步的静态方法，与普通方法不同的是，静态方法需要通过 static 关键字声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">      count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中通过使用 synchronized 声明 add() 方法，告诉 JVM 这个 add() 方法是同步的。</p>
<p><strong>synchronized 同步静态方法：给当前类的 class 对象加锁，当某个线程进入synchronized静态方法时需要获取当前类的class对象的锁。</strong></p>
<p><strong>因为JVM中每个类只有一个class对象，因此只有一个线程能够同时执行静态同步方法。</strong></p>
<p>如果一个类声明了多个静态同步方法，只有一个线程可以同时执行这些方法。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static MyStaticCounter&#123;</span><br><span class="line"></span><br><span class="line">  private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public static synchronized void add(int value)&#123;</span><br><span class="line">    count +&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static synchronized void subtract(int value)&#123;</span><br><span class="line">    count -&#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于静态同步方法的锁作用于当前类的class对象，所以当多个线程需要执行同一个类中声明的不同的静态同步方法时，同一时间只有一个线程能拿到类的class对象锁，因此只有一个线程能在给定的时间内执行某个静态方法。</p>
<p>上例中声明了2个静态同步方法，分别是add()方法和subtract()方法，当某个线程执行add()方法时，其他线程只能等待正在执行add()方法执行完毕，并释放类的class对象锁后，才能获取到锁并执行对应的静态同步方法。</p>
<h5 id="2-3-作用于代码块"><a href="#2-3-作用于代码块" class="headerlink" title="2.3 作用于代码块"></a>2.3 作用于代码块</h5><p>通常情况下，我们不需要同步整个方法，可以在方法内部声明同步代码块，当多个线程执行到同步代码时，使线程的变得同步执行。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized (object) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：object 表示接收某个对象作为锁，可以是任意对象，也可以是class对象。</strong> </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void add(int value)&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">       this.count +&#x3D; value;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上例中通过使用synchronized标记这段代码块是同步的，当多个线程需要执行这段代码时，线程会变得同步执行。</p>
<p>synchronized代码块接收一个对象作为同步锁，只有获取到同步锁才能执行同步代码，这个对象可以是我们自定义的任意对象，包括class对象。通常包括下面三种情况：</p>
<blockquote>
<ul>
<li>this 对象</li>
<li>class 对象</li>
<li>其他自定义对象</li>
</ul>
</blockquote>
<h6 id="2-3-1-this对象作为synchronized同步代码块的锁"><a href="#2-3-1-this对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.1 this对象作为synchronized同步代码块的锁"></a>2.3.1 this对象作为synchronized同步代码块的锁</h6><p>当以this对象（表示当前实例对象）作为同步代码块的锁时，只有获取到当前实例对象锁的线程才能执行相应的同步代码。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中：如果某个线程正在执行log2()方法中的同步代码块，那么会阻塞其他线程执行log1()方法和log2()方法中的同步代码块（log1方法是普通同步方法，也是以当前实例对象作为锁）。</p>
<p>以this为对象锁的同步代码块，和普通同步方法的锁对象相同，都是某个实例对象作为同步锁。这种情况下，我们要考虑多线程竞争锁对象时造成的不必要的损耗。</p>
<h6 id="2-3-2-class对象作为synchronized同步代码块的锁"><a href="#2-3-2-class对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 class对象作为synchronized同步代码块的锁"></a>2.3.2 class对象作为synchronized同步代码块的锁</h6><p>当以class对象作为同步代码块的锁时，只有获取到class对象锁的线程才能执行相应的同步代码。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static synchronized void log1(String msg1, String msg2) &#123;</span><br><span class="line">         log.writeln(msg1);</span><br><span class="line">           log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (MyClass.class) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中：当某个线程正在执行log1()方法中的同步代码块或者log2()方法时，会阻塞其他线程执行这两个方法中的任意一个方法。</p>
<p>以class为对象锁的同步代码块，和静态同步方法的锁对象相同，都是某个类的class对象作为同步锁。这种情况下，我们也要考虑多线程竞争锁对象时造成的不必要的损耗。</p>
<h6 id="2-3-2-其他对象作为synchronized同步代码块的锁"><a href="#2-3-2-其他对象作为synchronized同步代码块的锁" class="headerlink" title="2.3.2 其他对象作为synchronized同步代码块的锁"></a>2.3.2 其他对象作为synchronized同步代码块的锁</h6><p>可以指定任意对象作为同步代码块的对象锁，通常情况下我们使用共享资源对象作为指定的对象锁。备注：如果存在多个共享资源，那么一定要注意锁的顺序，有效防止死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    private String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">         synchronized (lock) &#123;</span><br><span class="line">            log.writeln(msg1);</span><br><span class="line">            log.writeln(msg2);  </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以任意自定义对象作为锁时，似乎要比以this对象和class对象作为synchronized同步锁要灵活的多，不过也要根据场景来使用不同的对象作为同步锁。</p>
<h6 id="2-3-3-Lambda-表达式中的同步代码块"><a href="#2-3-3-Lambda-表达式中的同步代码块" class="headerlink" title="2.3.3 Lambda 表达式中的同步代码块"></a>2.3.3 Lambda 表达式中的同步代码块</h6><p>我们可以在Lambda表达式中声明synchronized同步代码块，其使用方式跟我们上面提到的知识点是一样的。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lock &#x3D; &quot;lock&quot;;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; s -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F;do something...</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-synchronized-数据可见性"><a href="#3-synchronized-数据可见性" class="headerlink" title="3. synchronized 数据可见性"></a>3. synchronized 数据可见性</h3><p>上一篇博客我们讲<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">《Java Happens Before Guarantee》</a> 时提到过 volatile 关键字和 synchronize 关键字的数据可见性保证。</p>
<p>这里我们简单回忆一下：没有使用 volatile 关键字或 synchronized 关键字时，当某个线程改变了共享资源的值时对其他线程不可见，原因是不会保证存储于CPU寄存器或者CPU高速缓存的数据重新写回主内存中。</p>
<p>synchronized 数据可见性：<strong>通过使用synchronized关键字声明同步方法或者同步代码块时，某个线程进入synchronized代码块时，会从主内存中读取最新的数据保存至CPU高速缓存或者CPU寄存器中；当某个线程退出synchronized代码块时，会将CPU寄存器中最新的数据刷回到CPU高速缓存中，再将CPU高速缓存中的最新数据刷新到主内存中，以此保证数据可见性。</strong></p>
<hr>
<h3 id="4-synchronized-和指令重排"><a href="#4-synchronized-和指令重排" class="headerlink" title="4. synchronized 和指令重排"></a>4. synchronized 和指令重排</h3><p>上一篇博客中提到过： synchronized 在一定程度上限制了指令重排。</p>
<p>JVM 和 CPU 为了让程序更快的执行，允许指令重排，通过指令重排让指令并行执行。（前提条件是并行执行的指令没有依赖关系，也就是重排的指令之间不存在依赖关系）</p>
<p>指令重排在多线程中可能会产生一些问题，比如synchronized同步代码块中写一个变量的代码被重排到synchronized外面。为了防止这种问题产生，synchronized 关键字限制了一些指令重排的发生（与volatile关键字限制指令重排相似）。</p>
<p>最终的结果是：你可以确定你的代码正确的工作 ———— synchronized限制了指令重排的发生。</p>
<hr>
<h3 id="5-什么对象用来做同步对象锁？"><a href="#5-什么对象用来做同步对象锁？" class="headerlink" title="5. 什么对象用来做同步对象锁？"></a>5. 什么对象用来做同步对象锁？</h3><p>正如我们前面多次提到的一样，synchronized 关键字必须作用于某个对象上做同步（通常情况下我们称这个对象为同步对象锁）。</p>
<p>你可以使用任意对象作为同步对象锁，但是不建议你使用某些String类型的对象和原始基本数据类型的包装类对象作为同步对象锁。因为编译器会优化它们，最终的结果是当你使用他们在不同的同步代码块中作为对象锁时，你以为你使用了不同的对象作为对象锁，实际上只使用了同一个对象作为对象锁。</p>
<p>出于安全考虑，使用 this 对象或者 new Object() 作为同步对象锁，这种情况下不会被Java编译器或JVM缓存。</p>
<hr>
<h3 id="6-synchronized-代码块的限制和替代品"><a href="#6-synchronized-代码块的限制和替代品" class="headerlink" title="6. synchronized 代码块的限制和替代品"></a>6. synchronized 代码块的限制和替代品</h3><p>Java 中的 synchronized代码块存在一些限制，比如同一时间只允许一个线程进入同步代码块。如果多个线程只读取共享数据，不更新共享数据，这是线程安全的，这种情况下我们可以使用 Read / Write Lock 代替 synchronized 代码块。</p>
<p>你想要多个线程进入同步代码块还是只是一个线程进入同步代码块？我们可以通过使用 Semaphore（计数信号量：限流的作用） 来实现指定数量的线程进入同步代码块(这个点说的同步代码块不是指synchronized代码块)，后面的博客我们来讲解这种实现方式。</p>
<p>synchronized代码块不会保证等待线程按顺序执行同步代码块。如果我们需要线程按顺序执行同步代码块，可以通过实现 Fairness（公平锁） 来达到这个目的。</p>
<p>如果只有一个线程修改共享变量，其他的线程只读取共享变量的值，我们可以使用 volatile 关键字，不需要任何同步代码块。</p>
<hr>
<h3 id="7-synchronized-性能消耗"><a href="#7-synchronized-性能消耗" class="headerlink" title="7. synchronized 性能消耗"></a>7. synchronized 性能消耗</h3><p>当线程进入和退出 synchronized 代码块时存在一些性能消耗。随着 JDK 版本的发布，性能的消耗变得越来越小，但是使用synchronized代码块还是不可避免地需要付出一些代价。</p>
<p>如果在循环内不断地进入和退出同步代码块，无疑会让放大性能的损耗。</p>
<p>尽量避免大的同步代码块，换句话说，只把真正需要的同步操作的代码放进同步代码块，避免其他线程执行不需要同步操作的代码时造成阻塞，同时也能提高执行代码的性能。</p>
<hr>
<h3 id="8-synchronized-锁重入"><a href="#8-synchronized-锁重入" class="headerlink" title="8. synchronized 锁重入"></a>8. synchronized 锁重入</h3><p>锁重入：当一个线程进入某个同步代码块时，线程持有同步代码块的同步锁，若同步代码块还调用了具有相同同步锁的同步代码块，线程不需要再次获取锁，可以直接进入相同同步锁的其他同步代码块。</p>
<p>synchronized 支持锁重入。</p>
<p>备注：设计多重同步代码块时，需要合理的设计，错误的实现容易导致死锁产生，保持同步代码的锁的顺序一致是一种设计方案。</p>
<hr>
<h3 id="9-集群中的-synchronized-代码块"><a href="#9-集群中的-synchronized-代码块" class="headerlink" title="9. 集群中的 synchronized 代码块"></a>9. 集群中的 synchronized 代码块</h3><p>请记住：synchronized 代码块只针对于同一个 JVM 中不同的线程能起到同步作用，如果你拥有相同的 Java 应用程序在多个 JVM 上面运行 ———— 集群，可能导致每个JVM都有一个线程在同时访问共享资源。 </p>
<p>如果你需要所有的JVM同步访问共享资源，可以使用其他的同步机制，而不是使用 synchronized 代码块。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 2. 使用多线程的成本</title>
    <url>/2020/08/09/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<p>从单线程应用程序到多线程应用程序不仅仅需要考虑多线程应用程序更加高效，我们还需要考虑使用多线程的成本。使用多线程技术时不要仅仅因为你会使用多线程技术，你应该有一个更好的想法，比如更好的处理线程安全问题，以及多线程使用成本。尽可能的去测试多线程应用程序的性能以及响应速度，而不是靠猜想。</p>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><blockquote>
<ul>
<li>更复杂的程序设计</li>
<li>上下文切换的开销</li>
</ul>
</blockquote>
<p><strong>更复杂的程序设计</strong> </p>
<blockquote>
<ul>
<li>在某些情况下，一个多线程应用程序比单线程应用程序更加简单，但是在某些特殊情况下要更加复杂。</li>
<li>在多个线程引用了同一个共享变量的情况下，多线程应用程序比单线程应用程序使用起来更加复杂，因为需要考虑线程安全问题，不正确的线程同步问题出现的问题往往防不胜防。</li>
</ul>
</blockquote>
<p><strong>上下文切换的开销</strong> </p>
<blockquote>
<ul>
<li>当一个CPU从当前线程切换的执行另外一个线程时，CPU需要保存当前线程的本地数据以及程序指针等等，再有另外一个线程切换到当前线程时，需要重新读取本地数据和程序指针等，这个交换的执行过程叫做上下文切换。</li>
<li>上下文切换的成本并不便宜。</li>
</ul>
</blockquote>
<p><strong>减少上下文切换</strong></p>
<blockquote>
<ul>
<li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁。</li>
<li>CAS算法：Java的atomic包使用CAS算法来更新数据，而不需要加锁。</li>
<li>使用最少线程：避免创建不需要的线程。</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 13. volatile关键字</title>
    <url>/2020/08/19/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volatile 关键字用来标记一个 Java 变量被保存至主内存中。更确切的说：每次读取 volatile 变量时会从主内存中读取，而不是从CPU高速缓存中读取；每次写 volatile 变量时会把数据写回主内存中，而不是CPU高速缓存中。</p>
<p>实际上，自 Java 5 起，volatile 关键字不仅仅保证从主内存中读取数据或者写回数据至主内存中。下面一起来探索下 volatile 关键字的作用吧。</p>
<h3 id="1-volatile-可见性问题"><a href="#1-volatile-可见性问题" class="headerlink" title="1. volatile 可见性问题"></a>1. volatile 可见性问题</h3><p>volatile 关键字保证了当某个线程改变了 volatile 变量的值时对其他线程可见。</p>
<p>在多线程应用系统中，线程操作 non-volatile 变量时，每个线程会拷贝 non-volatile 变量（拷贝引用）至CPU高速缓存中。如果你的计算机包含多个CPU，每个线程在不同的CPU上运行时，这就意味着每个线程拷贝这些变量至不同的CPU的CPU高速缓存中，如下图所示：</p>
<p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" alt></div></p>
<p>对于 non-volatile 变量，JVM每次读取变量数据时不会保证从主内存中拷贝至CPU高速缓存中，或者每次写数据时不会保证把CPU高速缓存的数据写回至主内存中。</p>
<p>下面我们来看个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，有2个线程，第一个线程对 count 的值做修改，第二个的线程能读取到 count 被修改后的值吗？？？</p>
<p>由于这个 count 变量没有被 volatile 关键字声明，当2个CPU运行的2个线程分别读取 count 的值时，会从主内存中将count的值拷贝至各自的CPU高速缓存中，其中一个线程修改count的值，由于它没有被volatile声明，因此不会保证被修改后的值写回至主内存中。请看下图：</p>
<p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" alt></div></p>
<p>由于count变量值被修改后没有写回主内存中，并且线程每次读取count变量值也没有保证从主内存中读取，这个问题被称为数据可见性问题，我们可以通过使用volatile关键字解决数据可见性问题，也可以使用其他方式解决。</p>
<hr>
<h3 id="2-volatile-可见性保证"><a href="#2-volatile-可见性保证" class="headerlink" title="2. volatile 可见性保证"></a>2. volatile 可见性保证</h3><p>volatile 关键字解决了数据可见性问题。通过使用 volatile 关键字声明变量是一个volatile变量，保证了每次读取变量数据时从主内存读取，写数据时把数据写回主内存中。</p>
<p>通过 volatile 声明变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShareObject &#123;</span><br><span class="line">    public volatile int count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到的这种情况，当线程一修改了count的值，线程二没有修改count的值，只读取了count的值，这种情况下，使用volatile关键字声明count变量足够保证数据的线程二读取到的是最新的数据。</p>
<p><strong>注意：当存在多个线程对同一个共享变量做修改操作时，使用volatile是远远不够的，volatile关键字只能保证数据可见性，并不能保证数据操作是原子性的，我们可以使用synchronized关键字或者Java提供的JUC工具包。</strong></p>
<h5 id="2-1-所有变量可见性保证"><a href="#2-1-所有变量可见性保证" class="headerlink" title="2.1 所有变量可见性保证"></a>2.1 所有变量可见性保证</h5><p>实际上，volatile 关键字的作用超越了 volatile 变量本身，有更多的作用。包括：</p>
<blockquote>
<ul>
<li>当某个线程写回volatile变量的值至主内存时，这个<strong>线程可见的所有变量的值</strong>都会写回至主内存中</li>
<li>当某个线程从主内存中读取volatile变量的值时，这个<strong>线程可见的所有变量的值</strong>都会重新从主内存中读取</li>
</ul>
</blockquote>
<p>上面提到的这些内容我们在博客<a href="https://miracle-sungm.github.io/2020/08/14/Guarantee/" target="_blank" rel="noopener">[Java 并发编程] 11. Java Happen Before Guarantee</a>提到过，这里不再举例证明。</p>
<hr>
<h3 id="3-指令重排挑战"><a href="#3-指令重排挑战" class="headerlink" title="3. 指令重排挑战"></a>3. 指令重排挑战</h3><p>JVM和CPU为了提升性能允许指令重排，只要满足语义不变（单线程情况下执行结果不变）即可指令重排。</p>
<p>请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure>

<p>指令重排后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line">int b &#x3D; 2;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure>

<p>然而，当一个变量被volatile修饰时，存在一些指令重排的挑战。请看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int years;</span><br><span class="line">    private int months</span><br><span class="line">    private volatile int days;</span><br><span class="line"></span><br><span class="line">    public void update(int years, int months, int days)&#123;</span><br><span class="line">        this.years  &#x3D; years;</span><br><span class="line">        this.months &#x3D; months;</span><br><span class="line">        this.days   &#x3D; days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦执行上面的update()方法，执行到修改days的指令时，years和months修改后的值也会被写回到主内存中。但是如果发生了指令重排，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void update(int years, int months, int days)&#123;</span><br><span class="line">    this.days   &#x3D; days;</span><br><span class="line">    this.years  &#x3D; years;</span><br><span class="line">    this.months &#x3D; months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样执行到days修改的指令时，years和months的值也会被写回到主内存中，但此时years和months的值未被修改（指令重排导致years和months修改的指令在days指令下面），写回数据至主内存的操作发生在years和months修改指令的前面，当执行完years和months的修改指令后，不会同步数据至主内存，因此years和months的新值对其他线程不可见（未使用volatile关键字），这样的指令重排导致程序的语义发生了改变。</p>
<p>Java 有解决这个问题，让我们看下一章节。</p>
<h3 id="4-volatile-happens-before-保证"><a href="#4-volatile-happens-before-保证" class="headerlink" title="4. volatile happens-before 保证"></a>4. volatile happens-before 保证</h3><p>为了解决指令重排可能产生的问题，java volatile 关键字除了提供可见性保证之外，还提供提供了happens-before保证，如下：</p>
<blockquote>
<ul>
<li>当其他变量的读写指令原本就在volatile写指令前面时，那么其他变量的读写指令不会被重排序到 volatile 写指令后面。（请注意：这里只提出了原本在volatile变量写指令前面的指令，不会被重排序到volatile指令后面，原本在volatile写指令前面的指令之间可以发生指令重排。）</li>
<li>当其他变量的读写指令原本就在volatile读指令后面时，那么其他变量的读写指令不会被重排序到 volatile 读指令前面。（同样：原本在 volatile 读指令后面的指令之间可以发生指令重排）</li>
</ul>
</blockquote>
<h3 id="5-volatile-不足"><a href="#5-volatile-不足" class="headerlink" title="5. volatile 不足"></a>5. volatile 不足</h3><p>即使 volatile 关键字保证了线程每次读取 volatile 变量时从主内存中读取数据，每次写数据时把数据写回主内存中，但在一些情况下，声明volatile变量是不够的。</p>
<p>上面我们提到过当一个线程修改volatile变量时，能保证其他线程可以读取到volatile变量的最新值。</p>
<p>事实上，在多个线程修改volatile变量的情况下，也能确保最新值被写回到主内存中。但这样可能会存在一些问题，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private volatile int totalPrice &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public int addPrice(int price) &#123;</span><br><span class="line">    totalPrice +&#x3D; price;</span><br><span class="line">    return totalPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initTotalPrice() &#123;</span><br><span class="line">    totalPrice &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程一、线程二分别在执行addPrice()方法和initTotalPrice()方法时，线程一执行完totalPrice += price指令后，把totalPrice的最新值刷回到主内存中，若此时线程二正巧执行完initTotalPrice()方法，totalPrice的值被重新刷回0，当线程一再读取totalPrice值并返回，导致最终返回的值是0，这可能不是我们程序最终想要的结果。（备注：当然我们不会去写这种程序代码，这个示例我只用来说明问题，并没有实际测试过这种场景。）</p>
<p>上例其实就是为了说明一个问题：<strong>volatile 只是保证了数据的可见性，并没有保证原子性，如果要执行原子性操作，使用volatile关键字是远远不够的。这里顺便提一下，synchronized关键字不仅保证了数据可见性，同时也保证了原子性。</strong></p>
<p>再来看下一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明volatile变量</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自增</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>
<p>当2个线程同时对变量 i 做自增操作，当他们同时把 i 的值写回到主内存中时，最终写回的值时1，实际上i做了2次自增。</p>
<p>因此：在多个线程同时存在修改共享数据的情况时，仅仅使用volatile变量是不够的。请记住：volatile 关键字只保证了数据可见性，并不保证原子性。</p>
<h3 id="6-什么时候使用-volatile"><a href="#6-什么时候使用-volatile" class="headerlink" title="6. 什么时候使用 volatile ?"></a>6. 什么时候使用 volatile ?</h3><p>正如前面提到的，如果多个线程同时对共享数据进行读写操作，这种情况下使用volatile关键字是不够的。我们需要使用synchronized关键字保证数据读写的可见性和原子性。</p>
<p>除了使用synchronized关键字之外，我们还可以使用 java.util.concurrent 包提供的各种工具类，比如 AtomicLong 、 AtomicReference 等等。</p>
<p>当只有一个线程会对共享变量的值进行修改，其他的线程只读取共享变量的值时，我们使用volatile关键字是足够的。</p>
<p>另外: volatile 关键字工作在32位或者64位的变量上。</p>
<h3 id="7-volatile-性能考虑"><a href="#7-volatile-性能考虑" class="headerlink" title="7. volatile 性能考虑"></a>7. volatile 性能考虑</h3><p>我们都知道，CPU操作CPU高速缓存的速度远远快于操作主内存的速度。CPU每次操作volatile关键字都会操作主内存会带来额外的性能开销。另外，volatile 关键字防止指令重排是正常性能增强技术。在条件允许的情况下，使用volatile关键字代替synchronized代码块能节省性能开销。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>做有意义的命名</title>
    <url>/2020/06/13/%E5%81%9A%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>软件中随处可见命名。我们给变量、函数、参数、类和封包命名。我们给源代码及源码所在的目录命名。我们给 jar 文件、 war 文件 和 ear 文件命名。有很多命名要做、不妨做好它。下面列出几条简单规则。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1. 名副其实"></a>1. 名副其实</h2><blockquote>
<p>变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做了什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。</p>
</blockquote>
<hr>
<h2 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2. 避免误导"></a>2. 避免误导</h2><blockquote>
<ol>
<li><strong>避免留下掩藏代码本意的错误线索。</strong><br>例如：使用某些专有名词作为变量名，使用缩写。</li>
<li><strong>避免使用与本意相悖的词</strong><br>例如：<br>String[] accountList = new String[10];  accountList 实质是一个数组对象，命名后缀为<br>List产生误导作用。</li>
<li><strong>避免使用外形相似的命名</strong><br>例如：两个变量</li>
<li><strong>避免使用小写字母 l 与 大写字母 O 作为变量名，跟数组1 和数字 0 难以区分。</strong></li>
</ol>
</blockquote>
<hr>
<h2 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3. 做有意义的区分"></a>3. 做有意义的区分</h2><blockquote>
<p>如果只是为了满足编译器或解释器的需要而写代码，肯定会制造麻烦。</p>
</blockquote>
<blockquote>
<p>#####错误示例：<br><strong>1. 添加数字系列，这样的名称纯属误导。</strong></p>
<ul>
<li>例如：<br>定义两个学生对象<br>Student student1 = new Student();<br>Student student2 = new Student();</li>
</ul>
<p><strong>2. 少使用废话，废话都是冗余。要区分名称，要以读者能鉴别之处来区分。</strong></p>
<ul>
<li><p>例如：假设已有一个 Product 类，还有ProductInfo 类 和 ProductData 类，虽然名称不同，意思却无差别。 Info 和 Data 就i想 a、an、the 一样，都是意义含混的废话。</p>
</li>
<li><p>例如：如果你需要获取账户信息，你该调用那个方法呢 ？<br>getAccount();<br>getAccounts();<br>getAccountInfo();</p>
</li>
<li><p>例如：<br>moneyAmount 和 money 没区别，<br>customerInfo 与 customer 没区别，<br>accountData 和 account 没区别，<br>theMessage 和 message 没区别 。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="4-使用读的出来的名称"><a href="#4-使用读的出来的名称" class="headerlink" title="4. 使用读的出来的名称"></a>4. 使用读的出来的名称</h2><blockquote>
<p>#####错误示例：<br><strong>1.  使用汉语拼音，只会让别人觉得你写的代码很 low.</strong></p>
<p><strong>2. 使用罕见的英语词汇</strong></p>
</blockquote>
<hr>
<h2 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5. 使用可搜索的名称"></a>5. 使用可搜索的名称</h2><blockquote>
<p>#####建议:<br><strong>1. 使用长名称，长名称胜于短名称。</strong></p>
<ul>
<li>例如： WORK_DAYS_PER_WEEK 比数字 5 好找得多。</li>
</ul>
</blockquote>
<hr>
<h2 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6. 避免使用编码"></a>6. 避免使用编码</h2><blockquote>
<p>编码已经太多，不需要自找麻烦。</p>
</blockquote>
<hr>
<h2 id="7-避免使用前缀"><a href="#7-避免使用前缀" class="headerlink" title="7. 避免使用前缀"></a>7. 避免使用前缀</h2><blockquote>
<p>不必使用 m_ 前缀来表名成员变量，很多时候阅读代码的人不会去看前缀，直接看后面有意义的名称，前缀反而成了废代码。</p>
</blockquote>
<hr>
<h2 id="8-接口和实现"><a href="#8-接口和实现" class="headerlink" title="8. 接口和实现"></a>8. 接口和实现</h2><p>略</p>
<hr>
<h2 id="9-类名"><a href="#9-类名" class="headerlink" title="9. 类名"></a>9. 类名</h2><blockquote>
<p>类名和对象名应该是名词或者名词短语，不应该是动词。</p>
<ul>
<li>正例：Customer</li>
<li>反例：CustomerInfo、CustomerData、 Data .</li>
</ul>
</blockquote>
<hr>
<h2 id="10-方法名"><a href="#10-方法名" class="headerlink" title="10. 方法名"></a>10. 方法名</h2><blockquote>
<p>方法名应该是动词或者动词短语，不应该是名词。</p>
<ul>
<li>例如：getName(); setName() 等。</li>
</ul>
</blockquote>
<hr>
<h2 id="11-避免思维映射"><a href="#11-避免思维映射" class="headerlink" title="11. 避免思维映射"></a>11. 避免思维映射</h2><blockquote>
<ul>
<li>例如：变量 i、j 通常用于 for 循环中，传统惯用这种单字母名词作为循环计数器，并不是一种好的选择。</li>
</ul>
</blockquote>
<hr>
<h2 id="12-避免使用双关语"><a href="#12-避免使用双关语" class="headerlink" title="12. 避免使用双关语"></a>12. 避免使用双关语</h2><blockquote>
<ul>
<li>例如：add方法用来添加一个对象，返回结果应该是布尔类型（添加成功或者失败） ，如果你需要添加一个对象并返回添加后产生的新值，建议使用append方法和insert方法。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式数据处理</title>
    <url>/2020/07/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h2><p>概念：</p>
<blockquote>
<ul>
<li>Stream：支持数据处理操作的源（集合、数组、输入/输出资源）生成的元素序列 。</li>
<li>备注： 流是Java 8 API的新成员，它允许你以声明性方式处理数据集合。</li>
<li><a href="https://miracle-sungm.github.io/2020/06/13/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">Lambda表达式博客链接</a>   </li>
</ul>
</blockquote>
<p>定义：</p>
<blockquote>
<ol>
<li>源： 流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>元素序列： 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。</li>
<li>数据处理操作: 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li>
</ol>
</blockquote>
<p>特点：</p>
<blockquote>
<ol>
<li>流水线： 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li>
<li>内部迭代： 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ol>
</blockquote>
<p>流的特性：</p>
<blockquote>
<ol>
<li>只能遍历一次。和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。</li>
</ol>
</blockquote>
<p>Stream API 带来的好处：</p>
<blockquote>
<ul>
<li>声明性 ： 更简洁易读</li>
<li>可复合 ： 更灵活</li>
<li>可并行 ： 性能更好</li>
</ul>
</blockquote>
<p>流与集合</p>
<blockquote>
<p>粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，集合中的每个元素都得先计算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</p>
</blockquote>
<p>流与集合的差异：</p>
<blockquote>
<ol>
<li>遍历数据的方式不同。使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</li>
<li>//TODO 待补充</li>
</ol>
</blockquote>
<h2 id="2-使用-Stream"><a href="#2-使用-Stream" class="headerlink" title="2. 使用 Stream"></a>2. 使用 Stream</h2><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th align="left">操作</th>
<th align="left">类型</th>
<th align="left">返回类型</th>
<th align="left">函数式接口</th>
<th align="left">函数描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">filter</td>
<td align="left">中间</td>
<td align="left">Stream<T></T></td>
<td align="left">Predicate<T></T></td>
<td align="left">T -&gt; boolean</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">中间(有状态 &amp; 无界)</td>
<td align="left">Stream<T></T></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">中间(有状态 &amp; 有界)</td>
<td align="left">Stream<T> long</T></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">中间(有状态 &amp; 有界)</td>
<td align="left">Stream<T> long</T></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">中间</td>
<td align="left">Stream<R></R></td>
<td align="left">Function&lt;T, R&gt;</td>
<td align="left">T -&gt; R</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">中间</td>
<td align="left">Stream<R></R></td>
<td align="left">Function&lt;T, Stream<R>&gt;</R></td>
<td align="left">T -&gt; Stream<R></R></td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">中间(有状态 &amp; 无界)</td>
<td align="left">Stream<T></T></td>
<td align="left">Comparator<T></T></td>
<td align="left">(T, T) -&gt; int</td>
</tr>
<tr>
<td align="left">anyMatch</td>
<td align="left">终端</td>
<td align="left">boolean</td>
<td align="left">Predicate<T></T></td>
<td align="left">T -&gt; boolean</td>
</tr>
<tr>
<td align="left">noneMatch</td>
<td align="left">终端</td>
<td align="left">boolean</td>
<td align="left">Predicate<T></T></td>
<td align="left">T -&gt; boolean</td>
</tr>
<tr>
<td align="left">allMatch</td>
<td align="left">终端</td>
<td align="left">boolean</td>
<td align="left">Predicate<T></T></td>
<td align="left">T -&gt; boolean</td>
</tr>
<tr>
<td align="left">findAny</td>
<td align="left">终端</td>
<td align="left">Optional<T></T></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">findFirst</td>
<td align="left">终端</td>
<td align="left">Optional<T></T></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">forEach</td>
<td align="left">终端</td>
<td align="left">void</td>
<td align="left">Consumer<T></T></td>
<td align="left">T -&gt; void</td>
</tr>
<tr>
<td align="left">collect</td>
<td align="left">终端</td>
<td align="left">R</td>
<td align="left">Collector&lt;T, A, R&gt;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">reduce</td>
<td align="left">终端(有状态 &amp; 有界)</td>
<td align="left">Optional<T></T></td>
<td align="left">BinaryOperator<T></T></td>
<td align="left">(T, T) -&gt; T</td>
</tr>
<tr>
<td align="left">count</td>
<td align="left">终端</td>
<td align="left">long</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>过滤流元素：该操作会接受一个 Predicate 函数式接口对象（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;过滤出元素小于5的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().filter(number -&gt; number &lt; 5).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h4 id="2-2-distinct"><a href="#2-2-distinct" class="headerlink" title="2.2 distinct"></a>2.2 distinct</h4><p>对流元素去重：根据流元素的hashCode和equals方法判断元素是否重复。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 1, 1, 2, 2, 2, 3, 3);</span><br><span class="line">    &#x2F;&#x2F;去重数据</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="2-3-limit"><a href="#2-3-limit" class="headerlink" title="2.3 limit"></a>2.3 limit</h4><p>截断流：该操作会接受一个 int 类型的入参，返回一个不超过给定长度的流。（如果流是有序的，则最多返回前 n 个元素）。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;截断前2个元素</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().limit(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>

<h4 id="2-4-skip"><a href="#2-4-skip" class="headerlink" title="2.4 skip"></a>2.4 skip</h4><p>跳过元素：该操作会接受一个 int 类型的入参，返回扔掉前 n 个元素的流。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;跳过前2个元素，返回剩余元素的集合</span><br><span class="line">    List&lt;Integer&gt; result &#x3D; numbers.stream().skip(2).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>映射元素： 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;将int元素映射成String元素</span><br><span class="line">    List&lt;String&gt; result &#x3D; numbers.stream().map(Object::toString).collect(Collectors.toList());</span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<h4 id="2-6-flatMap"><a href="#2-6-flatMap" class="headerlink" title="2.6 flatMap"></a>2.6 flatMap</h4><p>扁平化流： 当流的元素可以转换成另外一个流时，扁平化流会得到一个流元素的流。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; a &#x3D; Arrays.asList(&quot;a&quot;, &quot;a1&quot;);</span><br><span class="line">    List&lt;String&gt; b &#x3D; Arrays.asList(&quot;b&quot;, &quot;b1&quot;);</span><br><span class="line">    List&lt;String&gt; c &#x3D; Arrays.asList(&quot;c&quot;, &quot;c1&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; listList &#x3D; Arrays.asList(a, b, c);</span><br><span class="line">    &#x2F;&#x2F;扁平化流：将 Stream&lt;List&lt;String&gt;&gt; 流转换成一个新的 Stream&lt;String&gt; 流。</span><br><span class="line">    List&lt;String&gt; list &#x3D; listList.stream().flatMap(List::stream).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">[a, a1, b, b1, c, c1]</span><br></pre></td></tr></table></figure>

<h4 id="2-7-anyMatch"><a href="#2-7-anyMatch" class="headerlink" title="2.7 anyMatch"></a>2.7 anyMatch</h4><p>判断流中是否存在元素与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否存在与谓词匹配。（注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回true）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    if (numbers.stream().anyMatch(number -&gt; number &#x3D;&#x3D; 2)) &#123;</span><br><span class="line">        System.out.println(&quot;成功匹配到数字2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">成功匹配到数字2</span><br></pre></td></tr></table></figure>

<h4 id="2-8-allMatch"><a href="#2-8-allMatch" class="headerlink" title="2.8 allMatch"></a>2.8 allMatch</h4><p>判断流中所有元素是否都与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都与谓词匹配。 （注意：该方法执行时，若找到一个不匹配的元素，则终止操作，并返回false）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39;,&#39;结尾</span><br><span class="line">    if (list.stream().allMatch(s -&gt; s.endsWith(&quot;,&quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素均以&#39;,&#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素均以&#39;,&#39;结尾</span><br></pre></td></tr></table></figure>

<h4 id="2-9-nonMatch"><a href="#2-9-nonMatch" class="headerlink" title="2.9 nonMatch"></a>2.9 nonMatch</h4><p>与allMatch相反，nonMatch是判断流中所有元素是否都不与谓词（Predicate）匹配：接受一个 Predicate 对象，返回流元素是否都不与谓词匹配。 （注意：该方法执行时，若找到一个相匹配的元素，则终止操作，并返回false）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;1,&quot;, &quot;2,&quot;, &quot;3,&quot;, &quot;4,&quot;, &quot;5,&quot;);</span><br><span class="line">    &#x2F;&#x2F;判断元素是否都以&#39; &#39;结尾</span><br><span class="line">    if (list.stream().noneMatch(s -&gt; s.endsWith(&quot; &quot;))) &#123;</span><br><span class="line">        System.out.println(&quot;所有元素都不以&#39; &#39;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">所有元素都不以&#39; &#39;结尾</span><br></pre></td></tr></table></figure>

<h4 id="2-10-findFirst"><a href="#2-10-findFirst" class="headerlink" title="2.10 findFirst"></a>2.10 findFirst</h4><p>找到流中第一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中第一个元素。（注意：该方法执行时，找到第一个元素之后，则终止操作，并返回包含第一个元素的Optional对象）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到第一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findFirst();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="2-11-findAny"><a href="#2-11-findAny" class="headerlink" title="2.11 findAny"></a>2.11 findAny</h4><p>找到流中任何一个元素，返回一个 Optional 对象。一般情况下配合filter使用，筛选流中元素后得到流中任何一个元素。（注意：该方法执行时，找到任何一个元素之后，则终止操作，并返回包含匹配的元素的Optional对象。该方法在并行情况下效率更佳）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;找到任何一个小于5的元素</span><br><span class="line">    Optional&lt;Integer&gt; number &#x3D; numbers.stream().filter(n -&gt; n &lt; 5).findAny();</span><br><span class="line">    System.out.println(number.orElse(null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>何时使用 findFirst 和 findAny</strong></p>
<blockquote>
<p>你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p>
</blockquote>
<h4 id="2-12-reduce"><a href="#2-12-reduce" class="headerlink" title="2.12 reduce"></a>2.12 reduce</h4><p>规约：包含2个方法</p>
<p><strong>第一个方法</strong></p>
<p>该方法接受一个与流元素类型相同的泛型对象 T 和一个 BinaryOperator(该类继承了BiFunction)对象；返回一个与流元素类型相同的规约后的对象。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></p>
<p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    int number &#x3D; numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure></p>
<p><strong>第二个方法</strong></p>
<p>该方法接受一个 BinaryOperator<T> 对象；返回 Optional<T> 对象。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Stream 源码</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure></T></T></p>
<p>举例：对集合内元素求和<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer::sum);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">36</span><br></pre></td></tr></table></figure><br>举例：对集合内元素求积<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce((a, b) -&gt; a * b);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">40320</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最大值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:max);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>举例：对集合内元素最小值(若需要并行执行，可使用并行流parallelStream())<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; numberOptional &#x3D; numbers.stream().reduce(Integer:min);</span><br><span class="line">    System.out.println(numberOptional.orElse(0));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p><strong>2个方法的区别</strong></p>
<blockquote>
<p>第一个方法接受了一个对象，执行规约方法时会将入参与流中的元素规约到一起。<br>第二个方法只对流中的元素进行规约，因为源可能是空的，所以返回一个Optional对象。</p>
</blockquote>
<h4 id="2-13-count"><a href="#2-13-count" class="headerlink" title="2.13 count"></a>2.13 count</h4><p>对流中元素进行计数，返回一个long类型的对象。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().count();</span><br><span class="line">    System.out.println(count));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">8</span><br></pre></td></tr></table></figure>


<h4 id="2-14-注意："><a href="#2-14-注意：" class="headerlink" title="2.14 注意："></a>2.14 注意：</h4><blockquote>
<ul>
<li>filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你用不着为了让某些数据处理任务并行而去操心线程和锁了，Stream API都替你做好了！</li>
<li>对于流而言，某些操作（例如allMatch、anyMatch、noneMatch、findFirst和findAny）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流</li>
</ul>
</blockquote>
<hr>
<h2 id="3-数值流"><a href="#3-数值流" class="headerlink" title="3. 数值流"></a>3. 数值流</h2><p>我们在计算流中元素总和时，通常情况下会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum &#x3D; Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>这段代码问题是它暗藏拆箱成本。每个Integer都必须拆成一个原始类型再进行求和。</p>
<h4 id="3-1-原始类型特化"><a href="#3-1-原始类型特化" class="headerlink" title="3.1 原始类型特化"></a>3.1 原始类型特化</h4><p>说明：</p>
<blockquote>
<p>Java 8 引入了三个原始类型特化流接口来解决上面这个暗藏拆箱成本的问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。此外还有在必要时再把它们转换回对象流的方法。要记住的是，这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和Integer之间的效率差异。</p>
</blockquote>
<p><strong>映射到数值流</strong></p>
<blockquote>
<ul>
<li>mapToInt：    映射成IntStream</li>
<li>mapToLong：   映射成LongStream</li>
<li>mapToDouble： 映射成DoubleStream</li>
</ul>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;映射到数值流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).sum());</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).sum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转换回对象流</strong></p>
<p>通过boxed()方法，转换回对象流，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过boxed()方法，转换回对象流</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToInt(n -&gt; n).boxed().reduce(0, Integer::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToLong(n -&gt; n).boxed().reduce(0L, Long::sum));</span><br><span class="line">    System.out.println(Stream.of(1, 2, 3, 4, 5, 6, 7, 8).mapToDouble(n -&gt; n).boxed().reduce(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认值</strong></p>
<p>对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。</p>
<p><strong>数值范围</strong></p>
<p>通过使用range() 和 rangeClosed() 方法生成数值范围。</p>
<blockquote>
<ul>
<li>range(int startInclusive, int endExclusive) 方法： 生成 [startInclusive, endExclusive) 范围内数值流（左闭右开）。</li>
<li>rangeClosed(int startInclusive, int endInclusive) 方法： 生成 [startInclusive, endInclusive] 范围内数值流（左闭右闭）。</li>
</ul>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(IntStream.range(1, 100).count());</span><br><span class="line">    System.out.println(IntStream.rangeClosed(1, 100).count());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-构建流"><a href="#4-构建流" class="headerlink" title="4. 构建流"></a>4. 构建流</h2><p>这里主要介绍由集合、数值、数组、文件来创建流；最后介绍下由生成函数来创建无限流。</p>
<h4 id="4-1-由集合生成流"><a href="#4-1-由集合生成流" class="headerlink" title="4.1 由集合生成流"></a>4.1 由集合生成流</h4><p>Java 8 的 Collection 新增了 stream() 的 Api，集合对象通过调用 stream() 方法生成流。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;sungm&quot;, &quot;other&quot;);</span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure>

<h4 id="4-2-由数值生成流"><a href="#4-2-由数值生成流" class="headerlink" title="4.2 由数值生成流"></a>4.2 由数值生成流</h4><p>通过 Stream.of() 方法生成流</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;sungm&quot;, &quot;other&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-由数组生成流"><a href="#4-3-由数组生成流" class="headerlink" title="4.3 由数组生成流"></a>4.3 由数组生成流</h4><p>通过 Arrays.stream() 方法生成流</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] numbers &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(numbers);</span><br></pre></td></tr></table></figure>


<h4 id="4-4-由文件生成流"><a href="#4-4-由文件生成流" class="headerlink" title="4.4 由文件生成流"></a>4.4 由文件生成流</h4><p>java nio</p>
<blockquote>
<p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。例如：Files.lines()方法</p>
</blockquote>
<h4 id="4-5-函数生成流：创建无限流"><a href="#4-5-函数生成流：创建无限流" class="headerlink" title="4.5 函数生成流：创建无限流"></a>4.5 函数生成流：创建无限流</h4><p>Stream.iterate()方法和Stream.generate()方法：</p>
<blockquote>
<p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;我们通过使用limit()方法来截断流</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(5).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<blockquote>
<p>无限流是没有固定大小的流</p>
</blockquote>
<hr>
<h2 id="5-用流收集数据"><a href="#5-用流收集数据" class="headerlink" title="5. 用流收集数据"></a>5. 用流收集数据</h2><h4 id="5-1-Collectors-收集器"><a href="#5-1-Collectors-收集器" class="headerlink" title="5.1 Collectors (收集器)"></a>5.1 Collectors (收集器)</h4><p><strong>简介</strong></p>
<blockquote>
<ul>
<li>Stream类的collect方法是一个终端操作，类似于Stream类的reduce方法，可以接受做法作为参数，将流中的元素累积成一个汇总结果，而collect方法接受的就是一个 Collector 对象。</li>
<li>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）；再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。</li>
<li>Collectors 非常有用，因为它可以简洁和灵活的定义collect用来生成结果集合的标准。更具体地说，对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）</li>
<li>Collectors 是 Collector 的工厂类。</li>
</ul>
</blockquote>
<p><strong>预定义收集器</strong></p>
<p>Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p>
<blockquote>
<p>将流元素归约和汇总为一个值<br>元素分组<br>元素分区</p>
</blockquote>
<h4 id="5-2-归约和汇总"><a href="#5-2-归约和汇总" class="headerlink" title="5.2 归约和汇总"></a>5.2 归约和汇总</h4><h5 id="5-2-1-counting-计数"><a href="#5-2-1-counting-计数" class="headerlink" title="5.2.1 counting (计数)"></a>5.2.1 counting (计数)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    long count &#x3D; numbers.stream().collect(Collectors.counting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<p>使用 number.stream().count() 进行计数更直接，但是counting收集器在和其他收集器联合使用的时候特别有用。</p>
</blockquote>
<h5 id="5-2-2-maxBy-最大值"><a href="#5-2-2-maxBy-最大值" class="headerlink" title="5.2.2 maxBy (最大值)"></a>5.2.2 maxBy (最大值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; maxNumber &#x3D; numbers.stream().collect(Collectors.maxBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>也可以使用 numbers.stream().max(Comparator.comparingInt(a -&gt; a)) 获取最大值</p>
</blockquote>
<h5 id="5-2-3-minBy-最小值"><a href="#5-2-3-minBy-最小值" class="headerlink" title="5.2.3 minBy (最小值)"></a>5.2.3 minBy (最小值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    Optional&lt;Integer&gt; minNumber &#x3D; numbers.stream().collect(Collectors.minBy(Comparator.comparingInt(a -&gt; a)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>也可以使用 numbers.stream().min(Comparator.comparingInt(a -&gt; a)) 获取最小值</p>
</blockquote>
<h5 id="5-2-4-summingInt、summarizingLong、summarizingDouble-求和"><a href="#5-2-4-summingInt、summarizingLong、summarizingDouble-求和" class="headerlink" title="5.2.4 summingInt、summarizingLong、summarizingDouble (求和)"></a>5.2.4 summingInt、summarizingLong、summarizingDouble (求和)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求和</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>也可以将流转换成数值流之后再对数值流进行求和，例如： numbers.stream().maoToInt(a -&gt; a).sum()。</p>
</blockquote>
<h5 id="5-2-5-averagingInt、averagingLong、averagingDouble-求平均值"><a href="#5-2-5-averagingInt、averagingLong、averagingDouble-求平均值" class="headerlink" title="5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)"></a>5.2.5 averagingInt、averagingLong、averagingDouble (求平均值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;求平均值</span><br><span class="line">    double averagingInt &#x3D; numbers.stream().collect(Collectors.averagingInt(a -&gt; a));</span><br><span class="line">    double averagingLong &#x3D; numbers.stream().collect(Collectors.averagingLong(a -&gt; (long) a));</span><br><span class="line">    double averagingDouble &#x3D; numbers.stream().collect(Collectors.averagingDouble(a -&gt; (double) a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结"><a href="#5-2-6-summarizingInt、summarizingLong、summarizingDouble-对数值进行总结" class="headerlink" title="5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)"></a>5.2.6 summarizingInt、summarizingLong、summarizingDouble (对数值进行总结)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);</span><br><span class="line">    &#x2F;&#x2F;对数值进行总结，获取流元素的数值和、最大值、最小值、平均值、计数。</span><br><span class="line">    IntSummaryStatistics intSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingInt(a -&gt; a));</span><br><span class="line">    LongSummaryStatistics longSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingLong(a -&gt; (long) a));</span><br><span class="line">    DoubleSummaryStatistics doubleSummaryStatistics &#x3D; numbers.stream().collect(Collectors.summarizingDouble(a -&gt; (double) a));</span><br><span class="line"></span><br><span class="line">    System.out.println(intSummaryStatistics.toString());</span><br><span class="line">    System.out.println(longSummaryStatistics.toString());</span><br><span class="line">    System.out.println(doubleSummaryStatistics.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">IntSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">LongSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36, min&#x3D;1, average&#x3D;4.500000, max&#x3D;8&#125;</span><br><span class="line">DoubleSummaryStatistics&#123;count&#x3D;8, sum&#x3D;36.000000, min&#x3D;1.000000, average&#x3D;4.500000, max&#x3D;8.000000&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>通过一次 summarizing 操作你可以就计算出元素的个数，并得到元素总和、平均值、最大值和最小值。</p>
</blockquote>
<h5 id="5-2-7-join-连接字符串"><a href="#5-2-7-join-连接字符串" class="headerlink" title="5.2.7 join 连接字符串"></a>5.2.7 join 连接字符串</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;);</span><br><span class="line">    &#x2F;&#x2F;直接连接字符串</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining()));</span><br><span class="line">    &#x2F;&#x2F;字符串之间用指定的delimiter(定界符)连接字符</span><br><span class="line">    System.out.println(list.stream().collect(Collectors.joining(&quot;, &quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">OneTwoThreeFourFiveSix</span><br><span class="line">One, Two, Three, Four, Five, Six</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>某些情况下，可以使用String.join()方法更直接。 例如：String.join(“, “, list);</p>
</blockquote>
<h4 id="5-2-8-reducing-规约-5-2章节的重点"><a href="#5-2-8-reducing-规约-5-2章节的重点" class="headerlink" title="5.2.8 reducing 规约(5.2章节的重点)"></a>5.2.8 reducing 规约(5.2章节的重点)</h4><p><strong>Collectors类中存在3个reducing()方法，下面我们逐个介绍</strong></p>
<blockquote>
<ul>
<li>reducing(Object, Function, BinaryOperator)</li>
<li>reducing(Object, BinaryOperator)</li>
<li>reducing(BinaryOperator)</li>
</ul>
</blockquote>
<p><strong>说明：</strong></p>
<blockquote>
<p>我们上面讨论的7种方法（5.2.1 - 5.2.7）都是一个可以用 reducing 工厂方法定义的归约过程的特殊情况而已。Collectors.reducing 工厂方法是所有这些特殊情况的一般化。<br>Collectors类中存在3个reducing()方法功能类似。</p>
</blockquote>
<p><strong>方法一：reducing(Object, Function, BinaryOperator) 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? super T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<ul>
<li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li>
<li>该方法第二个参数是函数式接口Function对象，该Function对象将流元素对象转换成你所需要进行规约操作的对象</li>
<li>该方法第三个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li>
</ul>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 成绩</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-07-05 14:32</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Grade &#123;</span><br><span class="line"></span><br><span class="line">    private String studentName;</span><br><span class="line">    private String course;</span><br><span class="line">    private Double score;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略getter、setter、toString、以及无参构造方法和全参构造方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().collect(Collectors.reducing(0D, Grade::getScore, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>方法二：reducing(Object, BinaryOperator) 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, T&gt;</span><br><span class="line">reducing(T identity, BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    return new CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[0] &#x3D; op.apply(a[0], t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[0] &#x3D; op.apply(a[0], b[0]); return a; &#125;,</span><br><span class="line">            a -&gt; a[0],</span><br><span class="line">            CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<ul>
<li>该方法第一个参数是泛型对象 U， U 表示规约操作的的初始值，也就是当流中没有元素时的返回值。</li>
<li>该方法第二个参数是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li>
</ul>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学生所有课程的总成绩</span><br><span class="line">    double score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(0D, Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：reducing(BinaryOperator) 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    class OptionalBox implements Consumer&lt;T&gt; &#123;</span><br><span class="line">        T value &#x3D; null;</span><br><span class="line">        boolean present &#x3D; false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void accept(T t) &#123;</span><br><span class="line">            if (present) &#123;</span><br><span class="line">                value &#x3D; op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                value &#x3D; t;</span><br><span class="line">                present &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::new, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; if (b.present) a.accept(b.value); return a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<blockquote>
<ul>
<li>该方法入参是函数式接口BinaryOperator(二元运算符，BinaryOperator 继承了BiFunction)对象，该BinaryOperator将2个需要进行规约操作的对象，按照BinaryOperator规约成一个对象</li>
<li>该方法返回一个Optional<T>类的对象。</T></li>
</ul>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Grade&gt; grades &#x3D; Arrays.asList(new Grade(&quot;sungm&quot;, &quot;语文&quot;, 80.0)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;数学&quot;, 88.5)</span><br><span class="line">            , new Grade(&quot;sungm&quot;, &quot;英语&quot;, 88.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;语文&quot;, 58.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;数学&quot;, 51.0)</span><br><span class="line">            , new Grade(&quot;zhangsan&quot;, &quot;英语&quot;, 61.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;语文&quot;, 98.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;数学&quot;, 95.0)</span><br><span class="line">            , new Grade(&quot;diLiReBa&quot;, &quot;英语&quot;, 100.0));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;所有学视所有课程的总成绩</span><br><span class="line">    Optional&lt;Double&gt; score &#x3D; grades.stream().map(Grade::getScore).collect(Collectors.reducing(Double::sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别"><a href="#5-2-9-Stream类的reduce方法-与-Collectors类的reduce方法-的区别" class="headerlink" title="5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别"></a>5.2.9 Stream类的reduce方法 与 Collectors类的reduce方法 的区别</h4><p> 示例：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 8)</span><br><span class="line">        .boxed()</span><br><span class="line">        .reduce(new ArrayList&lt;&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; &#123;</span><br><span class="line">            l.add(e);</span><br><span class="line">            return l;</span><br><span class="line">        &#125;, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; &#123;</span><br><span class="line">            l1.addAll(l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>区别:</p>
<blockquote>
<p>Stream类的reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反，collect方法的设计就是要改变容器，从而累积要输出的结果。这意味着，上面的示例的代码片段是在滥用reduce方法，因为它在原地改变了作为累加器的List。<br>以错误的语义使用Stream类的reduce方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏List本身。在这种情况下，如果你想要线程安全，就需要每次分配一个新的List，而对象分配又会影响性能。这就是collect方法特别适合表达可变容器上的归约的原因，更关键的是它适合并行操作</p>
</blockquote>
<p>使用收集器的的好处：</p>
<blockquote>
<ul>
<li>灵活性更强：可以以不同的方法执行同样的操作。</li>
<li>根据情况选择最佳解决方案：收集器在某种程度上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</li>
</ul>
</blockquote>
<p><strong>建议：</strong></p>
<blockquote>
<p>就实际应用而言，建议使用Collectors类的reduce方法，无轮从可读性还是性能上讲，Collectors类的reduce方法都更好。</p>
</blockquote>
<h2 id="5-3-分组"><a href="#5-3-分组" class="headerlink" title="5.3 分组"></a>5.3 分组</h2><h4 id="5-3-1-groupingBy-分组"><a href="#5-3-1-groupingBy-分组" class="headerlink" title="5.3.1 groupingBy 分组"></a>5.3.1 groupingBy 分组</h4><p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Student&gt; students &#x3D; Arrays.asList(new Student(1L, &quot;miracle&quot;, 25, &quot;Boy&quot;)</span><br><span class="line">            , new Student(2L, &quot;bob&quot;, 24, &quot;Boy&quot;)</span><br><span class="line">            , new Student(3L, &quot;lucky&quot;, 22, &quot;Girl&quot;)</span><br><span class="line">            , new Student(3L, &quot;lusa&quot;, 24, &quot;Girl&quot;));</span><br><span class="line">    &#x2F;&#x2F;按照性别分组</span><br><span class="line">    Map&lt;String, List&lt;Student&gt;&gt; map &#x3D; students.stream().collect(Collectors.groupingBy(Student::getSex));</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果：</span><br><span class="line">&#123;</span><br><span class="line">    Girl&#x3D;[Student&#123;id&#x3D;3, name&#x3D;&#39;lucky&#39;, age&#x3D;22, sex&#x3D;&#39;Girl&#39;&#125;, Student&#123;id&#x3D;3, name&#x3D;&#39;lusa&#39;, age&#x3D;24, sex&#x3D;&#39;Girl&#39;&#125;], </span><br><span class="line">    Boy&#x3D;[Student&#123;id&#x3D;1, name&#x3D;&#39;miracle&#39;, age&#x3D;25, sex&#x3D;&#39;Boy&#39;&#125;, Student&#123;id&#x3D;2, name&#x3D;&#39;bob&#39;, age&#x3D;24, sex&#x3D;&#39;Boy&#39;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>示例中给groupingBy传入一个Function，我们把这个Function叫作分类函数，因为它用来把流中的元素分成不同的组。</p>
</blockquote>
<p>groupingBy源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    return groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














]]></content>
      <tags>
        <tag>Java 8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 6. 创建和开始Java线程</title>
    <url>/2020/08/12/%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%80%E5%A7%8BJava%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>一个Java线程就像一个可以执行你的Java代码的虚拟CPU。</p>
<p>当Java虚拟机创建的主线程开始执行main方法时，你的Java应用程序启动，在你的Java应用程序里面你可以创建和开始你自定义的线程。</p>
<p>Java 线程都是对象，就像其他的Java对象一样，线程对象都是 java.lang.Tread 的实例或者其子类的实例。</p>
<h3 id="1-创建和开始线程"><a href="#1-创建和开始线程" class="headerlink" title="1 创建和开始线程"></a>1 创建和开始线程</h3><p>你可以像这样创建一个线程对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread myThread &#x3D; new Thread();</span><br></pre></td></tr></table></figure>

<p>你可以像这样开始一个线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<p>创建线程的几种方式：</p>
<blockquote>
<ul>
<li>继承 java.lang.Thread 类并重写 run() 方法。</li>
<li>实现 java.lang.Runnable 接口并重写 run() 方法。</li>
<li>实现 java.util.concurrent.Callable 接口并重写 call() 方法。（备注：这种实现方式后面有 JUC 专题）</li>
</ul>
</blockquote>
<hr>
<h3 id="2-Thread-子类"><a href="#2-Thread-子类" class="headerlink" title="2 Thread 子类"></a>2 Thread 子类</h3><p>继承 java.lang.Thread 类并重写 run() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyThread running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyThread myThread &#x3D; new MyThread();</span><br><span class="line">    myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start() 方法不会等线程执行完 run()方法，run() 方法将会由其他不同的CPU执行。</p>
<hr>
<h3 id="3-实现-Runnable-接口"><a href="#3-实现-Runnable-接口" class="headerlink" title="3 实现 Runnable 接口"></a>3 实现 Runnable 接口</h3><p>第二种创建线程的方式是实现 java.lang.Runnable 接口并重写该接口的 run() 方法。一个 Java 对象实现 Runnable 接口 可以被Java Thread 类执行。</p>
<p>Runnable 接口由 JDK 提供，仅有一个 run 方法，是一个函数式接口。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Runnable 的方式有3种：</p>
<blockquote>
<ol>
<li>创建一个 Java 类实现 Runnable 接口</li>
<li>创建一个 Java 匿名类实现 Runnable 接口</li>
<li>使用 Java 8 Lambda 表达式实现 Runnable 接口</li>
</ol>
</blockquote>
<h5 id="3-1-创建一个-Java-类实现-Runnable-接口"><a href="#3-1-创建一个-Java-类实现-Runnable-接口" class="headerlink" title="3.1 创建一个 Java 类实现 Runnable 接口"></a>3.1 创建一个 Java 类实现 Runnable 接口</h5><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">     System.out.println(&quot;MyRunnable running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-创建一个-Java-匿名类实现-Runnable-接口"><a href="#3-2-创建一个-Java-匿名类实现-Runnable-接口" class="headerlink" title="3.2 创建一个 Java 匿名类实现 Runnable 接口"></a>3.2 创建一个 Java 匿名类实现 Runnable 接口</h5><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runnable myRunnable &#x3D; new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口"><a href="#3-3-使用-Java-8-Lambda-表达式实现-Runnable-接口" class="headerlink" title="3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口"></a>3.3 使用 Java 8 Lambda 表达式实现 Runnable 接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runnable runnable &#x3D; () -&gt; &#123; System.out.println(&quot;Lambda Runnable running&quot;); &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-开启一个实现了-Runnable-接口的线程"><a href="#3-4-开启一个实现了-Runnable-接口的线程" class="headerlink" title="3.4 开启一个实现了 Runnable 接口的线程"></a>3.4 开启一个实现了 Runnable 接口的线程</h5><p>java.lang.Thread的包含传入一个Runnable接口的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;or an anonymous class, or lambda...</span><br><span class="line">    Runnable runnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;executed by a thread</span><br><span class="line">    Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-使用哪种方式创建线程更好"><a href="#4-使用哪种方式创建线程更好" class="headerlink" title="4. 使用哪种方式创建线程更好 ?"></a>4. 使用哪种方式创建线程更好 ?</h3><p>关于继承Thread和实现Runnable接口，没有明确的规定用哪种方式创建线程更好，两种方式都可以让线程运行。我更倾向于使用实现Runnable接口的方式，后面我还们会了解到另外一种创建线程的方式，通过线程池创建线程的方式更加合理。</p>
<h3 id="5-常见陷阱：调用-run-代替-start"><a href="#5-常见陷阱：调用-run-代替-start" class="headerlink" title="5. 常见陷阱：调用 run() 代替 start()"></a>5. 常见陷阱：调用 run() 代替 start()</h3><p>通过调用start()，程序会告诉 CPU 线程已准备就绪，等待CPU执行 run() 方法。若直接调用 run() 方法则不会开启一个新的线程去执行 run() 方法，而是在原来的线程中去执行 run() 方法，所以当我们需要一个新的线程去执行 run() 方法中的代码时，应该调用 start() 方法启动一个线程，而不是直接调用 run() 方法。</p>
<h3 id="6-线程名（Thread-Names）"><a href="#6-线程名（Thread-Names）" class="headerlink" title="6. 线程名（Thread Names）"></a>6. 线程名（Thread Names）</h3><p>创建线程的时候可以指定线程名称，详见 java.lang.Thread API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable myRunnable &#x3D; () -&gt; System.out.println(&quot;Thread name is &quot; + Thread.currantThread().getName());</span><br><span class="line">    </span><br><span class="line">    new Thread(myRunnable, &quot;Thread One&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console out: Thread name is Thread One</span><br></pre></td></tr></table></figure>

<h3 id="7-Thread-currentThread"><a href="#7-Thread-currentThread" class="headerlink" title="7. Thread.currentThread()"></a>7. Thread.currentThread()</h3><p>通过 Thread.currentThread() 获取当前正在执行的线程对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread currentThread &#x3D; Thread.currentThread();</span><br></pre></td></tr></table></figure>

<h3 id="8-暂停线程"><a href="#8-暂停线程" class="headerlink" title="8. 暂停线程"></a>8. 暂停线程</h3><p>可以通过 Thread.sheep() 让线程睡眠指定毫秒数。这里不建议使用 thread.suspend() 方法，该方法和 Thread 类的 resume()、stop()、destroy() 都是 JDK 标注废弃方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(1000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： Thread.sheep() 方法不会释放CPU资源，如果设置锁的话也不会释放锁资源，只是让线程睡眠指定毫秒数。与 Object 类的 wait() 方法不同， wait() 方法主要用于线程通信，且 wait() 方法会释放锁资源。</p>
<h3 id="9-停止一个线程"><a href="#9-停止一个线程" class="headerlink" title="9. 停止一个线程"></a>9. 停止一个线程</h3><p>不建议使用 Thread 类提供的 stop() 方法去停止一个线程，stop() 方法会暴力停止一个线程，对程序不友好，可以通过更友好的方式停止一个线程。</p>
<p>请看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private boolean doStop &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doStop() &#123;</span><br><span class="line">        this.doStop &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized boolean keepRunning() &#123;</span><br><span class="line">        return this.doStop &#x3D;&#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(keepRunning()) &#123;</span><br><span class="line">            &#x2F;&#x2F; keep doing what this thread should do.</span><br><span class="line">            System.out.println(&quot;Running&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3L * 1000L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意 doStop() 方法和 keepRunning() 方法使用了 synchronized 关键字，后面会详细讲解 synchronized 关键字的作用，这里不做过多描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyRunnableMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10L * 1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myRunnable.doStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例通过设置一个标识，主线程里面启动子线程，然后主线程睡眠10秒钟后调用 doStop() 方法，实现在主线程中停止子线程的运行。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 3. 并发模型</title>
    <url>/2020/08/09/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>我们可以通过使用不同的并发模型来实现一个并发系统，线程之间通过协作完成系统给定的任务。不同的并发模型以不同的方式切割任务，线程之间可能存在通信和合作完成不同的任务。</p>
<h3 id="1-并发模型与分布式系统相似"><a href="#1-并发模型与分布式系统相似" class="headerlink" title="1. 并发模型与分布式系统相似"></a>1. 并发模型与分布式系统相似</h3><blockquote>
<ul>
<li>在一个并发系统中，不同的线程之间相互通信。</li>
<li>在一个分布式系统中，不同的进程之间相互通信。</li>
</ul>
</blockquote>
<p>分布式系统比并发系统面临更多的挑战，比如可能面临网络异常、远程主机或进程停止；并发系统理论上也存在相似的问题，比如CPU异常，内存或硬盘损坏等情况，这种异常的概率相对较小，但实际上是存在的。</p>
<hr>
<h3 id="2-共享状态-vs-隔离状态"><a href="#2-共享状态-vs-隔离状态" class="headerlink" title="2. 共享状态 vs 隔离状态"></a>2. 共享状态 vs 隔离状态</h3><h5 id="2-1-共享状态"><a href="#2-1-共享状态" class="headerlink" title="2.1 共享状态"></a>2.1 共享状态</h5><p>共享状态意味着同一系统的多个线程之间共享一些状态（一般指数据，共享一个或多个对象的数据）。当线程共享状态时，容易引发一些并发问题，比如死锁，竞争条件等等，这取决于线程怎样地使用和访问共享数据等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png" alt></div></p>
<h5 id="2-2-隔离状态"><a href="#2-2-隔离状态" class="headerlink" title="2.2 隔离状态"></a>2.2 隔离状态</h5><p>隔离状态意味着同一系统的多个线程之间不共享状态。如果不同的线程之间需要进行通信，可以通过交换不可变对象、或者使用复制的对象进行通信。当多个线程之间不存在共享状态（或共享数据），就可以避免最常见的并发问题。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png" alt></div></p>
<p><strong>备注</strong><br>隔离状态通常情况下可以让代码实现更加简单，并且可以不用担心发生并发访问的问题，避免一些常见的并发问题。在一些特殊情况下，使用分离状态并发设计可能存在更大的挑战。</p>
<hr>
<h3 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3. 并发模型"></a>3. 并发模型</h3><h5 id="3-1-Parallel-Workers-并行工作者并发模式"><a href="#3-1-Parallel-Workers-并行工作者并发模式" class="headerlink" title="3.1 Parallel Workers (并行工作者并发模式)"></a>3.1 Parallel Workers (并行工作者并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt></div></p>
<p><strong>并行工作者模式：</strong><br>传入的工作被分配到不同的工作者去执行，每个工作者执行完整的工作流程。工作者在不同的线程中执行。并行工作者并发模型在 Java 应用程序中很常见，JUC包中很多并发工具类的设计都采用了这种并发模型。 </p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><blockquote>
<ul>
<li>非常容易理解：如果要提高并行效率只需要增加更多的工作者</li>
</ul>
</blockquote>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><blockquote>
<ul>
<li>存在共享状态时实现更加复杂</li>
<li>工作顺序不固定</li>
</ul>
</blockquote>
<p><strong>缺点1：存在共享状态时实现更加复杂</strong><br>并行工作者模式不同线程存在共享数据时，实现变得更加复杂。共享线程通常需要访问共享对象，不论共享对象存在于内存中还是数据库中。如下图所示<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt></div></p>
<p>某些共享状态是工作队列中的通信机制，也有些共享状态是业务数据、数据缓存、数据库连接池等等。</p>
<p>并行工作者并发模式的线程之间存在共享数据时会更加复杂，当一个线程修改了共享数据变量时，需要确保其他线程读取的共享数据变量是最新的（线程修改了共享数据变量应该把数据保存至主内存中，而不是保存至线程独有的CPU高速缓存栈中）。线程需要避免死锁、竞争条件、或者其他共享状态的并发问题。</p>
<p>当某个线程正在访问共享数据结构时，其他线程会等待正在访问共享数据结构的线程执行完毕，造成阻塞。这可能导致这些线程在竞争共享数据资源，高的竞争条件会导致许多线程访问共享数据时串行执行。</p>
<p>现代非阻塞并发算法可能降低竞争并且提高性能，但是非阻塞并发算法很难实现。</p>
<p>持久性数据结构是另一种选择，当持久性数据结构被修改时，他总是保持修改前版本。当多个线程引用了某个持久性数据结构，其中某个线程对持久性数据结构做了修改时，这个修改了持久性数据结构的线程获得了最新的引用数据，而其他的线程保持原来的引用的数据。在共享数据被修改时，持久性数据结构的方式是一个很好的解决方案。</p>
<blockquote>
<p>关于持久性数据结构的举例：</p>
<ul>
<li>当某个线程给ArrayList添加一个元素时，新添加的元素对其他线程并不可见</li>
<li>也存在某些缺陷，比如LinkedList， 由于LinkedList是链表的数据结构，链表的每个元素都是一个单独的对象，这种数据结构分布在内存块中的各个地方。然而现代CPU在访问顺序的数据结构时要快的多，比如ArrayList，所以CPU在访问ArrayList时能够表现出更加卓越的性能。CPU能够一次加载一个较大的数组类型的数据结构至高速缓存中，但是无法将一个元素分布至内存各个地方的链表（ListedList）加载到CPU的高速缓存中。</li>
</ul>
</blockquote>
<p><strong>无状态工作者</strong><br>共享数据可以被系统中某个线程修改，其他线程在每次访问共享数据时必须重新读取最新的内存中的数据，以保证线程在执行中时拿到的是最新的内存副本，一个线程不始终保持自己线程独有的CPU高速缓存数据的状态称为无状态。</p>
<p><strong>缺点2：工作顺序不固定</strong><br>工作A可能被分配给线程A执行，也可能被分配给线程B执行，因此并行工作者模式的执行顺序不是固定的。</p>
<h5 id="3-2-Assembly-Line-流水线并发模式"><a href="#3-2-Assembly-Line-流水线并发模式" class="headerlink" title="3.2 Assembly Line (流水线并发模式)"></a>3.2 Assembly Line (流水线并发模式)</h5><p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt></div></p>
<p>这种模式就像工厂中流水线的工人一样，每个工作者只负责整个生产车间的一部分工作，每个工作者负责的这部分工作完成之后会传递给下一个工作者。</p>
<p>每个工作者在自己的线程内执行，不存在共享状态，流水线并发模式也被称为无共享并发模式。</p>
<p>流水线并发模式经常在非阻塞IO (NIO) 被设计使用。当一个工作者开始IO操作，其他工作者不需要等待IO操作结束。IO操作很慢，所以等待IO操作完成会浪费大量CPU时间，当IO操作完成时，IO操作的结果会被传递给其他工作者。</p>
<p>关于NIO， 在IO操作确定工人之间的界限。如图<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt></div></p>
<p>实际上，工作模式可能不只一条流水线，大多数系统可以设计多条流水线。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt></div></p>
<p>工作可能并定向到一个工作者进行并行处理。比如一个工作可能同时被分配到工作执行器和日志执行器中执行。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt></div></p>
<p>流水线并发模式也被称为反应系统或者事件响应系统。</p>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>不共享状态</li>
<li>可以顺序执行工作</li>
</ul>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<ul>
<li>作业的执行分散在各个工人</li>
<li>调试更加复杂</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>原始类型特化</title>
    <url>/2020/06/13/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%8C%96/</url>
    <content><![CDATA[<p><strong>引言</strong></p>
<blockquote>
<p>上篇我们介绍了三个函数式接口：Predicate<T>、Consumer<T>、Function&lt;T，R&gt; 。还有一些函数式接口是专门为某些类型涉及的。<a href="https://www.jianshu.com/p/4c93e1f7c19b" target="_blank" rel="noopener">https://www.jianshu.com/p/4c93e1f7c19b</a></T></T></p>
</blockquote>
<a id="more"></a>

<p> <strong>Java 类型</strong></p>
<blockquote>
<ul>
<li>引用类型（如 Byte、Integer、Long、Object、List）</li>
<li>原始类型（byte、short、int、float、double、long、char、boolean）</li>
</ul>
</blockquote>
<p> <strong>回顾知识点：</strong></p>
<blockquote>
<ul>
<li>Java 类型要么是引用类型，要么是原始类型。</li>
<li>泛型只能绑定到引用类型上面、这是由泛型内部的实现方式造成的。</li>
<li>在 Java 中有一个将原始类型转换为对应的引用类型的机制、这个机智就叫做装箱。相反的操作、也就是将引用类型转换成对应的原始类型的机制，这种机智叫做拆箱。Java 还有一个自动装拆箱的机智来帮助我们程序员执行这一任务：装箱和拆箱都是自动完成的。</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>虽然 Java 提供了自动装拆箱的机智，但这在性能方面是要付出代价的，装箱的本质是就是把原始类型包裹起来，并保存在堆里。因此、装箱后的值需要更多的内存、并需要额外的内存搜索来获取被包裹的值。因此、为提高程序的执行效率、Java  8 为我们前面所提到的函数式接口提供了一个专门的版本、以便在输入和输出都是原始类型时避免自动装拆箱的操作。</p>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;IntPredicate 源码</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface IntPredicate &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Evaluates this predicate on the given argument.</span><br><span class="line">     *</span><br><span class="line">     * @param value the input argument</span><br><span class="line">     * @return &#123;@code true&#125; if the input argument matches the predicate,</span><br><span class="line">     * otherwise &#123;@code false&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean test(int value);</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 其他默认方法省略</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<blockquote>
<p> IntPredicate 源码解析：IntPredicate 类的 test方法接收一个原始类型 int类型的入参，其返回值为 boolean，避免了输入和输出都是原始类型时自动装拆箱的操作。 </p>
</blockquote>
<p><strong>Java 8中的常用函数式接口</strong></p>
<p><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-b49768e2e438afa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-b49768e2e438afa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></div></p>
<p><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-b03a23c45dc9e0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-b03a23c45dc9e0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用函数式接口"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">常用函数式接口</span></div></div></p>
<p><strong>Lambdas及函数式接口的例子</strong><br><div class="img-item" data-src="https://upload-images.jianshu.io/upload_images/11864885-049343497380171b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sub-html=".caption"><img src="https://upload-images.jianshu.io/upload_images/11864885-049343497380171b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lambdas及函数式接口的例子"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">Lambdas及函数式接口的例子</span></div></div></p>
<hr>
<p><strong>推荐书籍</strong></p>
<blockquote>
<ul>
<li>《Java 8 in Action》</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>并行流</title>
    <url>/2020/07/09/%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>[Java 并发编程] 5. 并发和并行</title>
    <url>/2020/08/11/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="1-Concurrency-并发"><a href="#1-Concurrency-并发" class="headerlink" title="1. Concurrency 并发"></a>1. Concurrency 并发</h3><p>应用程序中（Application）同时进行一个以上的任务（Task）。对于单CPU的电脑而言，不可能同时进行一个以上的任务，CPU通过交换的执行任务直到任务都被执行完成。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png" alt></div></p>
<hr>
<h3 id="2-Parallelism-并行"><a href="#2-Parallelism-并行" class="headerlink" title="2. Parallelism 并行"></a>2. Parallelism 并行</h3><p>应用程序中的任务（Task）被切割成多个子任务（SubTask）同时执行。实现并行你的应用程序必须有多个线程在同时执行，并且至少有一个任务在执行（Task）。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png" alt></div></p>
<hr>
<h3 id="3-Concurrency-vs-Parallelism"><a href="#3-Concurrency-vs-Parallelism" class="headerlink" title="3. Concurrency vs. Parallelism"></a>3. Concurrency vs. Parallelism</h3><ul>
<li>并发是一个应用程序同时执行多个任务。</li>
<li>并行是一个应用程序处理单个任务，将单个任务切割成多个子任务并行执行。</li>
</ul>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>正确的避免NullPointException</title>
    <url>/2020/06/13/%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%81%BF%E5%85%8DNullPointException/</url>
    <content><![CDATA[<h2 id="1-正确使用-String类的-equals-方法-和-Object类的-equals-方法"><a href="#1-正确使用-String类的-equals-方法-和-Object类的-equals-方法" class="headerlink" title="1. 正确使用 String类的 equals()方法 和 Object类的 equals() 方法"></a>1. 正确使用 String类的 equals()方法 和 Object类的 equals() 方法</h2><blockquote>
<p>已知对象在前，未知对象在后。注意：已知对象不为 null</p>
</blockquote>
<a id="more"></a>

<p>######正确示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String name &#x3D; &quot;sungm&quot;; </span><br><span class="line">    &#x2F;&#x2F;name为已知对象且被赋予初始值不为空</span><br><span class="line">    if (name.equals(getOtherName())) &#123;</span><br><span class="line">        &#x2F;&#x2F;todo do something</span><br><span class="line">        System.out.println(&quot;todo do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String getOtherName() &#123;</span><br><span class="line">    return &quot;sungm&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>######错误示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    String name &#x3D; &quot;sungm&quot;;</span><br><span class="line">    &#x2F;&#x2F;getOtherName()方法返回值为 null。抛出NPE</span><br><span class="line">    if (getOtherName().equals(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F;todo do something</span><br><span class="line">        System.out.println(&quot;todo do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String getOtherName() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-未知对象转String使用String-valueOf-方法"><a href="#2-未知对象转String使用String-valueOf-方法" class="headerlink" title="2. 未知对象转String使用String.valueOf()方法"></a>2. 未知对象转String使用String.valueOf()方法</h2><blockquote>
<p>空对象调用 toString() 方法会抛出NPE，使用 String.valueOf() 替代</p>
</blockquote>
<p>#####示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;抛NPE</span><br><span class="line">    System.out.println(getPrice().toString());</span><br><span class="line">    &#x2F;&#x2F;不抛NPE</span><br><span class="line">    System.out.println(String.valueOf(getPrice()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static BigDecimal getPrice() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="String-valueOf-方法源码"><a href="#String-valueOf-方法源码" class="headerlink" title="String.valueOf() 方法源码"></a>String.valueOf() 方法源码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj &#x3D;&#x3D; null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-使用第三方类库或者自己封装的工具类"><a href="#3-使用第三方类库或者自己封装的工具类" class="headerlink" title="3. 使用第三方类库或者自己封装的工具类"></a>3. 使用第三方类库或者自己封装的工具类</h2><blockquote>
<p>例如 Apache 的 StringUtils 类</p>
</blockquote>
<p>#####Apache 的 StringUtils工具类部分源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static boolean isEmpty(String str) &#123;</span><br><span class="line">    return str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isNotEmpty(String str) &#123;</span><br><span class="line">    return !isEmpty(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isBlank(String str) &#123;</span><br><span class="line">    int strLen;</span><br><span class="line">    if (str !&#x3D; null &amp;&amp; (strLen &#x3D; str.length()) !&#x3D; 0) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; strLen; ++i) &#123;</span><br><span class="line">            if (!Character.isWhitespace(str.charAt(i))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isNotBlank(String str) &#123;</span><br><span class="line">    return !isBlank(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#####Apache 中 StringUtils 中 isEmpty() 方法 和 isBlank() 方法的区别：</p>
<blockquote>
<p>1: isEmpty() 方法：当Sting为null或者空（””）时返回true<br>2: isBlank() 方法 ：当Sting为null或者空（””）或者空字符串（”     “）时返回true</p>
</blockquote>
<p>#####示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    String empty &#x3D; null;</span><br><span class="line">    System.out.println(StringUtils.isEmpty(empty));</span><br><span class="line"></span><br><span class="line">    empty &#x3D; &quot;&quot;;</span><br><span class="line">    System.out.println(StringUtils.isEmpty(empty));</span><br><span class="line"></span><br><span class="line">    empty &#x3D; &quot;      &quot;;</span><br><span class="line">    System.out.println(StringUtils.isBlank(empty));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-避免自动拆箱可能抛出NPE"><a href="#4-避免自动拆箱可能抛出NPE" class="headerlink" title="4. 避免自动拆箱可能抛出NPE"></a>4. 避免自动拆箱可能抛出NPE</h2><blockquote>
<p>自动拆箱可能抛出NPE</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;反例</span><br><span class="line">public int function() &#123;</span><br><span class="line">    return Integer对象;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-数据库查出的数据可能为null，做空判断"><a href="#5-数据库查出的数据可能为null，做空判断" class="headerlink" title="5. 数据库查出的数据可能为null，做空判断"></a>5. 数据库查出的数据可能为null，做空判断</h2><blockquote>
<p>数据库非空字段可以加非空约束；对可能为空的字段做空判断、防止NPE。</p>
</blockquote>
<hr>
<h2 id="6-级联调用容易抛出NPE，建议使用Java-8-的-Optional类"><a href="#6-级联调用容易抛出NPE，建议使用Java-8-的-Optional类" class="headerlink" title="6. 级联调用容易抛出NPE，建议使用Java 8 的 Optional类"></a>6. 级联调用容易抛出NPE，建议使用Java 8 的 Optional类</h2><blockquote>
<p>例如 object.getMehtodA().getMethodB().getMethodC()；很容易抛出NPE</p>
</blockquote>
<hr>
<h2 id="7-远程调用返回对象容易抛出NPE，建议做空判断"><a href="#7-远程调用返回对象容易抛出NPE，建议做空判断" class="headerlink" title="7. 远程调用返回对象容易抛出NPE，建议做空判断"></a>7. 远程调用返回对象容易抛出NPE，建议做空判断</h2><blockquote>
<p>调用第三方接口等返回对象可能为空，建议对该对象操作之前做空判断。</p>
</blockquote>
<hr>
<h2 id="8-取Session中-的值之前做空判断"><a href="#8-取Session中-的值之前做空判断" class="headerlink" title="8. 取Session中 的值之前做空判断"></a>8. 取Session中 的值之前做空判断</h2><blockquote>
<p> 取Session的值之前对Session做空判断，对获取的Session值操作之前对Session值做空判断、避免NPE</p>
</blockquote>
<hr>
<h2 id="9-对集合的操作之前做空判断"><a href="#9-对集合的操作之前做空判断" class="headerlink" title="9. 对集合的操作之前做空判断"></a>9. 对集合的操作之前做空判断</h2><blockquote>
<p> 取集合中的值之前对集合做空判断，对获取的集合值操作之前对集合值做空判断、避免NPE</p>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 7. 竞争条件和临界区</title>
    <url>/2020/08/12/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</url>
    <content><![CDATA[<p>竞争条件是临界区可能发生的一种特殊状况。临界区是为了避免多线程产生并发问题而让多个线程顺序执行的那一段代码（我查阅了很多资源，对比了一些博客网站，对临界区的描述各不一致，这里只是我对临界区的一种理解，如果您有更好的描述，请告知小弟）。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 9. 线程安全和不变性</title>
    <url>/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%8F%98%E6%80%A7/</url>
    <content><![CDATA[<p>竞争条件只发生在多个线程同时访问相同资源，并且存在一个或多个线程修改了共享资源，如果多个线程只读共享资源那么不会产生竞争条件。</p>
<p>下面我们通过一个实例来说明当一个共享资源被多个线程访问，但没有线程修改共享资源时不会产生竞争条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImmutableValue&#123;</span><br><span class="line"></span><br><span class="line">  private int value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue(int value)&#123;</span><br><span class="line">    this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意 ImmutableValue 提供了一个传入指定 value 的构造函数，一旦对象被创建，该对象没有提供任何修改value值的方法，所以value的值无法被修改。</p>
<h3 id="特别注意：对象引用不是线程安全的"><a href="#特别注意：对象引用不是线程安全的" class="headerlink" title="特别注意：对象引用不是线程安全的"></a>特别注意：对象引用不是线程安全的</h3><p>需要注意的是，当一个对象不可变时对象本身是线程安全的，但是对象的引用可能不是线程安全的。举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  private ImmutableValue currentValue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public ImmutableValue getImmutableValue()&#123;</span><br><span class="line">    return currentValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setImmutableValue(ImmutableValue newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void add(int newValue)&#123;</span><br><span class="line">    this.currentValue &#x3D; new ImmutableValue(currentValue.getValue() + newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Calculator 类引用了一个 ImmutableValue 对象，请注意它可以通过 setImmutableValue() 方法和 add() 方法改变了 ImmutableValue 对象的引用。换句话说，即使 ImmutableValue 对象是不可变的，但它也是非线程安全的。ImmutableValue 类是线程安全的，但对象的引用是非线程安全的。<strong>所以特别注意：对象的引用可能是非线程安全的。</strong> 可以通过给 setImmutableValue() 方法和 add() 方法加锁（使用 synchronized 关键字等）保证线程安全。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 4. 相同线程</title>
    <url>/2020/08/11/%E7%9B%B8%E5%90%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>相同线程是一个从单线程系统扩展到多个相同的单线程的系统的并发模型，结果是多个相同的线程在计算机中并行执行。</p>
<p>一个相同线程的系统不是纯粹的单线程系统，因为它包含多个线程，每个线程执行就像一个单线程系统，所以用相同线程或者同一线程命名更加合理。</p>
<h3 id="1-为什么用单线程系统？"><a href="#1-为什么用单线程系统？" class="headerlink" title="1. 为什么用单线程系统？"></a>1. 为什么用单线程系统？</h3><p>你可能会想为什么每个人都能设计出单线程系统。单线程系统受欢迎的原因是因为单线程系统的并发模型比多线程系统的并发模型更加简单。单线程系统线程之间不共享任何状态（对象/数据），单线程系统可以不使用任何并发数据结构，并且更好地利用CPU和CPU缓存。</p>
<p>遗憾的是，单线程系统不能很好的利用现代CPU，现代CPU通常情况下拥有多个CPU内核，每个CPU内核的功能就像一个独立的单核CPU，一个单线程系统只能利用CPU中的一个内核，模型如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0.png" alt></div></p>
<hr>
<h3 id="2-相同线程（单线程系统的扩展）"><a href="#2-相同线程（单线程系统的扩展）" class="headerlink" title="2. 相同线程（单线程系统的扩展）"></a>2. 相同线程（单线程系统的扩展）</h3><p>为了充分的利用CPU的内核，一个单线程系统可以扩展到利用整个计算机。</p>
<h5 id="一个CPU内核执行一个线程"><a href="#一个CPU内核执行一个线程" class="headerlink" title="一个CPU内核执行一个线程"></a>一个CPU内核执行一个线程</h5><p>相同线程系统通常让计算机中每个CPU内核执行一个线程，如果一个计算机有4个CPU，每个CPU拥有4个CPU内核，让每个CPU内核执行一个线程的示例如下：<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-0-1.png" alt></div></p>
<hr>
<h3 id="3-不共享状态（数据）"><a href="#3-不共享状态（数据）" class="headerlink" title="3. 不共享状态（数据）"></a>3. 不共享状态（数据）</h3><p>一个相同线程系统与传统的多线程系统相似，因为一个相同线程系统有多个线程同时执行，但是两者有一些区别。</p>
<p>相同线程系统与多线程系统不同的是相同线程系统不共享状态（或不共享数据），当产生并发访问时不共享数据，没有并发数据结构等等。<br><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/same-threading-4.png" alt></div></p>
<p>不共享数据让相同线程系统看上去像单线程系统。因为相同线程系统可以包含多个单线程，因此取名相同线程系统更加合理。</p>
<p>相同线程系统基本含义是进程同时包含处理多个相同的线程，在相同线程系统中并发时没有线程共享数据。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 8. 线程安全和共享资源</title>
    <url>/2020/08/12/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>线程安全：代码同时被多个线程安全地调用。如果一段代码是安全的，那它不包含竞争条件。竞争条件只发生在多个线程更新共享资源的时候，因此当Java线程执行的时候，知道哪些资源是线程共享资源是非常重要的。</p>
<h3 id="1-Local-variables-本地变量-局部变量"><a href="#1-Local-variables-本地变量-局部变量" class="headerlink" title="1. Local variables (本地变量/局部变量)"></a>1. Local variables (本地变量/局部变量)</h3><p>局部变量保存在每个线程独有的线程栈中，因此局部变量在线程之间是不共享的。也就是说所有的局部变量都是线程安全的。举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void someMethod()&#123;</span><br><span class="line">    long threadSafeInt &#x3D; 0;</span><br><span class="line">    threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Local-Object-References-本地对象引用-局部对象引用"><a href="#2-Local-Object-References-本地对象引用-局部对象引用" class="headerlink" title="2. Local Object References (本地对象引用/局部对象引用)"></a>2. Local Object References (本地对象引用/局部对象引用)</h3><p>本地对象引用有所不同，引用本身是不共享的，同样也是保存在线程独有的线程栈中，线程之间不共享引用。但是引用的对象不是保存在线程栈中，而是保存在主内存堆中，理论上讲所有的线程都能够访问内存堆中存储的对象（但是要有对象的引用）。</p>
<p>如果一个对象创建之后没有离开创建它的方法，那么是线程安全的。事实上传递这个对象的引用给其他的方法，只要这个对象的引用没有传递给其他的线程，那么这个对象都不会成为共享对象，始终是线程安全的。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void methodOne()&#123;</span><br><span class="line">  LocalObject localObject &#x3D; new LocalObject();</span><br><span class="line">  methodTwo(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo(LocalObject localObject)&#123;</span><br><span class="line">  localObject.setValue(&quot;value&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中：对象 localObject 在 methodOne() 方法中被创建，然后传递给 methodTwo()，localObject 没有传递给其他线程; 每个线程执行 methodOne() 时会都创建一个新的 LocalObject 对象，且 LocalObject 对象的引用都保存在各自的线程栈中，因此是 methodOne() 线程安全的，尽管 LocalObject 存在多个实例对象，但使用它们是线程安全的。</p>
<p><strong>但有一种场景例外：</strong> 当某个方法将 localObject 对象的引用作为参数传递给了其他线程，那么可能会造成线程不安全。</p>
<h3 id="3-Object-Member-Variables-对象成员变量"><a href="#3-Object-Member-Variables-对象成员变量" class="headerlink" title="3. Object Member Variables (对象成员变量)"></a>3. Object Member Variables (对象成员变量)</h3><p>对象成员变量随对象保存在堆内存中。因此当两个线程调用了某个方法，这个方法引用了同一个对象并修改了这个对象的成员变量时，那么这个方法时线程不安全的。示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public add(String text)&#123;</span><br><span class="line">        this.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个线程同时调用同一个 NotThreadSafe 对象的 add() 方法时，会导致竞争条件发生。 示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NotThreadSafe sharedInstance &#x3D; new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"></span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance &#x3D; instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    this.instance.add(&quot;some text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意有 2 个 MyRunnable 对象共享了 sharedInstance 对象，因此当他们同时调用 sharedInstance.add() 方法时，会发生竞争条件。</p>
<p>然而，当 2 个线程同时调用不对对象的 add() 方法时，不会产生竞争条件。示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br><span class="line">new Thread(new MyRunnable(new NotThreadSafe())).start();</span><br></pre></td></tr></table></figure>

<h3 id="4-线程安全规则"><a href="#4-线程安全规则" class="headerlink" title="4. 线程安全规则"></a>4. 线程安全规则</h3><p>当你想确认你的代码访问某些资源的时候是否是线程安全的，你可以使用下面这个规则：</p>
<blockquote>
<p><strong>如果资源的创建、使用和销毁都没有离开某个方法，并且没有分享给其他线程，那么使用这个资源是线程安全的。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 16. 死锁和预防死锁</title>
    <url>/2020/08/27/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="1-线程死锁"><a href="#1-线程死锁" class="headerlink" title="1. 线程死锁"></a>1. 线程死锁</h3><p>死锁：两个或多个线程因为竞争资源而造成的一种僵局。</p>
<p>示例：线程A拥有锁a，线程B拥有锁b，线程A尝试获取锁b，线程B尝试获取锁a，因此产生死锁。线程A将永远无法获取锁b，同样线程B也无法获取锁a。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for a</span><br></pre></td></tr></table></figure>
<p>说明：线程A和线程B必须分别拥有锁a、锁b，同时等待彼此释放锁才会造成死锁的发生，若线程A等待获取锁B时线程B释放了锁B，那么不会造成死锁。</p>
<p>更复杂的死锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread A    locks a, wait for b</span><br><span class="line">Thread B    locks b, wait for c</span><br><span class="line">Thread C    locks c, wait for d</span><br><span class="line">Thread D    locks d, wait for e</span><br></pre></td></tr></table></figure>
<p>线程A等待线程B释放锁，线程B等待线程C释放锁，线程C等待线程D释放锁，线程D等待线程A释放锁，造成更加复杂的死锁。</p>
<hr>
<h3 id="2-数据库死锁"><a href="#2-数据库死锁" class="headerlink" title="2. 数据库死锁"></a>2. 数据库死锁</h3><p>一个更加复杂的死锁，是数据库的事务。一个数据库事务可能由很多个 update 语句组成。当一条记录在某个事务中被更新时，其他事务更新这条记录需要等待第一个事务提交，同一个事务中的每个 update 语句可能会锁住数据库中的一些数据记录。</p>
<p>当多个事务同时需要更新一些记录，就可能产生数据库死锁。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transaction A   第一个update请求： 锁住记录1</span><br><span class="line">Transaction B   第一个update请求： 锁住记录2</span><br><span class="line">Transaction A   第二个update请求： 尝试修改并锁住记录2</span><br><span class="line">Transaction B   第二个update请求： 尝试修改并锁住记录1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-预防死锁"><a href="#3-预防死锁" class="headerlink" title="3. 预防死锁"></a>3. 预防死锁</h3><p>一些防止死锁的方法：</p>
<blockquote>
<ul>
<li>锁排序</li>
<li>锁超时</li>
<li>死锁检测</li>
</ul>
</blockquote>
<h5 id="3-1-锁排序"><a href="#3-1-锁排序" class="headerlink" title="3.1 锁排序"></a>3.1 锁排序</h5><p>当多个线程以不同的顺序竞争一些锁资源时，可能产生死锁。</p>
<p>如果你能确保所有的线程按照一定的顺序获取锁资源，就不会产生死锁。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread A:</span><br><span class="line">    lock a</span><br><span class="line">    lock b</span><br><span class="line"></span><br><span class="line">Thread B:</span><br><span class="line">    wait for a</span><br><span class="line">    lock c (when a lock)</span><br><span class="line"></span><br><span class="line">Thread C:</span><br><span class="line">    wait for a:</span><br><span class="line">    wait for b:</span><br><span class="line">    wait for c:</span><br></pre></td></tr></table></figure>

<p>示例中的线程C，它必须按照 a -&gt; b -&gt; c 的顺序获取对应的锁，在未获取顺序排在前面的锁之前线程C无法获取后的锁。</p>
<p>示例中：一旦线程A获得了锁a，线程B和线程C必须等待线程A释放锁a之后才竞争获取锁a，之后它们必须按顺序获取锁b或锁c.</p>
<p><strong>锁排序是一种非常简单有效的预防死锁机制。然而，你需要已知所有的锁，然后给它们设定顺序。我们并非总能已知所有的锁。</strong></p>
<h5 id="3-2-锁超时"><a href="#3-2-锁超时" class="headerlink" title="3.2 锁超时"></a>3.2 锁超时</h5><p>另外一种预防死锁的机制是：给线程在尝试获取锁的时候设置一个超时时间，如果指定时间内未获取锁则放弃。如果一个线程在给定时间范围内未获取到所有有需要的锁，它将会阻塞并释放自身拥有的所有锁资源，等待一个随机的时间之后重新进入。这个随机的等待时间内，其他的线程可以获取锁资源或释放一些锁资源，改变锁资源的状态，这样使得应用程序避免死锁的发生。</p>
<p>示例：假设有2个线程分别是线程1，线程2按不同的顺序获取锁A，锁B</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程1获取锁资源A</span><br><span class="line">线程2获取锁资源B</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B但是锁B被线程2获取了</span><br><span class="line">线程2尝试获取锁资源A但是锁A被线程1获取了</span><br><span class="line"></span><br><span class="line">线程1尝试获取锁资源B 超时</span><br><span class="line">线程1阻塞并释放锁资源A</span><br><span class="line">线程1等待一个随机的时间（比如198毫秒）之后重新进入</span><br><span class="line"></span><br><span class="line">线程2尝试获取锁资源A 超时</span><br><span class="line">线程2阻塞并释放锁资源B</span><br><span class="line">线程2等待一个随机的时间（比如221毫秒）之后重新进入</span><br></pre></td></tr></table></figure>

<p>注意的是：线程尝试获取锁超时不一定意味着发生了死锁。因为存在其他的因素，比如持有锁的线程在设定的时间内未执行完任务，持有锁未释放锁导致其他线程尝试获取锁超时。</p>
<p>另外，当足够多的线程竞争同一个锁资源时，可能导致一些线程尝试获取锁时一次又一次的发生锁超时。</p>
<p>设置锁超时的预防死锁的机制有一个问题是：当线程进入synchronized代码块时，你无法给线程尝试进入synchronized代码块设置一个超时时间。你必须使用一个自定义的锁类或者使用 Java 5 提供的 JUC 包内的一些工具类。</p>
<h5 id="3-3-锁排序-vs-锁超时"><a href="#3-3-锁排序-vs-锁超时" class="headerlink" title="3.3 锁排序 vs. 锁超时"></a>3.3 锁排序 vs. 锁超时</h5><div class="table-responsive">
<table class="table table-bordered table-striped">
<thead>
<tr>
<th align="left">类型</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">锁排序</td>
<td align="left">简单，易实现</td>
<td align="left">适用于所有已知的锁资源，并设定锁的顺序</td>
</tr>
<tr>
<td align="left">锁超时</td>
<td align="left">灵活，不需要已知所有的锁资源</td>
<td align="left">复杂，线程获取锁资源时需设定超时时间，一般情况下使用juc工具包中的类，无法给synchronized关键字设定超时时间</td>
</tr>
</tbody></table>
<h5 id="3-4-死锁检测"><a href="#3-4-死锁检测" class="headerlink" title="3.4 死锁检测"></a>3.4 死锁检测</h5><p>死锁检测是一种沉重的防止死锁机制。通常在设置锁顺序、设置锁超时是不可行的情况下使用。</p>
<p>每个线程获取锁时需要在一个数据结构（例如map、graph）中记录线程和锁资源的信息，另外，无论何时线程请求锁也需要记录到一个数据结构中，后面通过检测这个数据结构来预防死锁的发生。</p>
<p>当一个线程尝试获取锁时被拒绝，这个线程可以通过定义的数据结构来检测系统是否发生了死锁。</p>
<p>线程A持有锁1，线程B持有锁2，线程C持有锁3，线程D持有锁4，且线程A尝试获取锁2，线程B尝试获取锁3，线程C尝试获取锁4，线程D尝试获取锁1。那么定义的数据结构示例如下：</p>
<p><div class="img-item" data-src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" data-sub-html=".caption"><img src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png" alt></div></p>
<p>当线程A持有锁1，且尝试获取锁2被拒时，那么可以通过定义的数据结构获取到持有锁2的线程B，再获取到线程B尝试获取的锁3，再循环上面的算法得到锁三的持有线程C，获取线程C尝试获取的锁4，再循环得到锁4的持有线程D，得到线程D之后获取到线程D尝试获取的锁1，这时候检测到锁1被自己（线程A）持有，那么就检测出了系统存在死锁。</p>
<p>简单地说，每当一个线程获取锁被拒绝时，这个线程根据定义的数据结构检测系统是否存在死锁，具体做法是以递归的形式遍历获取失败的锁以及获取失败的锁的所属线程，判断线程获取失败的锁是否与原始线程（获取锁失败并检测死锁的那个线程）持有的锁是否相同，如果原始线程拥有的锁中包含某个线程尝试获取的锁，那么就说明系统存在死锁，否则不存在死锁。</p>
<p>那么怎么处理死锁呢？</p>
<ol>
<li>当某个线程获取某个锁失败时，并检测到死锁，其中一种比较简单的做法是当前检测到死锁的线程释放所有的锁资源，以便其他线程获取到当前线程释放的锁资源，同时当前线程阻塞一个随机的时间段后重新进入，这有点类似于设置锁超时的做法。</li>
<li>另外一个更好的做法是指定一些线程的优先级，只让少量线程造成阻塞，剩余的线程在没有死锁发生的情况下继续执行任务。</li>
</ol>
<h3 id="3-5-预防死锁小结"><a href="#3-5-预防死锁小结" class="headerlink" title="3.5 预防死锁小结"></a>3.5 预防死锁小结</h3><p>通常情况下，设置获取锁的顺序是一种常见的、比较简单的预防死锁的方案，但不适用于锁数量过多和存在未知的锁资源时使用。在通过设置锁顺序方案不可行或难实行的情况下，我们可以使用juc工具包中的一些类来设置获取锁时间的方案，不过这种方案不适用于synchronized关键字。在前两种方案都比较困难实行的情况下，可以使用死锁检测的方案来检测死锁并处理死锁。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑使用静态工厂方法代替构造方法</title>
    <url>/2020/06/13/%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-静态工厂方法例子："><a href="#1-静态工厂方法例子：" class="headerlink" title="1. 静态工厂方法例子："></a>1. 静态工厂方法例子：</h2><p>如Boolean类中的valueOf(boolean b) 方法</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The &#123;@code Boolean&#125; object corresponding to the primitive</span><br><span class="line"> * value &#123;@code true&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final Boolean TRUE &#x3D; new Boolean(true);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The &#123;@code Boolean&#125; object corresponding to the primitive</span><br><span class="line"> * value &#123;@code false&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final Boolean FALSE &#x3D; new Boolean(false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;...中间代码省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态工厂方法</span><br><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">    return (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>静态工厂方法与工厂方法模式不同，类可以直接提供静态工厂方法，而不是公共的构造方法。</p>
<h2 id="2-使用静态工厂方法代替构造方法的优缺点"><a href="#2-使用静态工厂方法代替构造方法的优缺点" class="headerlink" title="2. 使用静态工厂方法代替构造方法的优缺点"></a>2. 使用静态工厂方法代替构造方法的优缺点</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>（1）. 静态工厂方法不像构造方法，它们是有名字的。（属于类的方法）<br>（2）. 静态工厂方法与构造方法不同，他们被调用时不需要每次都创建一个对象。例如调用Boolean.valueOf(true)方法，返回的是Boolean类中定义的静态不变属性TRUE对象；<br>（3）. 静态工厂方法与构造方法不同，他们可以返回任意对象，构造方法只能返回当前类的对象。<br>（4）. 静态工厂方法返回对象的类可以根据输入类型不同而不同。例如使用泛型。<br>（5）. 在编写该方法的类时，返回的对象的类不需要存在。（static关键字的作用）</p>
<h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>（1）. 只提供静态工厂方法、没有提供公共或者受保护的构造方法时不能被子类化。（主要限制）<br>（2）. 静态工厂方法并不像构造方法那样突出、不容易被程序员阅读。</p>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>静态工厂方法和公共构造方法都有他们的用途，并且了解他们的相对有点时值得的。通常，静态工厂方法更可取，因此避免在没有考虑静态工厂方法的情况下、提供公共构造方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 15. 线程通信</title>
    <url>/2020/08/21/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="1-通过共享对象实现线程通信"><a href="#1-通过共享对象实现线程通信" class="headerlink" title="1. 通过共享对象实现线程通信"></a>1. 通过共享对象实现线程通信</h3><p>线程通过在共享对象中发送一个信号实现与其他线程通信。如下图所示，设置一个成员变量 hasProcess，线程A通过setHasProcess同步方法设置hasProcess的值，这样线程B可以读取到成员变量hasProcess的值，实现线程之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MySignal &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasProcess &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void setHasProcess(boolean hasProcess) &#123; this.hasProcess &#x3D; hasProcess; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean getHasProcess() &#123; return this.hasProcess; &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程A和线程B必须引用共享对象 MySignal 的实例来实现线程A与线程B之间的线程通信。如果线程A和线程B引用了不同的MySignal实例对象，那么线程A和线程B不会检测到彼此发送的信号，达不到线程通信的目的。</p>
<hr>
<h3 id="2-Busy-Wait"><a href="#2-Busy-Wait" class="headerlink" title="2. Busy Wait"></a>2. Busy Wait</h3><p>上例中线程B需要等待信号处理数据，因此它的业务代码很可能一直在等待信号，浪费了很多CPU资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySignal singal &#x3D; ...</span><br><span class="line"></span><br><span class="line">while (!singal.getHasProcess()) &#123;</span><br><span class="line">    &#x2F;&#x2F;do nothing... busy waiting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们不知道线程A什么时候发送信号，因此导致线程B一直等待线程A的信号，没做任何事情，浪费CPU资源。</p>
<hr>
<h3 id="3-等待通知机制：wait-、notify-、notifyAll"><a href="#3-等待通知机制：wait-、notify-、notifyAll" class="headerlink" title="3. 等待通知机制：wait()、notify()、notifyAll()"></a>3. 等待通知机制：wait()、notify()、notifyAll()</h3><p>Busy waiting 浪费了CPU资源，即使某些情况下等待的时间非常短暂。因此，让等待信号的线程在接收信号之前处于无效状态，直到接收信号之后（被唤醒）继续执行代码，这是一种非常聪明的做法。</p>
<p><strong>等待通知机制：</strong>让等待信号的线程在接收信号之前处于无效状态（不占用CPU资源，线程暂停执行），由发出信号的线程唤醒等待信号的线程，等待信号的线程被唤醒后继续执行，这就是等待通知机制。</p>
<p>Java 有一个等待机制：让等待信号的线程处于无效状态。Java Object 类定义了三个方法分别是wait()、notify()、notifyAll()，通过这三个方法我们可以实现这种机制。</p>
<p>一个线程调用了某个对象的 wait() 方法之后，这个线程就成为无效状态，直到另外一个线程调用了同一个对象的 notify() 方法或者 notifyAll()方法之后，原来处于无效状态的线程才结束无效状态。</p>
<p>线程调用某个对象的 wait() 方法或者 notify() 方法必须获取这个对象的锁，也就是说 wait() 方法或者 notify() 方法调用的代码必须包含在 synchronized 代码块中，synchronized 监视器必须是 wait() 或 nofity() 方法所属的那个对象。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;监视器对象</span><br><span class="line">public class MonitorObject &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyWaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    MonitorObject myMonitorObject &#x3D; new MonitorObject();</span><br><span class="line"></span><br><span class="line">    public void doWait() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;wait()方法必须包含在synchronized代码块中，且synchronized监视器是wait()方法所属对象myMonitorObject</span><br><span class="line">                myMonitorObject.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doNotify() &#123;</span><br><span class="line">        synchronized (myMonitorObject) &#123;</span><br><span class="line">            &#x2F;&#x2F;notify()方法必须包含在synchronized代码块中，且synchronized监视器是notify()方法所属对象myMonitorObject</span><br><span class="line">            myMonitorObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程调用某个对象的notify()方法，会唤醒一个等待状态的线程；通过调用notifyAll()方法，唤醒所有处于等待状态的线程。</p>
<p>你可以从上例中观察到<strong>wait()方法和notify()方法都在同步代码块中，并且同步代码块的监视器对象与调用wait方法（或notify方法）的对象是同一个对象</strong>。这是强制的，一个线程不能在没有持有某个对象锁的方法上调用wait方法或notify方法，否则程序将抛出 IllegalMonitorStateException (非法监视器状态异常)。</p>
<p>你可能会想：当等待线程进入synchronized代码块调用wait方法使得线程进入等待状态，并没有退出synchronized代码块，那么等待线程就会阻止唤醒线程进入synchronized代码块调用notify()方法，那么唤醒线程怎么可能能够进入synchronized代码块呢？答案是唤醒线程可以进入synchronized代码块调用notify方法，原因是当一个线程调用了wait方法之后，当前线程会释放基于某个对象的持有锁，这样其他的线程就有机会进入synchronized代码块。</p>
<p>一旦一个线程被唤醒，它不能立即退出wait()方法，等待线程需要等待唤醒线程退出包含notify()方法的synchronized代码块之后，等待线程需要重新获取对象的持有锁之后退出wait方法，然后继续执行下面的代码。</p>
<p>使用notifyAll()唤醒多个等待线程，那么多个等待线程也需要等唤醒线程退出synchronized代码块之后，各个等待线程需要重新获取对象的持有锁才能退出wait()方法继续执行程序，由于各个等待线程的synchronized代码块的监视器是同一个对象，因此各个线程之间是同步退出wait()方法。</p>
<p>小结：</p>
<ul>
<li>Java 的等待通知机制是基于某个对象实现的一种等待通知机制。</li>
<li>Java Object 类定义的 wait()、notify()、notifyAll()用于线程通信，这些方法的调用必须包含在以这些方法的对象为监视器的synchronized代码块中，否则程序将抛出IllegalMonitorStateException异常。</li>
<li>当一个线程调用wait()方法后，线程会释放基于这个方法的对象的持有锁，并使线程进入无效状态，只有当其他线程调用了同一个对象的notify方法（或notifyAll方法）之后，这个对象才可能被唤醒，等待线程需等唤醒线程退出包含notify方法（或notifyAll方法）的synchronized代码块之后，才能重新获取对象的持有锁并退出wait方法继续执行程序。</li>
<li>当一个线程调用某个对象的notifyAll方法后，所有基于这个对象的等待中的线程将全部被唤醒，但这些等待中的线程需要等唤醒线程退出包含notifyAll方法的synchronized代码块之后，同步的获取对象的持有锁并退出wait()方法。</li>
</ul>
<hr>
<h3 id="4-丢失信号"><a href="#4-丢失信号" class="headerlink" title="4. 丢失信号"></a>4. 丢失信号</h3><p>当一个线程调用notify方法时没有线程处于等待状态，那么这个唤醒信号就被丢失了。丢失信号可能会导致程序产生一些问题，也可能不会产生一些问题，但我们需要知道这种情况可能发生。在某些情况下，丢失信号可能导致一些等待线程一直处于等待中，从未被唤醒，因为唤醒线程调用notify方法发生在等待线程调用wait方法之前。</p>
<p>为了避免这个问题，我们可以将信号保存在共享数据对象中，这里就不在举例了。</p>
<hr>
<h3 id="5-虚假唤醒"><a href="#5-虚假唤醒" class="headerlink" title="5. 虚假唤醒"></a>5. 虚假唤醒</h3><p>请看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 程序入口 </span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 17:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static int number &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock &#x3D; new Lock();</span><br><span class="line">        </span><br><span class="line">        Runnable myRunnable &#x3D; () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                number++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        new Thread(myRunnable, &quot;Thread A&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread B&quot;).start();</span><br><span class="line">        new Thread(myRunnable, &quot;Thread C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义锁</span><br><span class="line"> *</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean hasLocked &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLocked) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLocked &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unLock() &#123;</span><br><span class="line">        hasLocked &#x3D; false;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>现在我们来分析下上面代码中可能会存在什么问题？</strong></p>
<p>首先假设线程A调用了lock()方法获取到了锁，然后执行number++操作时，此时线程B进入lock()方法（锁已被线程A获取），因此线程B调用wait()方法进入等待状态，之后线程A调用了unLock()方法释放锁资源并唤醒一个线程，因为这里只有线程B处于wait状态，因此线程B被唤醒，线程B等待重新进入synchronized代码块，若此时线程C优先于线程B进入lock同步方法，锁归线程C所有，当线程C退出lock方法后，线程B进入synchronized退出wait方法，继续执行下面的程序代码，那么此时锁同时被线程B和线程C拥有，出现了不同步的操作，这样容易导致程序出现问题。</p>
<p><strong>现在我们来解决上面代码存在的问题</strong></p>
<p>我们只要将lock()方法中的if(hasLocked)判断条件换成while(hasLocked)代码块，就能很好的解决上面这个问题，while(hasLocked)我们称它为“自旋锁”。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">    while (hasLocked) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    hasLocked &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当线程B退出wait()方法后继续判断hasLocked条件是否为真，仅当锁没有被任何线程锁拥有时才真正的唤醒线程，否则线程继续等待。</p>
<h3 id="当多个线程等待同一个信号"><a href="#当多个线程等待同一个信号" class="headerlink" title="当多个线程等待同一个信号"></a>当多个线程等待同一个信号</h3><p>自旋锁在处理多个线程等待同一个信号时也是一种很好的方案，我们会使用notifyAll()方法唤醒等待的所有线程，同时只有一个线程能够退出wait()方法，当某个线程退出wait()方法后，这个线程会修改hasLocked的值，当其他线程退出wait方法时会自旋判断hasLocked，若锁被其他线程拥有，会继续进入等待状态，从而避免程序产生一些不正常的操作。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>解析XML</title>
    <url>/2020/06/16/%E8%A7%A3%E6%9E%90XML/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Java 8 官方API : <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8 API</a></li>
<li>github代码地址: <a href="https://github.com/miracle-sungm/learn_xml" target="_blank" rel="noopener">Github</a></li>
</ul>
</blockquote>
<hr>
<h2 id="1-DOM解析XML"><a href="#1-DOM解析XML" class="headerlink" title="1. DOM解析XML"></a>1. DOM解析XML</h2><p><strong>xml文档</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p><strong>程序入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.w3c.dom.*;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-16 16:59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者工厂实例（设计模式：工厂模式）</span><br><span class="line">        DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个xml解析器的文档构建者实例（设计模式：Builder模式）</span><br><span class="line">        DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">        &#x2F;&#x2F;使用xml解析器builder解析文档，获取解析后的Document对象</span><br><span class="line">        Document document &#x3D; builder.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取根元素</span><br><span class="line">        Element rootElement &#x3D; document.getDocumentElement();</span><br><span class="line">        &#x2F;&#x2F;获取文档中student元素列表（也可以直接通过document.getElementsByTagName(&quot;student&quot;)获取所有的student元素）</span><br><span class="line">        NodeList studentNodes &#x3D; rootElement.getElementsByTagName(&quot;student&quot;);</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; studentNodes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            Element element &#x3D; (Element) studentNodes.item(index);</span><br><span class="line">            &#x2F;&#x2F;元素（备注：通过getElementsByTagName()方法获取指定的元素）</span><br><span class="line">            Element nameElement &#x3D; (Element) element.getElementsByTagName(&quot;name&quot;).item(0);</span><br><span class="line">            Element ageElement &#x3D; (Element) element.getElementsByTagName(&quot;age&quot;).item(0);</span><br><span class="line">            Element sexElement &#x3D; (Element) element.getElementsByTagName(&quot;sex&quot;).item(0);</span><br><span class="line">            Element classElement &#x3D; (Element) element.getElementsByTagName(&quot;className&quot;).item(0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;文本（备注：通过getNodeName()方法获取元素名称，通过getTextContent()方法获取文本内容）</span><br><span class="line">            System.out.println(nameElement.getNodeName()  + &quot; : &quot; + nameElement.getTextContent());</span><br><span class="line">            System.out.println(ageElement.getNodeName()   + &quot; : &quot; + ageElement.getTextContent());</span><br><span class="line">            System.out.println(sexElement.getNodeName()   + &quot; : &quot; + sexElement.getTextContent());</span><br><span class="line">            System.out.println(classElement.getNodeName() + &quot; : &quot; + classElement.getTextContent());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;属性（备注：通过getAttributeNode(name)方法属性节点，通过getAttribute(name)方法获取属性内容）</span><br><span class="line">            Attr nameAttr &#x3D; nameElement.getAttributeNode(&quot;nameAttr&quot;);</span><br><span class="line">            Attr ageAttr &#x3D; ageElement.getAttributeNode(&quot;ageAttr&quot;);</span><br><span class="line">            Attr sexAttr &#x3D; sexElement.getAttributeNode(&quot;sexAttr&quot;);</span><br><span class="line">            Attr classAttr &#x3D; classElement.getAttributeNode(&quot;classAttr&quot;);</span><br><span class="line">            System.out.println(nameAttr.getName()  + &quot; : &quot; + nameAttr.getValue());</span><br><span class="line">            System.out.println(ageAttr.getName()   + &quot; : &quot; + ageAttr.getValue());</span><br><span class="line">            System.out.println(sexAttr.getName()   + &quot; : &quot; + sexAttr.getValue());</span><br><span class="line">            System.out.println(classAttr.getName()   + &quot; : &quot; + classAttr.getValue());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name : sungm</span><br><span class="line">age : 25</span><br><span class="line">sex : Man</span><br><span class="line">className : Class One</span><br><span class="line">nameAttr : sungm</span><br><span class="line">ageAttr : 25</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassOne</span><br><span class="line"></span><br><span class="line">name : sunhw</span><br><span class="line">age : 1</span><br><span class="line">sex : Man</span><br><span class="line">className : Class Two</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">ageAttr : 1</span><br><span class="line">sexAttr : Man</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>树结构，方便理解与使用</li>
<li>解析过程中树结构保存在内存中，方便修改</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>当文件过大时耗用内存，需谨慎使用</li>
</ul>
</blockquote>
<hr>
<h2 id="2-SAX解析XML"><a href="#2-SAX解析XML" class="headerlink" title="2. SAX解析XML"></a>2. SAX解析XML</h2><p><strong>xml文档</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p><strong>自定义Handler处理器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.xml.sax.Attributes;</span><br><span class="line">import org.xml.sax.SAXException;</span><br><span class="line">import org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:42</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StudentParserHandler extends DefaultHandler &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String ROOT_ELEMENT &#x3D; &quot;class&quot;;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法执行顺序：startDocument -&gt; startElement -&gt; characters -&gt; endElement -&gt; characters -&gt; endDocument</span><br><span class="line">    &#x2F;&#x2F;执行次数        只执行一次      元素循环执行    元素循环执行   元素循环执行   元素循环执行    只执行一次</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startDocument() throws SAXException &#123;</span><br><span class="line">        super.startDocument();</span><br><span class="line">        System.out.println(&quot;开始解析XML文档&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endDocument() throws SAXException &#123;</span><br><span class="line">        super.endDocument();</span><br><span class="line">        System.out.println(&quot;解析XML文档结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">        super.startElement(uri, localName, qName, attributes);</span><br><span class="line">        System.out.println(Constants.ROOT_ELEMENT.equals(qName) ? &quot;开始解析根节点&quot; : &quot;节点名称 ： &quot; + qName);</span><br><span class="line">        &#x2F;&#x2F;获取元素的属性</span><br><span class="line">        for (int index &#x3D; 0, size &#x3D; attributes.getLength(); index &lt; size; index++) &#123;</span><br><span class="line">            String attrName &#x3D; attributes.getLocalName(index);</span><br><span class="line">            String attrValue &#x3D; attributes.getValue(index);</span><br><span class="line">            System.out.println(&quot;attrName &#x3D; &quot; + attrName + &quot;, attrValue &#x3D; &quot; + attrValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void endElement(String uri, String localName, String qName) throws SAXException &#123;</span><br><span class="line">        super.endElement(uri, localName, qName);</span><br><span class="line">        if (Constants.ROOT_ELEMENT.equals(qName)) &#123;</span><br><span class="line">            System.out.println(&quot;解析根节点结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void characters(char[] ch, int start, int length) throws SAXException &#123;</span><br><span class="line">        super.characters(ch, start, length);</span><br><span class="line">        String value &#x3D; new String(ch, start, length).trim();</span><br><span class="line">        if (!Constants.EMPTY.equals(value)) &#123;</span><br><span class="line">            System.out.println(&quot;节点值：&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line">import javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-17 17:33</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析工厂实例</span><br><span class="line">        SAXParserFactory saxParserFactory &#x3D; SAXParserFactory.newInstance();</span><br><span class="line">        &#x2F;&#x2F;获取一个Sax解析器实例</span><br><span class="line">        SAXParser saxParser &#x3D; saxParserFactory.newSAXParser();</span><br><span class="line">        &#x2F;&#x2F;创建一个Handel实例</span><br><span class="line">        StudentParserHandler handler &#x3D; new StudentParserHandler();</span><br><span class="line">        &#x2F;&#x2F;解析文件</span><br><span class="line">        saxParser.parse(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始解析XML文档</span><br><span class="line">开始解析根节点</span><br><span class="line">节点名称 ： class</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sungm</span><br><span class="line">节点值：sungm</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 25</span><br><span class="line">节点值：25</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassOne</span><br><span class="line">节点值：Class One</span><br><span class="line">节点名称 ： student</span><br><span class="line">节点名称 ： name</span><br><span class="line">attrName &#x3D; nameAttr, attrValue &#x3D; sunhw</span><br><span class="line">节点值：sunhw</span><br><span class="line">节点名称 ： age</span><br><span class="line">attrName &#x3D; ageAttr, attrValue &#x3D; 1</span><br><span class="line">节点值：1</span><br><span class="line">节点名称 ： sex</span><br><span class="line">attrName &#x3D; sexAttr, attrValue &#x3D; Man</span><br><span class="line">节点值：Man</span><br><span class="line">节点名称 ： className</span><br><span class="line">attrName &#x3D; classAttr, attrValue &#x3D; ClassTwo</span><br><span class="line">节点值：Class Two</span><br><span class="line">解析根节点结束</span><br><span class="line">解析XML文档结束</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>采用事件驱动的方式，耗用内存更少</li>
<li>适用于只需要处理xml文件的数据时使用</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>需编写自定义的handler类，不易编写</li>
<li>很难同时访问同一个xml中的不同数据</li>
</ul>
</blockquote>
<hr>
<h2 id="3-JDOM解析XML"><a href="#3-JDOM解析XML" class="headerlink" title="3. JDOM解析XML"></a>3. JDOM解析XML</h2><p><strong>引入依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jdom&#x2F;jdom --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>XML</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p><strong>程序入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.jdom2.Attribute;</span><br><span class="line">import org.jdom2.Document;</span><br><span class="line">import org.jdom2.Element;</span><br><span class="line">import org.jdom2.input.SAXBuilder;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 10:46</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    interface Constants &#123;</span><br><span class="line"></span><br><span class="line">        String EMPTY &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        SAXBuilder saxBuilder &#x3D; new SAXBuilder();</span><br><span class="line">        Document document &#x3D; saxBuilder.build(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element rootElement &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：&quot; + rootElement.getName());</span><br><span class="line">        parseElement(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        &#x2F;&#x2F;元素内容</span><br><span class="line">        if (element.getText() !&#x3D; null &amp;&amp; !Constants.EMPTY.equals(element.getTextTrim())) &#123;</span><br><span class="line">            System.out.println(element.getName() + &quot;:&quot; + element.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;元素属性</span><br><span class="line">        if (element.hasAttributes()) &#123;</span><br><span class="line">            element.getAttributes().forEach(Main::parseAttribute);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;解析子元素</span><br><span class="line">        List&lt;Element&gt; childrenElement &#x3D; element.getChildren();</span><br><span class="line">        if (childrenElement !&#x3D; null &amp;&amp; childrenElement.size() &gt; 0) &#123;</span><br><span class="line">            childrenElement.forEach(Main::parseElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Attribute attribute) &#123;</span><br><span class="line">        System.out.println(attribute.getName() + &quot; : &quot; + attribute.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根节点：class</span><br><span class="line">name:sungm</span><br><span class="line">nameAttr : sungm</span><br><span class="line">age:25</span><br><span class="line">ageAttr : 25</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class One</span><br><span class="line">classAttr : ClassOne</span><br><span class="line">name:sunhw</span><br><span class="line">nameAttr : sunhw</span><br><span class="line">age:1</span><br><span class="line">ageAttr : 1</span><br><span class="line">sex:Man</span><br><span class="line">sexAttr : Man</span><br><span class="line">className:Class Two</span><br><span class="line">classAttr : ClassTwo</span><br></pre></td></tr></table></figure>


<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>API简单易用，推荐使用</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>用了很多具体类，没使用接口</li>
</ul>
</blockquote>
<hr>
<h2 id="4-DOM4J解析XML"><a href="#4-DOM4J解析XML" class="headerlink" title="4. DOM4J解析XML"></a>4. DOM4J解析XML</h2><p><strong>引入依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;dom4j&#x2F;dom4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>XML</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sungm&quot;&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;25&quot;&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassOne&quot;&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student&gt;</span><br><span class="line">        &lt;name nameAttr&#x3D;&quot;sunhw&quot;&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age ageAttr&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex sexAttr&#x3D;&quot;Man&quot;&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className classAttr&#x3D;&quot;ClassTwo&quot;&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>

<p><strong>程序入口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.dom4j.Attribute;</span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-18 11:27</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SAXReader reader &#x3D; new SAXReader();</span><br><span class="line">        Document document &#x3D; reader.read(&quot;src&#x2F;main&#x2F;resources&#x2F;student.xml&quot;);</span><br><span class="line">        Element element &#x3D; document.getRootElement();</span><br><span class="line">        System.out.println(&quot;根节点：名称 &#x3D; &quot; + element.getName());</span><br><span class="line">        &#x2F;&#x2F;递归解析</span><br><span class="line">        parseElement(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private static void parseElement(Element element) &#123;</span><br><span class="line">        System.out.println(&quot;节点：名称 &#x3D; &quot; + element.getName() + &quot;, value &#x3D; &quot; + element.getTextTrim());</span><br><span class="line">        Iterator iterator &#x3D; element.elementIterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Element childElement &#x3D; (Element) iterator.next();</span><br><span class="line">            &#x2F;&#x2F;解析属性</span><br><span class="line">            if (childElement.attributeCount() &gt; 0) &#123;</span><br><span class="line">                childElement.attributes().forEach(Main::parseAttribute);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;解析元素</span><br><span class="line">            parseElement(childElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseAttribute(Object attribute) &#123;</span><br><span class="line">        System.out.println(&quot;属性：&quot; + ((Attribute) attribute).getName() + &quot; : &quot; + ((Attribute) attribute).getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根节点：名称 &#x3D; class</span><br><span class="line">节点：名称 &#x3D; class, value &#x3D; </span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sungm</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sungm</span><br><span class="line">属性：ageAttr : 25</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 25</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassOne</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class One</span><br><span class="line">节点：名称 &#x3D; student, value &#x3D; </span><br><span class="line">属性：nameAttr : sunhw</span><br><span class="line">节点：名称 &#x3D; name, value &#x3D; sunhw</span><br><span class="line">属性：ageAttr : 1</span><br><span class="line">节点：名称 &#x3D; age, value &#x3D; 1</span><br><span class="line">属性：sexAttr : Man</span><br><span class="line">节点：名称 &#x3D; sex, value &#x3D; Man</span><br><span class="line">属性：classAttr : ClassTwo</span><br><span class="line">节点：名称 &#x3D; className, value &#x3D; Class Two</span><br></pre></td></tr></table></figure>


<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>使用了接口和抽象方案，是个优秀的API</li>
<li>灵活性好、性能优异、易用性好。推荐使用</li>
</ul>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>通用Builder</title>
    <url>/2020/06/15/%E9%80%9A%E7%94%A8Builder/</url>
    <content><![CDATA[<blockquote>
<p>直接上代码</p>
</blockquote>
<blockquote>
<p>Builder类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Builder&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Supplier&lt;T&gt; supplier;</span><br><span class="line">    private List&lt;Consumer&lt;T&gt;&gt; consumers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private Builder(Supplier&lt;T&gt; supplier) &#123;</span><br><span class="line">        this.supplier &#x3D; supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Builder&lt;T&gt; of(Supplier&lt;T&gt; supplier) &#123;</span><br><span class="line">        return new Builder&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;U&gt; Builder&lt;T&gt; with(BiConsumer&lt;T, U&gt; biConsumer, U u) &#123;</span><br><span class="line">        consumers.add(supplier -&gt; biConsumer.accept(supplier, u));</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T build() &#123;</span><br><span class="line">        T value &#x3D; supplier.get();</span><br><span class="line">        consumers.forEach(consumer -&gt; consumer.accept(value));</span><br><span class="line">        consumers.clear();</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>POJO</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:15</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Main方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @since : 2020-06-15 11:15</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person sungm &#x3D; Builder.of(Person::new)</span><br><span class="line">                .with(Person::setName, &quot;孙广明&quot;)</span><br><span class="line">                .with(Person::setAge, 25)</span><br><span class="line">                .with(Person::setSex, &quot;男&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(sungm.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果集 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person&#123;name&#x3D;&#39;孙广明&#39;, age&#x3D;25, sex&#x3D;&#39;男&#39;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>工具类</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java 并发编程] 17. 饥饿与公平</title>
    <url>/2020/09/01/%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/</url>
    <content><![CDATA[<p>一个线程没有获取到CPU时间片，因为CPU时间片总是被其他线程获取，这种情况我们叫它“饥饿”。线程被“饿死”是因为没有获取CPU时间片执行指令。解决“饥饿”的办法成为“公平” —— 所有的线程公平的获取CPU时间片执行指令。</p>
<hr>
<h3 id="1-Java-中常见饥饿的场景"><a href="#1-Java-中常见饥饿的场景" class="headerlink" title="1. Java 中常见饥饿的场景"></a>1. Java 中常见饥饿的场景</h3><blockquote>
<ul>
<li>具有高优先性的线程比低优先性的线程更容易获取CPU时间片。</li>
<li>线程无限期阻塞等待进入synchronized代码块，因为其他线程在不断地被允许访问synchronized代码块。</li>
<li>线程调用了wait方法，一直未被唤醒，因为总有其他的线程被唤醒（调用notify方法），而不是它。</li>
</ul>
</blockquote>
<h5 id="1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片"><a href="#1-1-高优先性的线程比低优先性的线程更容易获取CPU时间片" class="headerlink" title="1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片"></a>1.1 高优先性的线程比低优先性的线程更容易获取CPU时间片</h5><p>你可以通过setPriority()方法（Thread类的方法，取值范围是[1-10]）设置每个线程的优先级。具有高优先性的线程比低优先性的线程更容易获取CPU时间片，具体怎么执行依赖于我们的操作系统。</p>
<h5 id="1-2-线程无限期阻塞等待进入synchronized代码块"><a href="#1-2-线程无限期阻塞等待进入synchronized代码块" class="headerlink" title="1.2 线程无限期阻塞等待进入synchronized代码块"></a>1.2 线程无限期阻塞等待进入synchronized代码块</h5><p>Java synchronized 代码块不保证线程按照等待进入synchronized代码块的顺序进入synchronized代码块，首先等待进入synchronized代码块的线程不一定先进入synchronized代码快。这就意味着系统可能存在某些线程无限期的等待进入synchronized代码块的风险，因为其他线程在不断的访问它。</p>
<h5 id="1-3-线程调用了wait方法，一直未被唤醒"><a href="#1-3-线程调用了wait方法，一直未被唤醒" class="headerlink" title="1.3 线程调用了wait方法，一直未被唤醒"></a>1.3 线程调用了wait方法，一直未被唤醒</h5><p>我们都知道wait()、notify()、notifyAll() 方法用于线程通信。在多个等待线程调用了wait()方法时，某个唤醒线程调用了notify() 方法会唤醒某个等待线程，但它不保证某个线程一定会被唤醒，它唤醒的是等待线程中的任意一个线程。因此当多个线程调用了wait方法，其中某些线程可能一直处于等待状态，因为总有线程被唤醒，而不是它们。</p>
<hr>
<h3 id="2-Java-中实现公平"><a href="#2-Java-中实现公平" class="headerlink" title="2. Java 中实现公平"></a>2. Java 中实现公平</h3><p>尽管Java中不可能百分之百实现公平，但我们可以实现我们的同步机制来提高不同线程之间的公平性。</p>
<p>示例：synchronized 代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">  public synchronized void doSynchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;do a lot of work which takes a long time</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个线程调用doSynchronized()方法，只有一个线程能够进入该方法，其他线程会造成阻塞直到进入doSynchronized()方法的线程退出。如果多个线程被阻塞，当某个线程退出synchronized代码块后，不确定下一次进入synchronized代码块的线程是哪个线程。</p>
<h5 id="2-1-使用Lock代替synchronized代码块"><a href="#2-1-使用Lock代替synchronized代码块" class="headerlink" title="2.1 使用Lock代替synchronized代码块"></a>2.1 使用Lock代替synchronized代码块</h5><p>为了提高等待线程进入同步代码块的公平性，通过自定义的Lock代替synchronized代码块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">    public synchronized void doSynchronized() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line"></span><br><span class="line">        lock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意doSynchronized()方法没有使用synchronized关键字声明，取而代之的是Lock类的lock()和unLock()方法，Lock类的实现可以是下面这种方式（也可以使用juc包下的Lock，这里先尝试自己实现Lock）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author : sungm</span><br><span class="line"> * @date : 2020-09-01 16:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Lock &#123;</span><br><span class="line">    </span><br><span class="line">    private boolean hasLock &#x3D; false;</span><br><span class="line">    private Thread lockThread &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private synchronized void lock() throws InterruptedException &#123;</span><br><span class="line">        if (hasLock) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        hasLock &#x3D; true;</span><br><span class="line">        lockThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private synchronized void unLock() &#123;</span><br><span class="line">        if (lockThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread is not lock thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        hasLock &#x3D; false;</span><br><span class="line">        lockThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请仔细看Lock类的实现，你会发现当多个线程访问lock()方法时会造成阻塞，因为它使用了synchronized关键字。如果锁已经被锁定，其他线程调用lock方法进入无效状态（调用了wait方法），锁的每次释放，都将唤醒一个wait状态的线程(unLock方法里面调用了notify方法)。</p>
<p>之前我们提到过，当多个线程同时调用synchronized代码块会造成阻塞，synchronized关键字不会确保线程按顺序进入synchronized代码块。同样，当多个线程调用了wait方法，某个唤醒线程调用notify方法不能唤醒某个指定的等待线程。因此上面的示例是不是一个公平的锁，但是我们可以对它做修改，实现一个公平锁。</p>
<p><strong>公平锁</strong></p>
<p>可参考 java.util.concurrent.locks.ReentrantLock 类中的内部类 FairSync 同步锁。</p>
]]></content>
      <tags>
        <tag>Java 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>验证XML</title>
    <url>/2020/06/18/%E9%AA%8C%E8%AF%81XML/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote>
<ul>
<li>如果我们解析XML之后，获取到XML的内容，再校验XML内容或格式是否符合设计规范，这个工作是很繁琐的。</li>
<li>幸好，XML解析器的一个很大的好处就是它能够自动校验某个文档是否具有正确的结构，这样解析工作就变的简单的多。</li>
<li>通过定义一个 <a href="https://www.w3school.com.cn/dtd/dtd_intro.asp" target="_blank" rel="noopener">DTD</a> 或者 <a href="https://www.w3school.com.cn/schema/schema_intro.asp" target="_blank" rel="noopener">XML Schema</a>， DTD 或者 Schema 包含了用于解释文档如何构成的规则，这些规则指定了每个元素的合法子元素和属性。</li>
</ul>
</blockquote>
<hr>
<h2 id="2-定义DTD校验规则"><a href="#2-定义DTD校验规则" class="headerlink" title="2. 定义DTD校验规则"></a>2. 定义DTD校验规则</h2><p><strong>XML文档</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!-- 定义DTD校验规则 --&gt;</span><br><span class="line">&lt;!DOCTYPE class [</span><br><span class="line">    &lt;!-- 定义class至少包含一个student --&gt;</span><br><span class="line">    &lt;!ELEMENT class (student+)&gt;</span><br><span class="line">    &lt;!-- 定义student只包含name,age,sex,className属性 --&gt;</span><br><span class="line">    &lt;!ELEMENT student (name, age, sex, className)&gt;</span><br><span class="line">        &lt;!-- 定义id属性, 属性默认值为0 --&gt;</span><br><span class="line">        &lt;!ATTLIST student id CDATA &quot;0&quot;&gt;</span><br><span class="line">    &lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">    &lt;!ELEMENT className (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;class&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;sungm&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;25&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class One&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">    &lt;student id&#x3D;&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;sunhw&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;1&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;sex&gt;Man&lt;&#x2F;sex&gt;</span><br><span class="line">        &lt;className&gt;Class Two&lt;&#x2F;className&gt;</span><br><span class="line">    &lt;&#x2F;student&gt;</span><br><span class="line">&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Java</tag>
        <tag>XML</tag>
      </tags>
  </entry>
</search>
